+ **************************************************
+ ST220 Architecture Database
+ **************************************************

+ ======================================================= +
+=add
+opcode 00000
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Add
+stage_3_0
result1 = operand1 + operand2;

+ ======================================================= +
+=addcg
+opcode 0010
+formats cgen
+resources ALU
+op1 name=result1, stage=3
+op2 name=result2, stage=3
+op3 name=operand1, stage=2, type=signed
+op4 name=operand2, stage=2, type=signed
+op5 name=operand3, stage=2, type=unsigned
+summary Add with carry and generate carry
+stage_3_0
result1 = (operand1 + operand2) + operand3; 
result2 = Bit(result1, 32);

+ ======================================================= +
+=and
+opcode 01001
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Bitwise and
+stage_3_0
result1 = operand1 & operand2;

+ ======================================================= +
+=andc
+opcode 01010
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Complement and bitwise and
+stage_3_0
result1 = (~operand1) & operand2;

+ ======================================================= +
+=andl
+opcode 1010
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Logical and
+stage_3_0
result1 = (operand1 != 0) AND (operand2 != 0);

+ ======================================================= +
+=br
+opcode 0
+formats Branch
+resources BRANCH
+op1 name=operand1, stage=1, type=unsigned
+op2 name=operand2, stage=1, type=signed
+summary Branch
+state1 name=PC, kind=src, stage=1
+state2 name=PC, kind=dst, stage=1
+stage_1_0
IF (operand1 != 0) 
	PC = Register(ZeroExtend_32_(PC) + (operand2 << 2));

+ ======================================================= +
+=break
+opcode 1111111
+formats SysOp
+resources ALU
+summary Break
+stage_3_0
THROW ILL_INST;

+ ======================================================= +
+=brf
+opcode 1
+formats Branch
+resources BRANCH
+op1 name=operand1, stage=1, type=unsigned
+op2 name=operand2, stage=1, type=signed
+summary Branch false
+state1 name=PC, kind=src, stage=1
+state2 name=PC, kind=dst, stage=1
+stage_1_0
IF (operand1 == 0) 
	PC = Register(ZeroExtend_32_(PC) + (operand2 << 2));

+ ======================================================= +
+=bswap
+opcode 10100
+formats Int3R
+resources ALU
+op1 name=result1, stage=3
+op3 name=operand1, stage=2, type=unsigned
+temp1 name=byte0
+temp2 name=byte1
+temp3 name=byte2
+temp4 name=byte3
+summary Byte swap
+syntax bswap %1 = %3
+stage_3_0
byte0 = BitsOf(operand1,0,8);
byte1 = BitsOf(operand1,8,8);
byte2 = BitsOf(operand1,16,8);
byte3 = BitsOf(operand1,24,8);
result1 = ((byte0 << 24) | (byte1 << 16)) | ((byte2 << 8) | byte3);

+ ======================================================= +
+=call
+opcode 000
+formats Call
+field0 LNK=0
+resources CALL
+op1 name=operand1, stage=0, type=signed
+state1 name=LR, kind=dst, stage=1
+state2 name=PC, kind=dst, stage=1
+summary Jump and link
+stage_1_0
PC = Register(ZeroExtend_32_(PC) + (operand2 << 2));
+stage_5_0
LR = PC;

+ ======================================================= +
+=cmpeq
+opcode 0000
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Test for equality
+stage_3_0
result1 = operand1 == operand2;

+ ======================================================= +
+=cmpge
+opcode 0010
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed compare equal or greater than
+stage_3_0
result1 = operand1 >= operand2;

+ ======================================================= +
+=cmpgeu
+opcode 0011
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned compare equal or greater than
+stage_3_0
result1 = operand1 >= operand2;

+ ======================================================= +
+=cmpgt
+opcode 0100
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed compare greater than
+stage_3_0
result1 = operand1 > operand2;

+ ======================================================= +
+=cmpgtu
+opcode 0101
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned compare greater than
+stage_3_0
result1 = operand1 > operand2;

+ ======================================================= +
+=cmple
+opcode 0110
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed compare equal or less than
+stage_3_0
result1 = operand1 <= operand2;

+ ======================================================= +
+=cmpleu
+opcode 0111
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned compare equal or less than
+stage_3_0
result1 = operand1 <= operand2;

+ ======================================================= +
+=cmplt
+opcode 1000
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed compare less than
+stage_3_0
result1 = operand1 < operand2;

+ ======================================================= +
+=cmpltu
+opcode 1001
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned compare less than
+stage_3_0
result1 = operand1 < operand2;

+ ======================================================= +
+=cmpne
+opcode 0001
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Test for inequality
+stage_3_0
result1 = operand1 != operand2;

+ ======================================================= +
+=divs
+opcode 0100
+formats cgen
+resources ALU
+op1 name=result1, stage=3
+op2 name=result2, stage=3
+op3 name=operand1, stage=2, type=signed
+op4 name=operand2, stage=2, type=signed
+op5 name=operand3, stage=2, type=unsigned
+summary Non-restoring divide stage
+temp1 name=temp
+stage_3_0
temp = ZeroExtend_32_(operand1 * 2) + operand3; 
IF (operand1 < 0) 
{ 
    result1 = temp + operand2; 
    result2 = 1; 
} 
ELSE 
{ 
    result1 = temp - operand2; 
    result2 = 0; 
}

+ ======================================================= +
+=goto
+opcode 001
+formats Call
+field0 LNK=0
+resources CALL
+op1 name=operand1, stage=1, type=signed
+state1 name=PC, kind=dst, stage=1
+summary Jump
+stage_1_0
PC = Register(ZeroExtend_32_(PC) + (operand1 << 2));

+ ======================================================= +
+=icall
+opcode 000
+formats Call
+field0 LNK=1
+resources CALL
+state1 name=LR, kind=dst, stage=3
+state2 name=LR, kind=src, stage=-1
+state3 name=PC, kind=dst, stage=1
+summary Jump (using Link Register) and link
+syntax call LR = LR
+stage_1_0
PC = LR;
+stage_5_0
LR = PC;

+ ======================================================= +
+=igoto
+opcode 001
+formats Call
+field0 LNK=1
+resources CALL
+state1 name=LR, kind=src, stage=-1
+state2 name=PC, kind=dst, stage=1
+summary Jump (using Link Register)
+syntax goto LR
+stage_1_0
PC = LR;

+ ======================================================= +
+=imml
+opcode 01010
+formats Imm
+resources IMM
+op1 name=extension, stage=2, type=unsigned
+summary Long immediate for previous syllable

+ ======================================================= +
+=immr
+opcode 01011
+formats Imm
+resources IMM
+op1 name=extension, stage=2, type=unsigned
+summary Long immediate for next syllable

+ ======================================================= +
+=ldb
+opcode 0011
+formats Load
+field0 D=0
+resources LOAD
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed load byte
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
IF (IsCRegSpace(ea))
  THROW CREG_ACCESS_VIOALTION;
ELSE
  ReadCheckMemory_8_(ea);
+stage_5_0
ReadMemory_8_(ea);
+stage_5_1
result1 = SignExtend_8_(ReadMemResponse());

+ ======================================================= +
+=ldb.d
+opcode 0011
+formats Load
+field0 D=1
+resources LOAD
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed load byte dismissable
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsCRegSpace(ea))
  DisReadCheckCReg(ea);
ELSE
  DisReadCheckMemory_8_(ea);
+stage_5_0
IF (NOT (IsCRegSpace(ea)))
  DisReadMemory_8_(ea);
+stage_5_1
IF (IsCRegSpace(ea))
  result1 = 0;
ELSE
  result1 = SignExtend_8_(ReadMemResponse());

+ ======================================================= +
+=ldbu
+opcode 0100
+formats Load
+field0 D=0
+resources LOAD
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Unsigned load byte
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsCRegSpace(ea))
  THROW CREG_ACCESS_VIOALTION;
ELSE
  ReadCheckMemory_8_(ea);
+stage_5_0
ReadMemory_8_(ea);
+stage_5_1
result1 = ZeroExtend_8_(ReadMemResponse());

+ ======================================================= +
+=ldbu.d
+opcode 0100
+formats Load
+field0 D=1
+resources LOAD
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Unsigned load byte dismissable
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsCRegSpace(ea))
  DisReadCheckCReg(ea);
ELSE
  DisReadCheckMemory_8_(ea);
+stage_5_0
IF (NOT (IsCRegSpace(ea)))
  DisReadMemory_8_(ea);
+stage_5_1
IF (IsCRegSpace(ea))
  result1 = 0;
ELSE
  result1 = ZeroExtend_8_(ReadMemResponse());

+ ======================================================= +
+=ldh
+opcode 0001
+formats Load
+field0 D=0
+resources LOAD
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed load half-word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsCRegSpace(ea))
  THROW CREG_ACCESS_VIOALTION;
ELSE
  ReadCheckMemory_16_(ea);
+stage_5_0
ReadMemory_16_(ea);
+stage_5_1
result1 = SignExtend_16_(ReadMemResponse());

+ ======================================================= +
+=ldh.d
+opcode 0001
+formats Load
+field0 D=1
+resources LOAD
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed load half-word dismissable
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsCRegSpace(ea))
  DisReadCheckCReg(ea);
ELSE
  DisReadCheckMemory_16_(ea);
+stage_5_0
IF (NOT (IsCRegSpace(ea)))
  DisReadMemory_16_(ea);
+stage_5_1
IF (IsCRegSpace(ea))
  result1 = 0;
ELSE
  result1 = SignExtend_16_(ReadMemResponse());

+ ======================================================= +
+=ldhu
+opcode 0010
+formats Load
+field0 D=0
+resources LOAD
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Unsigned load half-word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsCRegSpace(ea))
  THROW CREG_ACCESS_VIOALTION;
ELSE
  ReadCheckMemory_16_(ea);
+stage_5_0
ReadMemory_16_(ea);
+stage_5_1
result1 = ZeroExtend_16_(ReadMemResponse());

+ ======================================================= +
+=ldhu.d
+opcode 0010
+formats Load
+field0 D=1
+resources LOAD
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Unsigned load half-word dismissable
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsCRegSpace(ea))
  DisReadCheckCReg(ea);
ELSE
  DisReadCheckMemory_16_(ea);
+stage_5_0
IF (NOT (IsCRegSpace(ea)))
  DisReadMemory_16_(ea);
+stage_5_1
IF (IsCRegSpace(ea))
  result1 = 0;
ELSE
  result1 = ZeroExtend_16_(ReadMemResponse());

+ ======================================================= +
+=ldw
+opcode 0000
+formats Load
+field0 D=0
+resources LOAD
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Load word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsCRegSpace(ea))
  ReadCheckCReg(ea);
ELSE
  ReadCheckMemory_32_(ea);
+stage_5_0
IF (IsCRegSpace(ea))
  ReadCReg(ea);
ELSE
  ReadMemory_32_(ea);
+stage_5_1
  result1 = SignExtend_32_(ReadMemResponse());

+ ======================================================= +
+=ldw.d
+opcode 0000
+formats Load
+field0 D=1
+resources LOAD
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Load word dismissable
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsCRegSpace(ea))
  DisReadCheckCReg(ea);
ELSE
  DisReadCheckMemory_32_(ea);
+stage_5_0
IF (NOT (IsCRegSpace(ea)))
  DisReadMemory_32_(ea);
+stage_5_1
IF (IsCRegSpace(ea))
  result1 = 0;
ELSE
  result1 = SignExtend_32_(ReadMemResponse());

+ ======================================================= +
+=max
+opcode 10000
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed maximum
+stage_3_0
IF (operand1 > operand2) 
    result1 = operand1; 
ELSE 
    result1 = operand2;

+ ======================================================= +
+=maxu
+opcode 10001
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned maximum
+stage_3_0
IF (operand1 > operand2) 
    result1 = operand1; 
ELSE 
    result1 = operand2;

+ ======================================================= +
+=min
+opcode 10010
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed minimum
+stage_3_0
IF (operand1 < operand2) 
    result1 = operand1; 
ELSE 
    result1 = operand2;

+ ======================================================= +
+=minu
+opcode 10011
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned minimum
+stage_3_0
IF (operand1 < operand2) 
    result1 = operand1; 
ELSE 
    result1 = operand2;

+ ======================================================= +
+=mulh
+opcode 10111
+formats Int3R Int3I
+resources MUL
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Word by upper-half-word signed multiply
+stage_5_0
result1 = operand1 * (operand2 >> 16);

+ ======================================================= +
+=mulhh
+opcode 11101
+formats Int3R Int3I
+resources MUL
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Upper-half-word by upper-half-word signed multiply
+stage_5_0
result1 = (operand1 >> 16) * (operand2 >> 16);

+ ======================================================= +
+=mulhhu
+opcode 11110
+formats Int3R Int3I
+resources MUL
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Upper-half-word by upper-half-word unsigned multiply
+stage_5_0
result1 = ZeroExtend_16_(operand1 >> 16) * ZeroExtend_16_(operand2 >> 16);

+ ======================================================= +
+=mulhs
+opcode 11111
+formats Int3R Int3I
+resources MUL
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Word by upper-half-word unsigned multiply, left shifted 16
+stage_5_0
result1 = (operand1 * ZeroExtend_16_(operand2 >> 16)) << 16;

+ ======================================================= +
+=mulhu
+opcode 11000
+formats Int3R Int3I
+resources MUL
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=signed
+summary Word by upper-half-word unsigned multiply
+stage_5_0
result1 = operand1 * ZeroExtend_16_(operand2 >> 16);

+ ======================================================= +
+=mull
+opcode 10101
+formats Int3R Int3I
+resources MUL
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed, size=16
+summary Word by half-word signed multiply
+stage_5_0
result1 = operand1 * operand2;

+ ======================================================= +
+=mullh
+opcode 11011
+formats Int3R Int3I
+resources MUL
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed, size=16
+op3 name=operand2, stage=2, type=signed
+summary Half-word by upper-half-word signed multiply
+stage_5_0
result1 = operand1 * (operand2 >> 16);

+ ======================================================= +
+=mullhu
+opcode 11100
+formats Int3R Int3I
+resources MUL
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned, size=16
+op3 name=operand2, stage=2, type=signed
+summary Half-word by upper-half-word unsigned multiply
+stage_5_0
result1 = operand1 * ZeroExtend_16_(operand2 >> 16);

+ ======================================================= +
+=mulll
+opcode 11001
+formats Int3R Int3I
+resources MUL
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed, size=16
+op3 name=operand2, stage=2, type=signed, size=16
+summary Half-word by half-word signed multiply
+stage_5_0
result1 = operand1 * operand2;

+ ======================================================= +
+=mulllu
+opcode 11010
+formats Int3R Int3I
+resources MUL
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned, size=16
+op3 name=operand2, stage=2, type=unsigned, size=16
+summary Half-word by half-word unsigned multiply
+stage_5_0
result1 = operand1 * operand2;

+ ======================================================= +
+=mullu
+opcode 10110
+formats Int3R Int3I
+resources MUL
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned, size=16
+summary Word by half-word unsigned multiply
+stage_5_0
result1 = operand1 * operand2;

+ ======================================================= +
+=nandl
+opcode 1011
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Logical nand
+stage_3_0
result1 = NOT ((operand1 != 0) AND (operand2 != 0));

+ ======================================================= +
+=norl
+opcode 1101
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Logical nor
+stage_3_0
result1 = NOT ((operand1 != 0) OR (operand2 != 0));

+ ======================================================= +
+=or
+opcode 01011
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Bitwise or
+stage_3_0
result1 = operand1 | operand2;

+ ======================================================= +
+=orc
+opcode 01100
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Complement and bitwise or
+stage_3_0
result1 = (~operand1) | operand2;

+ ======================================================= +
+=orl
+opcode 1100
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Logical or
+stage_3_0
result1 = (operand1 != 0) OR (operand2 != 0);

+ ======================================================= +
+=pft
+opcode 01101
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+summary Prefetch
+syntax pft %1[%2]
+temp1 name=dummy
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
+stage_5_0
PrefetchMemory(ea);

+ ======================================================= +
+=prgadd
+opcode 01110
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+summary Purge the address given from the data cache
+syntax prgadd %1[%2]
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
+stage_5_0
PurgeAddress(ea);

+ ======================================================= +
+=prgset
+opcode 01111
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+summary Purge a set of four cache lines from the data cache
+syntax prgset %1[%2]
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
+stage_5_0
PurgeSet(ea);

+ ======================================================= +
+=prgins
+opcode 1111100
+formats SysOp
+resources CALL
+summary Purge the instruction cache
+stage_5_0
PurgeIns();

+ ======================================================= +
+=rfi
+opcode 010
+formats Call
+field0 LNK=0
+resources CALL
+state1 name=SAVED_PC, kind=src, stage=-2
+state2 name=SAVED_PC, kind=dst, stage=5
+state3 name=SAVED_PSW, kind=src, stage=-2
+state4 name=SAVED_PSW, kind=dst, stage=5
+state5 name=SAVED_SAVED_PC, kind=src, stage=2
+state6 name=SAVED_SAVED_PSW, kind=src, stage=2
+state7 name=PSW, kind=src, stage=1
+state8 name=PSW, kind=dst, stage=5
+state9 name=PC, kind=dst, stage=1
+summary Return from interrupt
+syntax rfi
+stage_1_0
IF (PSW[USER_MODE]) 
	THROW ILL_INST;
PC = Register(ZeroExtend_32_(SAVED_PC));
+stage_5_0
PSW = SAVED_PSW;
SAVED_PC = SAVED_SAVED_PC;
SAVED_PSW = SAVED_SAVED_PSW;

+ ======================================================= +
+=sbrk
+opcode 1111101
+formats SysOp
+resources ALU
+summary Software breakpoint
+stage_3_0
THROW SBREAK;

+ ======================================================= +
+=sh1add
+opcode 00101
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Shift left one and accumulate
+stage_3_0
result1 = (operand1 << 1) + operand2;

+ ======================================================= +
+=sh2add
+opcode 00110
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Shift left two and accumulate
+stage_3_0
result1 = (operand1 << 2) + operand2;

+ ======================================================= +
+=sh3add
+opcode 00111
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Shift left three and accumulate
+stage_3_0
result1 = (operand1 << 3) + operand2;

+ ======================================================= +
+=sh4add
+opcode 01000
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Shift left four and accumulate
+stage_3_0
result1 = (operand1 << 4) + operand2;

+ ======================================================= +
+=shl
+opcode 00010
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Shift left
+temp1 name=distance, type=unsigned
+stage_3_0
distance = ZeroExtend_8_(operand2); 
result1 = operand1 << distance;

+ ======================================================= +
+=shr
+opcode 00011
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Arithmetic shift right
+temp1 name=distance, type=unsigned
+stage_3_0
distance = ZeroExtend_8_(operand2); 
result1 = operand1 >> distance;

+ ======================================================= +
+=shru
+opcode 00100
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=signed
+summary Logical shift right
+temp1 name=distance, type=unsigned
+stage_3_0
distance = ZeroExtend_8_(operand2); 
result1 = operand1 >> distance;

+ ======================================================= +
+=slct
+opcode 000
+formats SelectR SelectI
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=signed
+op4 name=operand3, stage=2, type=signed
+summary Conditional select
+stage_3_0
IF (operand1 != 0) 
	result1 = operand2; 
ELSE 
	result1 = operand3;

+ ======================================================= +
+=slctf
+opcode 001
+formats SelectR SelectI
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=signed
+op4 name=operand3, stage=2, type=signed
+summary Conditional select
+stage_3_0
IF (operand1 == 0) 
	result1 = operand2; 
ELSE 
	result1 = operand3;

+ ======================================================= +
+=stb
+opcode 01100
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 name=operand3, stage=2, type=signed
+summary Store byte
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
IF (IsCRegSpace(ea))
  THROW CREG_ACCESS_VIOALTION;
ELSE
  WriteCheckMemory_8_(ea);
+stage_5_0
WriteMemory_8_(ea, operand3);

+ ======================================================= +
+=sth
+opcode 01011
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 name=operand3, stage=2, type=signed
+summary Store half-word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsCRegSpace(ea))
  THROW CREG_ACCESS_VIOALTION;
ELSE
  WriteCheckMemory_16_(ea);
+stage_5_0
WriteMemory_16_(ea, operand3);

+ ======================================================= +
+=stw
+opcode 01010
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 name=operand3, stage=2, type=signed
+summary Store word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsCRegSpace(ea))
  WriteCheckCReg(ea);
ELSE
  WriteCheckMemory_32_(ea);
+stage_5_0
IF (IsCRegSpace(ea))
  WriteCReg(ea, operand3);
ELSE
  WriteMemory_32_(ea, operand3);

+ ======================================================= +
+=sub
+opcode 00001
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Subtract
+syntax sub %1 = %3, %2
+stage_3_0
result1 = operand2 - operand1;

+ ======================================================= +
+=sync
+opcode 10000
+formats Store
+resources LOAD
+summary Ensure synchronisation
+syntax sync
+stage_5_0
Sync();

+ ======================================================= +
+=syscall
+opcode 1111110
+formats SysOp
+resources ALU
+summary System call
+stage_3_0
THROW ILL_INST;

+ ======================================================= +
+=sxtb
+opcode 01110
+formats Int3R
+resources ALU
+op1 name=result1, stage=3
+op3 name=operand1, stage=2, type=signed, size=8
+summary Sign-extend byte
+syntax sxtb %1 = %3
+stage_3_0
result1 = operand1;

+ ======================================================= +
+=sxth
+opcode 01111
+formats Int3R
+resources ALU
+op1 name=result1, stage=3
+op3 name=operand1, stage=2, type=signed, size=16
+summary Sign-extend half-word
+syntax sxth %1 = %3
+stage_3_0
result1 = operand1;

+ ======================================================= +
+=xor
+opcode 01101
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Bitwise exclusive-or
+stage_3_0
result1 = operand1 ^ operand2;

