+ **************************************************
+ ST235 Architecture Database
+ **************************************************

+ ======================================================= +
+=add
+field0 INT3_OPCODE=00000
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Add
+stage_3_0
result1 = operand1 + operand2;

+ ======================================================= +
+=addcg
+field0 CGEN_OPCODE=0010
+formats cgen
+resources ALU
+op1 name=result1, stage=3
+op2 name=result2, stage=3
+op3 name=operand1, stage=2, type=unsigned
+op4 name=operand2, stage=2, type=unsigned
+op5 name=operand3, stage=2, type=unsigned
+summary Add with carry and generate carry
+stage_3_0
result1 = (operand1 + operand2) + operand3; 
result2 = Bit(result1, 32);

+ ======================================================= +
+=and
+field0 INT3_OPCODE=01001
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Bitwise and
+stage_3_0
result1 = operand1 & operand2;

+ ======================================================= +
+=andc
+field0 INT3_OPCODE=01010
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Complement and bitwise and
+stage_3_0
result1 = (~operand1) & operand2;

+ ======================================================= +
+=andl
+field0 CMP3_OPCODE=1010
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Logical and
+stage_3_0
result1 = (operand1 != 0) AND (operand2 != 0);

+ ======================================================= +

+=asm_0
+field0 ASM_OPCODE=0110000
+formats Asm
+resources ASM
+summary Asm0
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_1
+field0 ASM_OPCODE=0110001
+formats Asm
+resources ASM
+summary Asm1
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_2
+field0 ASM_OPCODE=0110010
+formats Asm
+resources ASM
+summary Asm2
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_3
+field0 ASM_OPCODE=0110011
+formats Asm
+resources ASM
+summary Asm3
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_4
+field0 ASM_OPCODE=0110100
+formats Asm
+resources ASM
+summary Asm4
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_5
+field0 ASM_OPCODE=0110101
+formats Asm
+resources ASM
+summary Asm5
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_6
+field0 ASM_OPCODE=0110110
+formats Asm
+resources ASM
+summary Asm6
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_7
+field0 ASM_OPCODE=0110111
+formats Asm
+resources ASM
+summary Asm7
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_8
+field0 ASM_OPCODE=0111000
+formats Asm
+resources ASM
+summary Asm8
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_9
+field0 ASM_OPCODE=0111001
+formats Asm
+resources ASM
+summary Asm9
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_10
+field0 ASM_OPCODE=0111010
+formats Asm
+resources ASM
+summary Asm10
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_11
+field0 ASM_OPCODE=0111011
+formats Asm
+resources ASM
+summary Asm11
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_12
+field0 ASM_OPCODE=0111100
+formats Asm
+resources ASM
+summary Asm12
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_13
+field0 ASM_OPCODE=0111101
+formats Asm
+resources ASM
+summary Asm13
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_14
+field0 ASM_OPCODE=0111110
+formats Asm
+resources ASM
+summary Asm14
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_15
+field0 ASM_OPCODE=0111111
+formats Asm
+resources ASM
+summary Asm15
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_16
+field0 ASM_OPCODE=1011000
+formats Asm
+resources ASM
+summary Asm16
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_17
+field0 ASM_OPCODE=1011001
+formats Asm
+resources ASM
+summary Asm17
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_18
+field0 ASM_OPCODE=1011010
+formats Asm
+resources ASM
+summary Asm18
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_19
+field0 ASM_OPCODE=1011011
+formats Asm
+resources ASM
+summary Asm19
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_20
+field0 ASM_OPCODE=1011100
+formats Asm
+resources ASM
+summary Asm20
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_21
+field0 ASM_OPCODE=1011101
+formats Asm
+resources ASM
+summary Asm21
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_22
+field0 ASM_OPCODE=1011110
+formats Asm
+resources ASM
+summary Asm22
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_23
+field0 ASM_OPCODE=1011111
+formats Asm
+resources ASM
+summary Asm23
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_24
+field0 ASM_OPCODE=1101000
+formats Asm
+resources ASM
+summary Asm24
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_25
+field0 ASM_OPCODE=1101001
+formats Asm
+resources ASM
+summary Asm25
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_26
+field0 ASM_OPCODE=1101010
+formats Asm
+resources ASM
+summary Asm26
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_27
+field0 ASM_OPCODE=1101011
+formats Asm
+resources ASM
+summary Asm27
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_28
+field0 ASM_OPCODE=1101100
+formats Asm
+resources ASM
+summary Asm28
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_29
+field0 ASM_OPCODE=1101101
+formats Asm
+resources ASM
+summary Asm29
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_30
+field0 ASM_OPCODE=1101110
+formats Asm
+resources ASM
+summary Asm30
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +

+=asm_31
+field0 ASM_OPCODE=1101111
+formats Asm
+resources ASM
+summary Asm31
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +
+=br
+field0 BRANCH_OPCODE=0
+formats Branch
+resources BRANCH
+op1 name=operand1, stage=0, type=unsigned
+op2 name=operand2, stage=1, type=signed
+summary Branch
+state1 name=BUNDLE_PC, kind=src, stage=1
+state2 name=PC, kind=dst, stage=1
+stage_1_0
IF (operand1 != 0) 
	PC = Register(ZeroExtend_32_(BUNDLE_PC) + (operand2 << 2));

+ ======================================================= +
+=break
+field0 SYSOP_OPCODE=1111111
+formats SysOp
+resources ALU
+summary Break
+stage_3_0
THROW(ILL_INST);

+ ======================================================= +
+=brf
+field0 BRANCH_OPCODE=1
+formats Branch
+resources BRANCH
+op1 name=operand1, stage=0, type=unsigned
+op2 name=operand2, stage=1, type=signed
+summary Branch false
+state1 name=BUNDLE_PC, kind=src, stage=1
+state2 name=PC, kind=dst, stage=1
+stage_1_0
IF (operand1 == 0) 
	PC = Register(ZeroExtend_32_(BUNDLE_PC) + (operand2 << 2));


+ ======================================================= +
+=bswap
+field0 MONADIC_OPCODE=000000010
+formats Monadic
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+temp1 name=byte0
+temp2 name=byte1
+temp3 name=byte2
+temp4 name=byte3
+summary Byte Swap
+stage_3_0
byte0 = BitsOf(operand1,0,8);
byte1 = BitsOf(operand1,8,8);
byte2 = BitsOf(operand1,16,8);
byte3 = BitsOf(operand1,24,8);
result1 = ((byte0 << 24) | (byte1 << 16)) | ((byte2 << 8) | byte3);

+ ======================================================= +
+=call
+field0 CALL_OPCODE=000
+field1 LNK=0
+formats Call
+resources CALL
+op1 name=operand1, stage=1, type=signed
+state1 name=LR, kind=dst, stage=3
+state2 name=BUNDLE_PC, kind=src, stage=1
+state3 name=PC, kind=src, stage=1
+state4 name=PC, kind=dst, stage=1
+temp1 name=NEXT_PC
+summary Jump and link
+stage_1_0
NEXT_PC = PC;
PC = Register(ZeroExtend_32_(BUNDLE_PC) + (operand1 << 2));
+stage_3_0
LR = NEXT_PC;

+ ======================================================= +
+=icall
+field0 CALL_OPCODE=000
+field1 LNK=1
+formats Call
+resources CALL
+op1 fixed=00000000000000000000000
+state1 name=LR, kind=dst, stage=3
+state2 name=LR, kind=src, stage=1
+state3 name=PC, kind=dst, stage=1
+state4 name=PC, kind=src, stage=1
+temp1 name=NEXT_PC
+summary Jump (using Link Register) and link
+syntax call LR = LR
+stage_1_0
NEXT_PC = PC;
PC = Register(ZeroExtend_32_(LR));
+stage_3_0
LR = NEXT_PC;

+ ======================================================= +
+=clz
+field0 MONADIC_OPCODE=000000100
+formats Monadic
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+summary Count leading zeros
+stage_3_0
result1 = CountLeadingZeros(operand1);

+ ======================================================= +
+=cmpeq
+field0 CMP3_OPCODE=0000
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Test for equality
+stage_3_0
result1 = operand1 == operand2;

+ ======================================================= +
+=cmpge
+field0 CMP3_OPCODE=0010
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed compare equal or greater than
+stage_3_0
result1 = operand1 >= operand2;

+ ======================================================= +
+=cmpgeu
+field0 CMP3_OPCODE=0011
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned compare equal or greater than
+stage_3_0
result1 = operand1 >= operand2;

+ ======================================================= +
+=cmpgt
+field0 CMP3_OPCODE=0100
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed compare greater than
+stage_3_0
result1 = operand1 > operand2;

+ ======================================================= +
+=cmpgtu
+field0 CMP3_OPCODE=0101
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned compare greater than
+stage_3_0
result1 = operand1 > operand2;

+ ======================================================= +
+=cmple
+field0 CMP3_OPCODE=0110
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed compare equal or less than
+stage_3_0
result1 = operand1 <= operand2;

+ ======================================================= +
+=cmpleu
+field0 CMP3_OPCODE=0111
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned compare equal or less than
+stage_3_0
result1 = operand1 <= operand2;

+ ======================================================= +
+=cmplt
+field0 CMP3_OPCODE=1000
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed compare less than
+stage_3_0
result1 = operand1 < operand2;

+ ======================================================= +
+=cmpltu
+field0 CMP3_OPCODE=1001
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned compare less than
+stage_3_0
result1 = operand1 < operand2;

+ ======================================================= +
+=cmpne
+field0 CMP3_OPCODE=0001
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Test for inequality
+stage_3_0
result1 = operand1 != operand2;

+ ======================================================= +
+=div.i
+field0 FLOAT_OPCODE=11000
+formats Maths3R_Dss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE integer divide
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = IDivIeee(operand1, operand2);

+ ======================================================= +
+=div.u
+field0 FLOAT_OPCODE=11010
+formats Maths3R_Dss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE unsigned integer divide
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = UIDivIeee(operand1, operand2);

+ ======================================================= +
+=divs
+field0 CGEN_OPCODE=0100
+formats cgen
+resources ALU
+op1 name=result1, stage=3
+op2 name=result2, stage=3
+op3 name=operand1, stage=2, type=signed
+op4 name=operand2, stage=2, type=signed
+op5 name=operand3, stage=2, type=unsigned
+summary Non-restoring divide stage
+temp1 name=temp
+stage_3_0
temp = ZeroExtend_32_(operand1 * 2) | (operand3 & 1); 
IF (operand1 < 0) 
{ 
    result1 = temp + operand2; 
    result2 = 1; 
} 
ELSE 
{ 
    result1 = temp - operand2; 
    result2 = 0; 
}

+ ======================================================= +
+=fadd.d
+field0 FLOAT_OPCODE=01000
+formats Float3R_Ddd
+resources FPU
+lr readonly
+op1 name=result1, stage=5, size=64
+op2 name=operand1, stage=2, type=unsigned, size=64
+op3 name=operand2, stage=2, type=unsigned, size=64
+state1 name=VERSION, kind=src, stage=3
+summary IEEE double presision floating point add
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FAddDIeee(operand1, operand2);

+ ======================================================= +
+=fadd.s
+field0 FLOAT_OPCODE=00000
+formats Float3R_Dss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE single presision floating point add
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FAddSIeee(operand1, operand2);

+ ======================================================= +
+=faddn.s
+field0 FLOAT_OPCODE=10000
+formats Maths3R_Dss
+resources EVEN
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary Non-IEEE single presision floating point add
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FAddSNonIeee(operand1, operand2);

+ ======================================================= +
+=fconv.di
+field0 FLOAT_OPCODE=11011
+formats Float3R_Mds
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned, size=64
+state1 name=VERSION, kind=src, stage=3
+summary IEEE double precision floating point to integer
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = DFloatToIntIeee(operand1);

+ ======================================================= +
+=fconv.ds
+field0 FLOAT_OPCODE=11000
+formats Float3R_Mds
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned, size=64
+state1 name=VERSION, kind=src, stage=3
+summary IEEE double precision to single precision floating point
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = DFloatToSFloatIeee(operand1);

+ ======================================================= +
+=fconv.du
+field0 FLOAT_OPCODE=11111
+formats Float3R_Mds
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned, size=64
+state1 name=VERSION, kind=src, stage=3
+summary IEEE double precision floating point to unsigned integer
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = DFloatToUIntIeee(operand1);

+ ======================================================= +
+=fconv.id
+field0 FLOAT_OPCODE=10010
+formats Float3R_Msd
+resources FPU
+lr readonly
+op1 name=result1, stage=5, size=64
+op2 name=operand1, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE integer to double precision floating point
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = IntToDFloatIeee(operand1);

+ ======================================================= +
+=fconv.is
+field0 FLOAT_OPCODE=10000
+formats Float3R_Mss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE integer to single presision floating point
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = IntToSFloatIeee(operand1);

+ ======================================================= +
+=fconv.sd
+field0 FLOAT_OPCODE=10111
+formats Float3R_Msd
+resources FPU
+lr readonly
+op1 name=result1, stage=5, size=64
+op2 name=operand1, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE single precision to double precision floating point
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = SFloatToDFloatIeee(operand1);

+ ======================================================= +
+=fconv.si
+field0 FLOAT_OPCODE=10001
+formats Float3R_Mss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE single precision floating point to integer
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = SFloatToIntIeee(operand1);

+ ======================================================= +
+=fconv.su
+field0 FLOAT_OPCODE=10101
+formats Float3R_Mss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE single precision floating point to unsigned integer
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = SFloatToUIntIeee(operand1);

+ ======================================================= +
+=fconv.ud
+field0 FLOAT_OPCODE=10110
+formats Float3R_Msd
+resources FPU
+lr readonly
+op1 name=result1, stage=5, size=64
+op2 name=operand1, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE unsigned integer to double precision floating point
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = UIntToDFloatIeee(operand1);

+ ====================================================== +
+=fconv.us
+field0 FLOAT_OPCODE=10100
+formats Float3R_Mss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE unsigned integer to single precision floating point
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = UIntToSFloatIeee(operand1);

+ ====================================================== +
+=fconvn.is
+field0 FLOAT_OPCODE=10011
+formats Maths3R_Mss
+resources EVEN
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary Non-IEEE signed integer to single precision floating point
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = IntToSFloatNonIeee(operand1);

+ ====================================================== +
+=fconvn.si
+field0 FLOAT_OPCODE=10100
+formats Maths3R_Mss
+resources EVEN
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary Non-IEEE single precision floating point to signed integer
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = SFloatToIntNonIeee(operand1);

+ ======================================================= +
+=fcmpeq.d
+field0 FLOAT_OPCODE=01010
+formats Maths3R_Dds
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned, size=64
+op3 name=operand2, stage=2, type=unsigned, size=64
+state1 name=VERSION, kind=src, stage=3
+summary Double precision floating point compare equal to
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FCmpEqD(operand1, operand2);

+ ======================================================= +
+=fcmpeq.s
+field0 FLOAT_OPCODE=00010
+formats Maths3R_Dss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary Single precision floating point compare equal to
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FCmpEqS(operand1, operand2);

+ ======================================================= +
+=fcmpge.d
+field0 FLOAT_OPCODE=01001
+formats Maths3R_Dds
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned, size=64
+op3 name=operand2, stage=2, type=unsigned, size=64
+state1 name=VERSION, kind=src, stage=3
+summary Double precision floating point compare greater than or equal to
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FCmpGeD(operand1, operand2);

+ ======================================================= +
+=fcmpge.s
+field0 FLOAT_OPCODE=00001
+formats Maths3R_Dss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary Single precision floating point compare greater than or equal to
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FCmpGeS(operand1, operand2);

+ ======================================================= +
+=fcmpgt.d
+field0 FLOAT_OPCODE=01000
+formats Maths3R_Dds
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned, size=64
+op3 name=operand2, stage=2, type=unsigned, size=64
+state1 name=VERSION, kind=src, stage=3
+summary Double precision floating point compare greater than
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FCmpGtD(operand1, operand2);

+ ======================================================= +
+=fcmpgt.s
+field0 FLOAT_OPCODE=00000
+formats Maths3R_Dss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary Single precision floating point compare greater than
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FCmpGtS(operand1, operand2);

+ ======================================================= +
+=fdiv.d
+field0 FLOAT_OPCODE=01100
+formats Float3R_Ddd
+resources FPU
+lr readonly
+op1 name=result1, stage=5, size=64
+op2 name=operand1, stage=2, type=unsigned, size=64
+op3 name=operand2, stage=2, type=unsigned, size=64
+state1 name=VERSION, kind=src, stage=3
+summary IEEE double presision floating point divide
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FDivDIeee(operand1, operand2);

+ ======================================================= +
+=fdiv.s
+field0 FLOAT_OPCODE=00100
+formats Float3R_Dss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE single presision floating point divide
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FDivSIeee(operand1, operand2);

+ ======================================================= +
+=fmul.d
+field0 FLOAT_OPCODE=01010
+formats Float3R_Ddd
+resources FPU
+lr readonly
+op1 name=result1, stage=5, size=64
+op2 name=operand1, stage=2, type=unsigned, size=64
+op3 name=operand2, stage=2, type=unsigned, size=64
+state1 name=VERSION, kind=src, stage=3
+summary IEEE double presision floating point multiply
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FMulDIeee(operand1, operand2);

+ ======================================================= +
+=fmul.s
+field0 FLOAT_OPCODE=00010
+formats Float3R_Dss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE single presision floating point multiply
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FMulSIeee(operand1, operand2);

+ ======================================================= +
+=fmuln.s
+field0 FLOAT_OPCODE=10010
+formats Maths3R_Dss
+resources ODD
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary Non-IEEE single presision floating point multiply
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FMulSNonIeee(operand1, operand2);

+ ======================================================= +
+=fsqrt.d
+field0 FLOAT_OPCODE=01101
+formats Float3R_Mdd
+resources FPU
+lr readonly
+op1 name=result1, stage=5, size=64
+op2 name=operand1, stage=2, type=unsigned, size=64
+state1 name=VERSION, kind=src, stage=3
+summary IEEE double presision floating point square root
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FSqrtDIeee(operand1);

+ ======================================================= +
+=fsqrt.s
+field0 FLOAT_OPCODE=00101
+formats Float3R_Mss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE single presision floating point square root
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FSqrtSIeee(operand1);

+ ======================================================= +
+=fsub.d
+field0 FLOAT_OPCODE=01001
+formats Float3R_Ddd
+resources FPU
+lr readonly
+op1 name=result1, stage=5, size=64
+op2 name=operand1, stage=2, type=unsigned, size=64
+op3 name=operand2, stage=2, type=unsigned, size=64
+state1 name=VERSION, kind=src, stage=3
+summary IEEE double precision floating point subtract
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FSubDIeee(operand1, operand2);

+ ======================================================= +
+=fsub.s
+field0 FLOAT_OPCODE=00001
+formats Float3R_Dss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE single precision floating point subtract
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FSubSIeee(operand1, operand2);

+ ======================================================= +
+=fsubn.s
+field0 FLOAT_OPCODE=10001
+formats Maths3R_Dss
+resources EVEN
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary Non-IEEE single precision floating point subtract
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = FSubSNonIeee(operand1, operand2);

+ ======================================================= +
+=goto
+field0 CALL_OPCODE=001
+field1 LNK=0
+formats Call
+resources CALL
+op1 name=operand1, stage=1, type=signed
+state1 name=BUNDLE_PC, kind=src, stage=1
+state2 name=PC, kind=dst, stage=1
+syntax goto %1
+summary Jump
+stage_1_0
PC = Register(ZeroExtend_32_(BUNDLE_PC) + (operand1 << 2));

+ ======================================================= +
+=igoto
+field0 CALL_OPCODE=001
+field1 LNK=1
+formats Call
+resources CALL
+op1 fixed=00000000000000000000000
+state1 name=LR, kind=src, stage=1
+state2 name=PC, kind=dst, stage=1
+summary Jump (using Link Register)
+syntax goto LR
+stage_1_0
PC = Register(ZeroExtend_32_(LR));

+ ======================================================= +
+=imml
+field0 IMMX_OPCODE=01010
+formats Imm
+resources IMM
+op1 name=extension, stage=2, type=unsigned
+summary Long immediate for previous syllable

+ ======================================================= +
+=immr
+field0 IMMX_OPCODE=01011
+formats Imm
+resources IMM
+op1 name=extension, stage=2, type=unsigned
+summary Long immediate for next syllable

+ ======================================================= +
+=ldb
+field0 LOAD_OPCODE=0100
+formats Load
+resources LOAD
+lr readonly
+op1 name=result1, stage=5_1
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed load byte
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
IF (IsDBreakLoadHit(ea))
  THROW(DBREAK);
IF (IsCRegSpace(ea))
  THROW(CREG_ACCESS_VIOLATION);
ELSE
  ReadCheckMemory_8_(ea);
+stage_5_0
ReadMemory_8_(ea);
+stage_5_1
result1 = SignExtend_8_(ReadMemResponse());

+ ======================================================= +
+=ldb.c
+field0 LOAD_OPCODE=0100
+formats LoadC
+resources LOAD
+lr readonly
+op1 name=result1, stage=5_1, conditional=cond
+op2 name=cond, stage=2, type=unsigned
+op3 name=operand1, stage=2, type=signed
+op4 name=operand2, stage=2, type=signed
+summary Conditional signed load byte
+temp1 name=ea
+stage_3_0
IF (cond)
{
  ea = ZeroExtend_32_(operand1 + operand2);
  IF (IsDBreakLoadHit(ea))
    THROW(DBREAK);
  IF (IsCRegSpace(ea))
    THROW(CREG_ACCESS_VIOLATION);
  ELSE
    ReadCheckMemory_8_(ea);
}
+stage_5_0
IF (cond)
  ReadMemory_8_(ea);
+stage_5_1
IF (cond)
  result1 = SignExtend_8_(ReadMemResponse());

+ ======================================================= +
+=ldbu
+field0 LOAD_OPCODE=0101
+formats Load
+resources LOAD
+lr readonly
+op1 name=result1, stage=5_1
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Unsigned load byte
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsDBreakLoadHit(ea))
  THROW(DBREAK);
IF (IsCRegSpace(ea))
  THROW(CREG_ACCESS_VIOLATION);
ELSE
  ReadCheckMemory_8_(ea);
+stage_5_0
ReadMemory_8_(ea);
+stage_5_1
result1 = ZeroExtend_8_(ReadMemResponse());

+ ======================================================= +
+=ldbu.c
+field0 LOAD_OPCODE=0101
+formats LoadC
+resources LOAD
+lr readonly
+op1 name=result1, stage=5_1, conditional=cond
+op2 name=cond, stage=2, type=unsigned
+op3 name=operand1, stage=2, type=signed
+op4 name=operand2, stage=2, type=signed
+summary Conditional unsigned load byte
+temp1 name=ea
+stage_3_0
IF (cond)
{
  ea = ZeroExtend_32_(operand1 + operand2); 
  IF (IsDBreakLoadHit(ea))
    THROW(DBREAK);
  IF (IsCRegSpace(ea))
    THROW(CREG_ACCESS_VIOLATION);
  ELSE
    ReadCheckMemory_8_(ea);
}
+stage_5_0
IF (cond)
  ReadMemory_8_(ea);
+stage_5_1
IF (cond)
  result1 = ZeroExtend_8_(ReadMemResponse());

+ ======================================================= +
+=ldd
+field0 LOAD_OPCODE=0000
+formats Load
+resources LOAD
+op1 name=result1, stage=5_1, size=64
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Load double word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
IF (IsDBreakLoadHit(ea))
  THROW(DBREAK);
IF (IsCRegSpace(ea))
  THROW(CREG_ACCESS_VIOLATION);
ELSE
  ReadCheckMemory_64_(ea);
+stage_5_0
ReadMemory_64_(ea);
+stage_5_1
result1 = SignExtend_64_(ReadMemResponse_64_());

+ ======================================================= +
+=ldd.c
+field0 LOAD_OPCODE=0000
+formats LoadC
+resources LOAD
+op1 name=result1, stage=5_1, size=64, conditional=cond
+op2 name=cond, stage=2, type=unsigned
+op3 name=operand1, stage=2, type=signed
+op4 name=operand2, stage=2, type=signed
+summary Conditional load double word
+temp1 name=ea
+stage_3_0
IF (cond)
{
  ea = ZeroExtend_32_(operand1 + operand2);
  IF (IsDBreakLoadHit(ea))
    THROW(DBREAK);
  IF (IsCRegSpace(ea))
    THROW(CREG_ACCESS_VIOLATION);
  ELSE
    ReadCheckMemory_64_(ea);
}
+stage_5_0
IF (cond)
  ReadMemory_64_(ea);
+stage_5_1
IF (cond)
  result1 = SignExtend_64_(ReadMemResponse_64_());

+ ======================================================= +
+=ldh
+field0 LOAD_OPCODE=0010
+formats Load
+resources LOAD
+lr readonly
+op1 name=result1, stage=5_1
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed load half-word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsDBreakLoadHit(ea))
  THROW(DBREAK);
IF (IsCRegSpace(ea))
  THROW(CREG_ACCESS_VIOLATION);
ELSE
  ReadCheckMemory_16_(ea);
+stage_5_0
ReadMemory_16_(ea);
+stage_5_1
result1 = SignExtend_16_(ReadMemResponse());

+ ======================================================= +
+=ldh.c
+field0 LOAD_OPCODE=0010
+formats LoadC
+resources LOAD
+lr readonly
+op1 name=result1, stage=5_1, conditional=cond
+op2 name=cond, stage=2, type=unsigned
+op3 name=operand1, stage=2, type=signed
+op4 name=operand2, stage=2, type=signed
+summary Conditional signed load half-word
+temp1 name=ea
+stage_3_0
IF (cond)
{
  ea = ZeroExtend_32_(operand1 + operand2); 
  IF (IsDBreakLoadHit(ea))
    THROW(DBREAK);
  IF (IsCRegSpace(ea))
    THROW(CREG_ACCESS_VIOLATION);
  ELSE
    ReadCheckMemory_16_(ea);
}
+stage_5_0
IF (cond)
  ReadMemory_16_(ea);
+stage_5_1
IF (cond)
  result1 = SignExtend_16_(ReadMemResponse());

+ ======================================================= +
+=ldhu
+field0 LOAD_OPCODE=0011
+formats Load
+resources LOAD
+lr readonly
+op1 name=result1, stage=5_1
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Unsigned load half-word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
IF (IsDBreakLoadHit(ea))
  THROW(DBREAK);
IF (IsCRegSpace(ea))
  THROW(CREG_ACCESS_VIOLATION);
ELSE
  ReadCheckMemory_16_(ea);
+stage_5_0
ReadMemory_16_(ea);
+stage_5_1
result1 = ZeroExtend_16_(ReadMemResponse());

+ ======================================================= +
+=ldhu.c
+field0 LOAD_OPCODE=0011
+formats LoadC
+resources LOAD
+lr readonly
+op1 name=result1, stage=5_1, conditional=cond
+op2 name=cond, stage=2, type=unsigned
+op3 name=operand1, stage=2, type=signed
+op4 name=operand2, stage=2, type=signed
+summary Conditional unsigned load half-word
+temp1 name=ea
+stage_3_0
IF (cond)
{
  ea = ZeroExtend_32_(operand1 + operand2);
  IF (IsDBreakLoadHit(ea))
    THROW(DBREAK);
  IF (IsCRegSpace(ea))
    THROW(CREG_ACCESS_VIOLATION);
  ELSE
    ReadCheckMemory_16_(ea);
}
+stage_5_0
IF (cond)
  ReadMemory_16_(ea);
+stage_5_1
IF (cond)
  result1 = ZeroExtend_16_(ReadMemResponse());

+ ======================================================= +
+=ldw
+field0 LOAD_OPCODE=0001
+formats Load
+resources LOAD
+op1 name=result1, stage=5_1
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Load word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
IF (IsDBreakLoadHit(ea))
  THROW(DBREAK);
IF (IsCRegSpace(ea))
  ReadCheckCReg(ea);
ELSE
  ReadCheckMemory_32_(ea);
+stage_5_0
IF (IsCRegSpace(ea))
  ReadCReg(ea);
ELSE
  ReadMemory_32_(ea);
+stage_5_1
result1 = SignExtend_32_(ReadMemResponse());

+ ======================================================= +
+=ldw.c
+field0 LOAD_OPCODE=0001
+formats LoadC
+resources LOAD
+op1 name=result1, stage=5_1, conditional=cond
+op2 name=cond, stage=2, type=unsigned
+op3 name=operand1, stage=2, type=signed
+op4 name=operand2, stage=2, type=signed
+summary Conditional load word
+temp1 name=ea
+stage_3_0
IF (cond)
{
  ea = ZeroExtend_32_(operand1 + operand2);
  IF (IsDBreakLoadHit(ea))
    THROW(DBREAK);
  IF (IsCRegSpace(ea))
    ReadCheckCReg(ea);
  ELSE
    ReadCheckMemory_32_(ea);
}
+stage_5_0
IF (cond)
{
  IF (IsCRegSpace(ea))
    ReadCReg(ea);
  ELSE
    ReadMemory_32_(ea);
}
+stage_5_1
IF (cond)
{
  result1 = SignExtend_32_(ReadMemResponse());
}

+ ======================================================= +
+=ldwl
+field0 LOADL_OPCODE=000000101
+formats LoadL
+resources LOAD
+op1 name=result1, stage=5_1
+op2 name=ea,      stage=2, type=unsigned
+summary Load word locked
+stage_3_0
IF (IsDBreakLoadHit(ea))
  THROW(DBREAK);
IF (IsCRegSpace(ea))
  THROW(CREG_ACCESS_VIOLATION);
ELSE
  ReadCheckMemory_32_(ea);
+stage_5_0
ReadLockMemory_32_(ea);
+stage_5_1
result1 = SignExtend_32_(ReadMemResponse());

+ ======================================================= +
+=max
+field0 INT3_OPCODE=10000
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed maximum
+stage_3_0
IF (operand1 > operand2) 
    result1 = operand1; 
ELSE 
    result1 = operand2;

+ ======================================================= +
+=maxu
+field0 INT3_OPCODE=10001
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned maximum
+stage_3_0
IF (operand1 > operand2) 
    result1 = operand1; 
ELSE 
    result1 = operand2;

+ ======================================================= +
+=min
+field0 INT3_OPCODE=10010
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Signed minimum
+stage_3_0
IF (operand1 < operand2) 
    result1 = operand1; 
ELSE 
    result1 = operand2;

+ ======================================================= +
+=minu
+field0 INT3_OPCODE=10011
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary Unsigned minimum
+stage_3_0
IF (operand1 < operand2) 
    result1 = operand1; 
ELSE 
    result1 = operand2;

+ ======================================================= +
+=mulh
+field0 INT3_OPCODE=10111
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Word by upper-half-word signed multiply
+stage_5_0
result1 = operand1 * (operand2 >> 16);

+ ======================================================= +
+=mulhh
+field0 INT3_OPCODE=11101
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Upper-half-word by upper-half-word signed multiply
+stage_5_0
result1 = (operand1 >> 16) * (operand2 >> 16);

+ ======================================================= +
+=mulhhs
+field0 INT3_OPCODE=10100
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Word by upper-half-word signed multiply, returns top 32 bits of 48 bit result
+stage_5_0
result1 = (operand1 * (operand2 >> 16)) >> 16;

+ ======================================================= +
+=mulhhu
+field0 INT3_OPCODE=11110
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Upper-half-word by upper-half-word unsigned multiply
+stage_5_0
result1 = ZeroExtend_16_(operand1 >> 16) * ZeroExtend_16_(operand2 >> 16);

+ ======================================================= +
+=mulhs
+field0 INT3_OPCODE=11111
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Word by upper-half-word unsigned multiply, left shifted 16
+stage_5_0
result1 = (operand1 * ZeroExtend_16_(operand2 >> 16)) << 16;

+ ======================================================= +
+=mulhu
+field0 INT3_OPCODE=11000
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=signed
+summary Word by upper-half-word unsigned multiply
+stage_5_0
result1 = operand1 * ZeroExtend_16_(operand2 >> 16);

+ ======================================================= +
+=mull
+field0 INT3_OPCODE=10101
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed, size=16
+summary Word by half-word signed multiply
+stage_5_0
result1 = operand1 * operand2;

+ ======================================================= +
+=mullh
+field0 INT3_OPCODE=11011
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed, size=16
+op3 name=operand2, stage=2, type=signed
+summary Half-word by upper-half-word signed multiply
+stage_5_0
result1 = operand1 * (operand2 >> 16);

+ ======================================================= +
+=mullhu
+field0 INT3_OPCODE=11100
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned, size=16
+op3 name=operand2, stage=2, type=signed
+summary Half-word by upper-half-word unsigned multiply
+stage_5_0
result1 = operand1 * ZeroExtend_16_(operand2 >> 16);

+ ======================================================= +
+=mullhus
+field0 INT3_OPCODE=01111
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=unsigned, size=16
+summary Word by lower-half-word signed multiply, returns top 16 bits of 48 bit result, sign extended
+stage_5_0
result1 = (operand1 * operand2) >> 32;

+ ======================================================= +
+=mulll
+field0 INT3_OPCODE=11001
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed, size=16
+op3 name=operand2, stage=2, type=signed, size=16
+summary Half-word by half-word signed multiply
+stage_5_0
result1 = operand1 * operand2;

+ ======================================================= +
+=mulllu
+field0 INT3_OPCODE=11010
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned, size=16
+op3 name=operand2, stage=2, type=unsigned, size=16
+summary Half-word by half-word unsigned multiply
+stage_5_0
result1 = operand1 * operand2;

+ ======================================================= +
+=mullu
+field0 INT3_OPCODE=10110
+formats Int3R Int3I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned, size=16
+summary Word by half-word unsigned multiply
+stage_5_0
result1 = operand1 * operand2;

+ ======================================================= +
+=mul32
+field0 MUL64_OPCODE=01110
+formats Mul64R Mul64I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary 32 by 32 multiply
+stage_5_0
result1 = operand1 * operand2;

+ ======================================================= +
+=mul64h
+field0 MUL64_OPCODE=01111
+formats Mul64R Mul64I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary 32 by 32 signed multiply, return the top 32 bits of the 64 bit result.
+stage_5_0
result1 = (operand1 * operand2) >> 32;

+ ======================================================= +
+=mul64hu
+field0 MUL64_OPCODE=11110
+formats Mul64R Mul64I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+summary 32 by 32 unsigned multiply, return the top 32 bits of the 64 bit result.
+stage_5_0
result1 = (operand1 * operand2) >> 32;

+ ======================================================= +
+=mulfrac
+field0 MUL64_OPCODE=11111
+formats Mul64R Mul64I
+resources MUL
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary fractional multiply.
+stage_5_0
IF (((-operand1) == 0x80000000) AND ((-operand2) == 0x80000000))
{
	result1 = 0x7FFFFFFF;
}
ELSE
{
	result1 = operand1 * operand2;
	result1 = result1 + (1 << 30);
	result1 = result1 >> 31;
}

+ ======================================================= +
+=nandl
+field0 CMP3_OPCODE=1011
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Logical nand
+stage_3_0
result1 = NOT ((operand1 != 0) AND (operand2 != 0));

+ ======================================================= +
+=norl
+field0 CMP3_OPCODE=1101
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Logical nor
+stage_3_0
result1 = NOT ((operand1 != 0) OR (operand2 != 0));

+ ======================================================= +
+=or
+field0 INT3_OPCODE=01011
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Bitwise or
+stage_3_0
result1 = operand1 | operand2;

+ ======================================================= +
+=orc
+field0 INT3_OPCODE=01100
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Complement and bitwise or
+stage_3_0
result1 = (~operand1) | operand2;

+ ======================================================= +
+=orl
+field0 CMP3_OPCODE=1100
+formats Cmp3R_Reg Cmp3R_Br Cmp3I_Reg Cmp3I_Br
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Logical or
+stage_3_0
result1 = (operand1 != 0) OR (operand2 != 0);

+ ======================================================= +
+=pft
+field0 LOAD_OPCODE=0000
+formats Load
+resources LOAD
+op1 fixed=000000
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Prefetch
+syntax pft %2[%3]
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
IF (IsDBreakPrefetchHit(ea))
  THROW(DBREAK);
PrefetchCheckMemory(ea);
+stage_5_0
PrefetchMemory(ea);

+ ======================================================= +
+=pft.c
+field0 LOAD_OPCODE=0000
+formats LoadC
+resources LOAD
+op1 fixed=000000
+op2 name=cond, stage=2, type=unsigned
+op3 name=operand1, stage=2, type=signed
+op4 name=operand2, stage=2, type=signed
+summary Conditional prefetch
+syntax pft.c %2, %3[%4]
+temp1 name=ea
+stage_3_0
IF (cond)
{
  ea = ZeroExtend_32_(operand1 + operand2); 
  PrefetchCheckMemory(ea);
}
+stage_5_0
IF (cond)
  PrefetchMemory(ea);

+ ======================================================= +
+=prgadd
+field0 STORE_OPCODE=1111
+field4 LS_SUBOPCODE=000
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 fixed=000000
+summary Purge the address given from the data cache
+syntax prgadd %1[%2]
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
PurgeAddressCheckMemory(ea);
+stage_5_0
PurgeAddress(ea);

+ ======================================================= +
+=prgins
+field0 SYSTEM_OPCODE=000000100
+formats System
+resources CALL
+op1 fixed=000000
+op2 fixed=000000
+syntax prgins
+summary Purge the instruction cache
+stage_3_0
IF (PSW[USER_MODE])
	THROW(ILL_INST);
+stage_5_0
PurgeIns();

+ ======================================================= +
+=prginspg
+field0 STORE_OPCODE=1111
+field4 LS_SUBOPCODE=010
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 fixed=000000
+summary Purge a 8kb page from the instruction cache
+syntax prginspg %1[%2]
+temp1 name=ea
+stage_3_0
IF (PSW[USER_MODE])
	THROW(ILL_INST);
ea = ZeroExtend_32_(operand1 + operand2);
+stage_5_0
PurgeInsPg(ea);

+ ======================================================= +
+=prgset
+field0 STORE_OPCODE=1111
+field4 LS_SUBOPCODE=001
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 fixed=000000
+summary Purge a set of four cache lines from the data cache
+syntax prgset %1[%2]
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
+stage_5_0
PurgeSet(ea);

+ ======================================================= +
+=pswset
+field0 SYSTEM_OPCODE=000000000
+formats System
+resources STORE BRANCH
+op1 fixed=000000
+op2 name=operand, stage=2, type=signed
+summary Atomic psw set.
+syntax pswset %2
+stage_3_0
IF (PSW[USER_MODE])
	THROW(ILL_INST);
+stage_5_0
PswSet(operand);

+ ======================================================= +
+=pswclr
+field0 SYSTEM_OPCODE=000000001
+formats System
+resources STORE BRANCH
+op1 fixed=000000
+op2 name=operand, stage=2, type=signed
+summary Atomic psw clear.
+syntax pswclr %2
+stage_3_0
IF (PSW[USER_MODE])
	THROW(ILL_INST);
+stage_5_0
PswClr(operand);

+ ======================================================= +
+=rem.i
+field0 FLOAT_OPCODE=11001
+formats Maths3R_Dss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE integer remainder
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = IRemIeee(operand1, operand2);

+ ======================================================= +
+=rem.u
+field0 FLOAT_OPCODE=11011
+formats Maths3R_Dss
+resources FPU
+lr readonly
+op1 name=result1, stage=5
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned
+state1 name=VERSION, kind=src, stage=3
+summary IEEE unsigned integer remainder
+stage_3_0
IF (NOT (Bit(VERSION, 8)))
	THROW(ILL_INST);
+stage_5_0
result1 = UIRemIeee(operand1, operand2);

+ ======================================================= +
+=rfi
+field0 CALL_OPCODE=010
+field1 LNK=0
+formats Call
+resources CALL LOAD
+op1 fixed=00000000000000000000000
+state1 name=SAVED_PC, kind=src, stage=1
+state2 name=SAVED_PC, kind=dst, stage=5
+state3 name=SAVED_PSW, kind=src, stage=1
+state4 name=SAVED_PSW, kind=dst, stage=5
+state5 name=SAVED_SAVED_PC, kind=src, stage=1
+state6 name=SAVED_SAVED_PSW, kind=src, stage=1
+state7 name=PSW, kind=src, stage=1
+state8 name=PSW, kind=dst, stage=5
+state9 name=PC, kind=dst, stage=1
+summary Return from interrupt
+syntax rfi
+stage_1_0
IF (PSW[USER_MODE])
	THROW(ILL_INST);
PC = Register(ZeroExtend_32_(SAVED_PC));
+stage_5_0
PSW = SAVED_PSW;
SAVED_PC = SAVED_SAVED_PC;
SAVED_PSW = SAVED_SAVED_PSW;
Rfi();

+ ======================================================= +
+=sbrk
+field0 SBREAK_OPCODE=1111101
+field1 STOPBIT=1
+formats SBreak
+resources ALU
+summary Software breakpoint
+stage_3_0
THROW(SBREAK);

+ ======================================================= +
+=sh1add
+field0 INT3_OPCODE=00101
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Shift left one and accumulate
+stage_3_0
result1 = (operand1 << 1) + operand2;

+ ======================================================= +
+=sh2add
+field0 INT3_OPCODE=00110
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Shift left two and accumulate
+stage_3_0
result1 = (operand1 << 2) + operand2;

+ ======================================================= +
+=sh3add
+field0 INT3_OPCODE=00111
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Shift left three and accumulate
+stage_3_0
result1 = (operand1 << 3) + operand2;

+ ======================================================= +
+=sh4add
+field0 INT3_OPCODE=01000
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Shift left four and accumulate
+stage_3_0
result1 = (operand1 << 4) + operand2;

+ ======================================================= +
+=shl
+field0 INT3_OPCODE=00010
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=unsigned, size=8
+summary Shift left
+stage_3_0
IF (operand2 > 31)
result1 = 0;
ELSE
result1 = operand1 << operand2;

+ ======================================================= +
+=shr
+field0 INT3_OPCODE=00011
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=unsigned, size=8
+summary Arithmetic shift right
+stage_3_0
result1 = operand1 >> operand2;

+ ======================================================= +
+=shru
+field0 INT3_OPCODE=00100
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=unsigned, size=8
+summary Logical shift right
+stage_3_0
result1 = operand1 >> operand2;

+ ======================================================= +
+=slct
+field0 SLCT_OPCODE=000
+formats SelectR SelectI
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=signed
+op4 name=operand3, stage=2, type=signed
+summary Conditional select
+stage_3_0
IF (operand1 != 0) 
	result1 = operand2; 
ELSE 
	result1 = operand3;

+ ======================================================= +
+=slctf
+field0 SLCT_OPCODE=001
+formats SelectR SelectI
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned
+op3 name=operand2, stage=2, type=signed
+op4 name=operand3, stage=2, type=signed
+summary Conditional select
+stage_3_0
IF (operand1 == 0) 
	result1 = operand2; 
ELSE 
	result1 = operand3;

+ ======================================================= +
+=stb
+field0 STORE_OPCODE=1100
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 name=operand3, stage=2, type=signed
+summary Store byte
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2);
IF (IsDBreakStoreHit(ea))
  THROW(DBREAK);
IF (IsCRegSpace(ea))
  THROW(CREG_ACCESS_VIOLATION);
WriteCheckMemory_8_(ea);
+stage_5_0
WriteMemory_8_(ea, operand3);

+ ======================================================= +
+=stb.c
+field0 STORE_OPCODE=1100
+formats StoreC
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 name=cond, stage=2, type=unsigned
+op4 name=operand3, stage=2, type=signed
+summary Conditional store byte
+temp1 name=ea
+stage_3_0
IF (cond)
{
  ea = ZeroExtend_32_(operand1 + operand2);
  IF (IsDBreakStoreHit(ea))
    THROW(DBREAK);
  IF (IsCRegSpace(ea))
    THROW(CREG_ACCESS_VIOLATION);
  WriteCheckMemory_8_(ea);
}
+stage_5_0
IF (cond)
  WriteMemory_8_(ea, operand3);

+ ======================================================= +
+=std
+field0 STORE_OPCODE=1000
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 name=operand3, stage=2, type=unsigned, size=64
+summary Store double word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsDBreakStoreHit(ea))
  THROW(DBREAK);
IF (IsCRegSpace(ea))
  THROW(CREG_ACCESS_VIOLATION);
ELSE  
  WriteCheckMemory_64_(ea);
+stage_5_0
WriteMemory_64_(ea, operand3);

+ ======================================================= +
+=std.c
+field0 STORE_OPCODE=1000
+formats StoreC
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 name=cond, stage=2, type=unsigned
+op4 name=operand3, stage=2, type=unsigned, size=64
+summary Conditional store double word
+temp1 name=ea
+stage_3_0
IF (cond)
{
  ea = ZeroExtend_32_(operand1 + operand2); 
  IF (IsDBreakStoreHit(ea))
    THROW(DBREAK);
  IF (IsCRegSpace(ea))
    THROW(CREG_ACCESS_VIOLATION);
  ELSE  
    WriteCheckMemory_64_(ea);
}
+stage_5_0
IF (cond)
  WriteMemory_64_(ea, operand3);

+ ======================================================= +
+=sth
+field0 STORE_OPCODE=1010
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 name=operand3, stage=2, type=signed
+summary Store half-word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsDBreakStoreHit(ea))
  THROW(DBREAK);
IF (IsCRegSpace(ea))
  THROW(CREG_ACCESS_VIOLATION);
WriteCheckMemory_16_(ea);
+stage_5_0
WriteMemory_16_(ea, operand3);

+ ======================================================= +
+=sth.c
+field0 STORE_OPCODE=1010
+formats StoreC
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 name=cond, stage=2, type=unsigned
+op4 name=operand3, stage=2, type=signed
+summary Conditional store half-word
+temp1 name=ea
+stage_3_0
IF (cond)
{
  ea = ZeroExtend_32_(operand1 + operand2); 
  IF (IsDBreakStoreHit(ea))
    THROW(DBREAK);
  IF (IsCRegSpace(ea))
    THROW(CREG_ACCESS_VIOLATION);
  WriteCheckMemory_16_(ea);
}
+stage_5_0
IF (cond)
  WriteMemory_16_(ea, operand3);

+ ======================================================= +
+=stw
+field0 STORE_OPCODE=1001
+formats Store
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 name=operand3, stage=2, type=signed
+summary Store word
+temp1 name=ea
+stage_3_0
ea = ZeroExtend_32_(operand1 + operand2); 
IF (IsDBreakStoreHit(ea))
  THROW(DBREAK);
IF (IsCRegSpace(ea))
  WriteCheckCReg(ea);
ELSE  
  WriteCheckMemory_32_(ea);
+stage_5_0
IF (IsCRegSpace(ea))
  WriteCReg(ea, operand3);
ELSE
  WriteMemory_32_(ea, operand3);

+ ======================================================= +
+=stw.c
+field0 STORE_OPCODE=1001
+formats StoreC
+resources STORE
+op1 name=operand1, stage=2, type=signed
+op2 name=operand2, stage=2, type=signed
+op3 name=cond, stage=2, type=unsigned
+op4 name=operand3, stage=2, type=signed
+summary Conditional store word
+temp1 name=ea
+stage_3_0
IF (cond)
{
  ea = ZeroExtend_32_(operand1 + operand2); 
  IF (IsDBreakStoreHit(ea))
    THROW(DBREAK);
  IF (IsCRegSpace(ea))
    WriteCheckCReg(ea);
  ELSE  
    WriteCheckMemory_32_(ea);
}
+stage_5_0
IF (cond)
{
  IF (IsCRegSpace(ea))
    WriteCReg(ea, operand3);
  ELSE
    WriteMemory_32_(ea, operand3);
}

+ ======================================================= +
+=stwl
+field0 STORE_OPCODE=1111
+field1 STOREL_OPCODE=100000
+formats StoreL
+resources STORE
+op1 name=cond, stage=5, type=unsigned
+op2 name=ea,   stage=2, type=unsigned
+op3 name=operand1, stage=2, type=signed
+state1 name=LOCK_ADDRESS, kind=src, stage=3
+summary Test lock and store
+stage_3_0
IF (IsCRegSpace(ea))
  THROW(CREG_ACCESS_VIOLATION);
IF (LOCK_ADDRESS[LOCKED])
{
  IF (IsDBreakStoreHit(ea))
    THROW(DBREAK);
  ELSE  
    WriteCheckMemory_32_(ea);
}
+stage_5_0
IF (IsCRegSpace(ea))
  cond = 0;
ELSE
  cond = WriteLockMemory_32_(ea, operand1);

+ ======================================================= +
+=sub
+field0 INT3_OPCODE=00001
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Subtract
+syntax sub %1 = %3, %2
+stage_3_0
result1 = operand2 - operand1;

+ ======================================================= +
+=sxtb
+field0 MONADIC_OPCODE=000000000
+formats Monadic
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed, size=8
+summary Sign extend byte
+stage_3_0
result1 = operand1;

+ ======================================================= +
+=sxth
+field0 MONADIC_OPCODE=000000001
+formats Monadic
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed, size=16
+summary Sign extend half
+stage_3_0
result1 = operand1;

+ ======================================================= +
+=sync
+field0 SYSTEM_OPCODE=000000010
+formats System
+resources LOAD
+op1 fixed=000000
+op2 fixed=000000
+summary Ensure that all outstanding memory transactions have completed.
+syntax sync
+stage_5_0
Sync();

+ ======================================================= +
+=syscall
+field0 SBREAK_OPCODE=1111110
+formats SBreak
+resources ALU
+summary System call
+syntax syscall
+stage_3_0
THROW(SYSCALL);

+ ======================================================= +
+=wmb
+field0 SYSTEM_OPCODE=000000011
+formats System
+resources LOAD
+op1 fixed=000000
+op2 fixed=000000
+summary Ensures coherency within a cluster.
+syntax wmb
+stage_5_0
Wmb();

+ ======================================================= +
+=xor
+field0 INT3_OPCODE=01101
+formats Int3R Int3I
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=signed
+op3 name=operand2, stage=2, type=signed
+summary Bitwise exclusive-or
+stage_3_0
result1 = operand1 ^ operand2;

+ ======================================================= +
+=zxth
+field0 MONADIC_OPCODE=000000011
+formats Monadic
+resources ALU
+op1 name=result1, stage=3
+op2 name=operand1, stage=2, type=unsigned, size=16
+summary Zero extend half
+stage_3_0
result1 = operand1;

+ ======================================================= +

















