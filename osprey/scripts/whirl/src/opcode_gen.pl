#!/usr/bin/perl --	# -*-Perl-*-

#
#
#  Copyright (C) 2000 Silicon Graphics, Inc.  All Rights Reserved.
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of version 2 of the GNU General Public License as
#  published by the Free Software Foundation.
#
#  This program is distributed in the hope that it would be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
#
#  Further, this software is distributed without any warranty that it is
#  free of the rightful claim of any third person regarding infringement 
#  or the like.  Any license provided herein, whether implied or 
#  otherwise, applies only to this software file.  Patent licenses, if 
#  any, provided herein do not apply to combinations of this program with 
#  other software, or any other product whatsoever.  
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write the Free Software Foundation, Inc., 59
#  Temple Place - Suite 330, Boston MA 02111-1307, USA.
#
#  Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pky,
#  Mountain View, CA 94043, or:
#
#  http://www.sgi.com
#
#  For further information regarding this notice, see:
#
#  http://oss.sgi.com/projects/GenInfo/NoticeExplan
#
#

### $Revision$
### $Date$
### $Author$
### $Source$

###########################################################################
###
### This file contains two parts.  The first, directly following, is a
### table which is used to define all WHIRL opcodes, types and opcode
### attributes.  This table is actually a series of perl statements
### (typically perl subroutine calls, recognizable by the & prefix).
### The second part contains the perl functions that implement
### these tables and generates C code to be used in the compiler.
###
### [Note: opcode.h is a C file that contains descriptions of functions
### generated by this perl script, e.g OPCODE_has_sym(op), etc.  Any
### changes to this file probably need to be reflected in the comments
### in opcode.h.]
###
###########################################################################


###########################################################################
###########################################################################
###########################################################################
###########################################################################
###
### PART I: tabular definition of WHIRL opcodes, types and attributes
###
###########################################################################
###########################################################################
###########################################################################
###########################################################################

# Although not necessary in perl, I've enclosed the "main program" in
# braces for documentation purposes.

{

###########################################################################
###
### Miscellaneous information.
###
###########################################################################

  $GENERAL_PREFIX = "OPERATOR_";
  $GOP_PREFIX = "OPR_";
  $OP_PREFIX = "OPC_";
  $OP_TYPE = "OPCODE";
  $GOP_TYPE = "OPERATOR";

  &OUTFILES("opcode_gen_core.h",
	    "opcode_gen.h",
	    "opcode_gen_core.cxx",
	    "wn_simp_ftable.h",
	    "mtypes.h",
	    "mtypes.cxx");

#
# begin bracketing ifndef in case opcode_gen_core.h is included multiple times
#

  printf(HFILET "#ifndef opcode_gen_core_INCLUDED\n");
  printf(HFILET "#define opcode_gen_core_INCLUDED\n\n");

###########################################################################
###
### TYPES
###
### WHIRL type information, and type abbreviations used in this file.
###
### The order is important: following tables depend on it:
###
###   1. convert_rule[] in be/com/opt_cvtl_rule.cxx
###
### &WHIRLTYPE("I") indicates that "I" is a base type in whirl
### &ABBREVTYPE("i", "I", "J", "K", "L") shows that "i" is an abbreviation
###	for I J K L.
###
###########################################################################

  &BEGIN_TYPECLASS();
  &NEW_TYPECLASS("INTEGER");
  &NEW_TYPECLASS("FLOAT");
  &NEW_TYPECLASS("COMPLEX");
  &NEW_TYPECLASS("UNSIGNED");
  &NEW_TYPECLASS("STR");
  &NEW_TYPECLASS("POINTER");
  &NEW_TYPECLASS("BOOLEAN");
#  &NEW_TYPECLASS("DOUBLE");

  # bint and pint are kept for compatibility with the old mtype 
  # definitions. TODO: clean up.
  &ABBREVCLASS("uint", "UNSIGNED", "INTEGER");
  &ABBREVCLASS("bint", "INTEGER", "BOOLEAN");
  &ABBREVCLASS("pint", "UNSIGNED", "INTEGER", "POINTER");
  &ABBREVCLASS("cfloat", "COMPLEX", "FLOAT");
#  &ABBREVCLASS("dint", "DOUBLE", "INTEGER");
#  &ABBREVCLASS("duint", "DOUBLE", "UNSIGNED", "INTEGER");
#  &ABBREVCLASS("dfloat", "DOUBLE", "FLOAT");

  $MTYPE_CLASS_PREFIX = "MTYPE_CLASS_";

  &END_TYPECLASS();

  &BEGIN_WHIRLTYPE();

  &WHIRLTYPE("B", "bint", "BOOL", "", 1, 0, "TARG_NONE_ALIGN", 0, "B");

  &WHIRLTYPE("I1", "INTEGER", "8-bit integer", "", 8, 1, "TARG_BYTE_ALIGN", 1, "U1");
  &WHIRLTYPE_NEXTALIGN("I1", "I2");
  &WHIRLTYPE_COMPARISON("I1", "I4");


  &WHIRLTYPE("I2", "INTEGER", "16-bit integer", "", 16, 2, "TARG_CARD_ALIGN", 3, "U2");
  &WHIRLTYPE_NEXTALIGN("I2", "I4");
  &WHIRLTYPE_PREVALIGN("I2", "I1");
  &WHIRLTYPE_COMPARISON("I2", "I4");

  &WHIRLTYPE("I4", "INTEGER", "32-bit integer", "", 32, 4, "TARG_WORD_ALIGN", 5, "U4");
  &WHIRLTYPE_NEXTALIGN("I4", "I8");
  &WHIRLTYPE_PREVALIGN("I4", "I2");

  &WHIRLTYPE("I8", "INTEGER", "64-bit integer", "", 64, 8, "TARG_DWORD_ALIGN", 7, "U8");
  &WHIRLTYPE_PREVALIGN("I8", "I4");

  &WHIRLTYPE("U1", "uint", "8-bit unsigned integer", "", 8, 1, "TARG_BYTE_ALIGN", 2, "I1");
  &WHIRLTYPE_NEXTALIGN("U1", "U2");
  &WHIRLTYPE_COMPARISON("U1", "U4");

  &WHIRLTYPE("U2", "uint", "16-bit unsigned integer", "", 16, 2, "TARG_CARD_ALIGN", 4, "I2");
  &WHIRLTYPE_NEXTALIGN("U2", "U4");
  &WHIRLTYPE_PREVALIGN("U2", "U1");
  &WHIRLTYPE_COMPARISON("U2", "U4");

  &WHIRLTYPE("U4", "uint", "32-bit unsigned integer", "", 32, 4, "TARG_WORD_ALIGN", 6, "I4");
  &WHIRLTYPE_NEXTALIGN("U4", "U8");
  &WHIRLTYPE_PREVALIGN("U4", "U2");

  &WHIRLTYPE("U8", "uint", "64-bit unsigned integer", "", 64, 8, "TARG_DWORD_ALIGN", 8, "I8");
  &WHIRLTYPE_PREVALIGN("U8", "U4");

  &WHIRLTYPE("I5", "INTEGER", "40-bit integer", "", 40, 8, "TARG_DWORD_ALIGN", 7, "U5");
  &WHIRLTYPE_PREVALIGN("I5", "I4");
#  &WHIRLTYPE_COMPARISON("I5", "I8");

  &WHIRLTYPE("U5", "uint", "40-bit unsigned integer", "", 40, 8, "TARG_DWORD_ALIGN", 8, "I5");
  &WHIRLTYPE_PREVALIGN("U5", "U4");
#  &WHIRLTYPE_COMPARISON("U5", "U8");

  &WHIRLTYPE("A4", "pint", "32-bit address", "", 32, 4, "TARG_WORD_ALIGN", 6, "A4");
  &WHIRLTYPE("A8", "pint", "64-bit address", "", 64, 8, "TARG_DWORD_ALIGN", 8, "A8");

  &WHIRLTYPE("F4", "FLOAT", "32-bit IEEE floating point", "", 32, 4, "TARG_WORD_ALIGN", 9, "F4");
  &WHIRLTYPE_NEXTALIGN("F4", "F8");

  &WHIRLTYPE("F8", "FLOAT", "64-bit IEEE floating point", "", 64, 8, "TARG_DWORD_ALIGN", 11, "F8");
  &WHIRLTYPE_NEXTALIGN("F8", "FQ");
  &WHIRLTYPE_PREVALIGN("F8", "F4");

  &WHIRLTYPE("F10", "FLOAT", "80-bit IEEE floating point", "", 128, 16, "TARG_QUAD_ALIGN", 13, "F10");
  &WHIRLTYPE("F16", "FLOAT", "128-bit IEEE floating point", "", 128, 16, "TARG_QUAD_ALIGN", 15, "F16");

  &WHIRLTYPE("STR", "STR", "char strings - TCONs only", "", 0, 0, "TARG_BYTE_ALIGN", 0, "STR");
  &WHIRLTYPE("STRING", "STR", "", "STR");

  &WHIRLTYPE("FQ", "FLOAT", "for SGI long double", "", 128, 16, "TARG_QUAD_ALIGN", 14, "FQ");
  &WHIRLTYPE_PREVALIGN("FQ", "F8");

  &WHIRLTYPE("M", "UNKNOWN", "memory chunk, for structures", "", 0, 0, "TARG_NONE_ALIGN", 0, "M");
  &WHIRLTYPE("C4", "cfloat", "for 32-bit complex", "", 64, 4, "TARG_WORD_ALIGN", 10, "C4");
  &WHIRLTYPE_NEXTALIGN("C4", "C8");
  &WHIRLTYPE_COMPLEXTOREAL ("C4", "F4");

  &WHIRLTYPE("C8", "cfloat", "for 64-bit complex", "", 128, 8, "TARG_DWORD_ALIGN", 12, "C8");
  &WHIRLTYPE_NEXTALIGN("C8", "CQ");
  &WHIRLTYPE_PREVALIGN("C8", "C4");
  &WHIRLTYPE_COMPLEXTOREAL ("C8", "F8");

  &WHIRLTYPE("CQ", "cfloat", "for quad complex", "", 256, 16, "TARG_QUAD_ALIGN", 16, "CQ");
  &WHIRLTYPE_PREVALIGN("CQ", "C8");
  &WHIRLTYPE_COMPLEXTOREAL ("CQ", "FQ");

  &WHIRLTYPE("V", "UNKNOWN", "for void type", "", 0, 0, "TARG_NONE_ALIGN", 0, "V");

  &WHIRLTYPE("BS", "INTEGER", "Bits", "", 1, 0, "TARG_NONE_ALIGN", 0, "BS");
  &WHIRLTYPE("C10", "cfloat", "80-bit IEEE floating point complex", "", 256, 16, "TARG_QUAD_ALIGN", 16, "C10");
  &WHIRLTYPE("C16", "cfloat", "128-bit IEEE floating point complex", "", 256, 16, "TARG_QUAD_ALIGN", 16, "C16");
  &WHIRLTYPE("I16", "INTEGER", "128-bit signed integer", "", 256, 16, "TARG_QUAD_ALIGN", 16, "U16");
  &WHIRLTYPE("U16", "uint", "128-bit unsigned integer", "", 256, 16, "TARG_QUAD_ALIGN", 16, "I16");

  &ABBREVTYPE("i", "I4", "I5", "I8", "U4", "U5", "U8", "I16", "U16");
  &ABBREVTYPE("f", "F4", "F8", "FQ", "F10", "F16");
  &ABBREVTYPE("z", "C4", "C8", "CQ", "C10", "C16");
  &ABBREVTYPE("s", "I1", "I2", "U1", "U2");
  &ABBREVTYPE("b", "I4", "B");
  &ABBREVTYPE("p", "U4", "U8", "A4", "A8");	# depending on the model, could be either
  &ABBREVTYPE("bs", "BS");

  $MTYPE_TYPE = "TYPE_ID";
  $MTYPE_PREFIX = "MTYPE_";

  &END_WHIRLTYPE();

###########################################################################
###
### WHIRLTYPE DESCRIPTION STRUCTURE
###
###########################################################################

  # enumeration types used in the compiler
  $IDX = "mCLASS_INDEX";      # index type
  $BOOL = "mBOOL";
  $UINT8 = "mUINT8";
  $UINT16 = "mUINT16";

  &BEGIN_WHIRLDESC ();
  &WHIRLDESC("id", $IDX, "Type index -- MTYPE_xxx above");
  &WHIRLDESC("bit_size", $UINT16, "bit size");
  &WHIRLDESC("byte_size", $UINT16, "byte size (NYI)");
  &WHIRLDESC("dummy1", $UINT16, "remove when incompatible change");
#  &WHIRLDESC("alignment", $UINT8, "byte alignment");
  &WHIRLDESC("alignment", $UINT8, "byte alignment defined in config_targ.h");
  &WHIRLDESC("dummy2", $UINT8, "remove when incompatible change");
  &WHIRLDESC("dummy3", $UINT8, "remove when incompatible change");
  &WHIRLDESC("signed_type", $BOOL, "Signed numeric type?");
  &WHIRLDESC("float_type", $BOOL, "Floating point type?");
  &WHIRLDESC("dummy4", $IDX, "remove when incompatible change");
  &WHIRLDESC("name", "char *", "Print name");
  &WHIRLDESC("type_class", $UINT8, "The classification bits used by the simplifier");
  &WHIRLDESC("type_order", $UINT8, "The order of types (I8 > I4 for example)");
  &WHIRLDESC("complement", $IDX, "complementary signed partner (ex. U1 -> I1)");

  &END_WHIRLDESC();

###########################################################################
###
### WHIRLTYPE FUNCTIONAL INTERFACE
###
###########################################################################

  &BEGIN_WHIRLFUNC();
  &END_WHIRLFUNC();

###########################################################################
###
### PROPERTIES
###
### Properties are listed here for documentation purposes.
### Also, any properties used later are checked against this list.
### Finally, the second entry is the C type of this property.
###
### &NEW_PROPERTY(prop, type) says that there is a property called
###	'prop' that has the given associated C type.  'prop' will be
###	the field name of the property.  The type "flag" is
###	implemented using one bit from a field.  The perl
###	script will generate a function called
###	OPCODE_is_'prop'($OP_TYPE) that takes an opcode and
###	returns 0 if the property doesn't exist for that opcode
###	and non-zero if it does exist for that opcode.
###     (Note that "mINT8" could be a sensible alternative to "flag"
###     for heavily used properties.)
###
### &NEW_VALUED_PROPERTY(prop, type[, dflt]) says that there is a
###	property called 'prop' that has the given associated C type.
###	This property must either have a value supplied with it for each
###	opcode, or else have a default to say what that value should be
###	if it is not supplied.  Generates a function called
###	OPCODE_'prop'($OP_TYPE) that returns the value of the property.
###
### We define some appreviations for the property names to keep this
###	file more readable.
###
###########################################################################

  $PROPERTY_ACCESSOR_PREFIX = $GENERAL_PREFIX . "is_";
  $VALUED_PROPERTY_ACCESSOR_PREFIX = $GENERAL_PREFIX . "";

  $SCF = "scf";				# structured control flow, e.g. IF
  $STMT = "stmt";			# statement, e.g. DEFLABEL
  $EXP = "expression";			# expression, e.g. ADD
  $LEAF = "leaf";			# leaf, e.g. CONST
  $STORE = "store";			# store, e.g. STID
  $LOAD = "load";			# load, e.g. LDID
  $CALL = "call";			# call, e.g. ICALL
  $CMP = "compare";			# comparison, e.g. GE
  $NSCF = "non_scf";			# non-structured cf, e.g. GOTO
  $BOOL = "boolean";			# boolean return value only, e.g. GE
  $NK = "nkids";			# number of kids, or -1 if variable
  $MC = "mapcat";			# annotation category
  $EBB = "endsbb";			# opcode ends a bb
  $CUI = "comp_unit_if";		# compilation unit interface, e.g. REGION
  $NE = "not_executable";		# e.g. COMMENT
  $PREF = "prefetch";			# a prefetch

  $HAS_NEXT_PREV = "next_prev";
  $HAS_SYM = "sym";
  $HAS_LBL_NUM = "label";
  $HAS_NE = "num_entries";
  $HAS_OFFSET = "offset";
  $HAS_2OFFSETS = "2offsets";
  $HAS_BITS = "bits";
  $HAS_NDIM = "ndim";
  $HAS_ESIZE = "esize";
  $HAS_VALUE = "value";
  $HAS_FLAGS = "flags";
  $HAS_INUMBER = "inumber";
  $HAS_1TY = "1ty";
  $HAS_2TY = "2ty";
  $HAS_EREG_SUPP = "ereg_supp";		# exception region supplement
  $HAS_BARRIER = "barrier";
  $HAS_LAST_LABEL = "last_label";
  $HAS_FIELD_ID = "field_id";

  $property_accessor_prefix{$HAS_NEXT_PREV} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_SYM} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_LBL_NUM} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_NE} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_OFFSET} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_2OFFSETS} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_BITS} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_NDIM} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_ESIZE} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_VALUE} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_FLAGS} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_INUMBER} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_1TY} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_2TY} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_EREG_SUPP} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_BARRIER} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_LAST_LABEL} = $GENERAL_PREFIX . "has_";
  $property_accessor_prefix{$HAS_FIELD_ID} = $GENERAL_PREFIX . "has_";

# If anything in OPCODE_MAPCAT changes, don't forget to update
# the documentation in wn_core.h

  printf(HFILET "#ifdef __cplusplus\n");
  printf(HFILET "extern \"C\" {\n");
  printf(HFILET "#endif\n\n");

  printf(HFILET "/* annotation categories */\n\n");
  printf(HFILET "typedef enum {\n");
  printf(HFILET "  OPERATOR_MAPCAT_HDR    = 0,\n");
  printf(HFILET "  OPERATOR_MAPCAT_SCF    = 1,\n");
  printf(HFILET "  OPERATOR_MAPCAT_LDST   = 2,\n");
  printf(HFILET "  OPERATOR_MAPCAT_PRAGMA = 3,\n");
  printf(HFILET "  OPERATOR_MAPCAT_OSTMT  = 4,\n");
  printf(HFILET "  OPERATOR_MAPCAT_OEXP   = 5,\n");
  printf(HFILET "  OPERATOR_MAPCAT_ARRAY  = 6,\n");
  printf(HFILET "  OPERATOR_MAPCAT_CALL   = 7\n");
  printf(HFILET "} OPERATOR_MAPCAT;\n\n");
  printf(HFILET "#define WN_MAP_CATEGORIES 8\n\n");

  $MCHDR = "OPERATOR_MAPCAT_HDR";
  $MCSCF = "OPERATOR_MAPCAT_SCF";
  $MCLDST = "OPERATOR_MAPCAT_LDST";
  $MCPR = "OPERATOR_MAPCAT_PRAGMA";
  $MCSTMT = "OPERATOR_MAPCAT_OSTMT";
  $MCEXP = "OPERATOR_MAPCAT_OEXP";
  $MCARRAY = "OPERATOR_MAPCAT_ARRAY";
  $MCCALL = "OPERATOR_MAPCAT_CALL";

  &BEGIN_PROPERTY();

  &NEW_PROPERTY($SCF, "flag");
  &NEW_PROPERTY($STMT, "flag");
  &NEW_PROPERTY($EXP, "flag");
  &NEW_PROPERTY($LEAF, "flag");
  &NEW_PROPERTY($STORE, "flag");
  &NEW_PROPERTY($LOAD, "flag");
  &NEW_PROPERTY($CALL, "flag");
  &NEW_PROPERTY($CMP, "flag");
  &NEW_PROPERTY($NSCF, "flag");
  &NEW_PROPERTY($BOOL, "flag");
  &NEW_PROPERTY($EBB, "flag");
  &NEW_PROPERTY($CUI, "flag");
  &NEW_PROPERTY($NE, "flag");
  &NEW_PROPERTY($PREF, "flag");

  &NEW_PROPERTY($HAS_NEXT_PREV, "flag");
  &NEW_PROPERTY($HAS_SYM, "flag");
  &NEW_PROPERTY($HAS_LBL_NUM, "flag");
  &NEW_PROPERTY($HAS_NE, "flag");
  &NEW_PROPERTY($HAS_OFFSET, "flag");
  &NEW_PROPERTY($HAS_2OFFSETS, "flag");
  &NEW_PROPERTY($HAS_BITS, "flag");
  &NEW_PROPERTY($HAS_NDIM, "flag");
  &NEW_PROPERTY($HAS_ESIZE, "flag");
  &NEW_PROPERTY($HAS_VALUE, "flag");
  &NEW_PROPERTY($HAS_FLAGS, "flag");
  &NEW_PROPERTY($HAS_INUMBER, "flag");
  &NEW_PROPERTY($HAS_1TY, "flag");
  &NEW_PROPERTY($HAS_2TY, "flag");
  &NEW_PROPERTY($HAS_EREG_SUPP, "flag");
  &NEW_PROPERTY($HAS_BARRIER, "flag");
  &NEW_PROPERTY($HAS_LAST_LABEL, "flag");
  &NEW_PROPERTY($HAS_FIELD_ID, "flag");

  &NEW_VALUED_PROPERTY($NK, "mINT8", "i", -1);        # "i": integer valued
  &NEW_VALUED_PROPERTY($MC, "OPERATOR_MAPCAT", "e");     # "e": enum valued

  &END_PROPERTY();

###########################################################################
###
### OPCODES
###
### This part defines all the operators in WHIRL.  Each call defines a
### set of opcodes, all with the same generic operator.  The generic
### operator, the 'return types' allowed for that operator, the
### 'descriptor types' allowed for that operator, and the properties
### (one of those defined by NEW_PROPERTY above) are indicated.  A
### cross product of the return types and the descriptors are taken.
### If a more restrictive set of typing is desired, then multiple
### calls to OP with the same generic opcode can be performed.
###
### &OP(generic_op, return_types, descriptor_types, properties, ...)
###	The first argument to OP is a string, the name of the generic
###	opcode.  The second and third parameters are also strings, comma
###	separated types defined by WHIRLTYPE or ABBREVTYPE.  The
###	fourth and further arguments are all the properties.
###     PROPERTIES ON PROPERTY LISTS HAVE INITIAL VALUES OF 1.
###	PROPERTIES NOT ON PROPERTY LISTS HAVE AN INITIAL VALUES OF 0.
###	This makes sense, but could be generalized.  For example, if we
###	decided to make "number of kids" a property, we'd have to change
###	the script.
###
###########################################################################

  &BEGIN_OP();

  &OP("ABS",          "I4,I5,I8,f",    "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("ADD",          "i,f,z,p",    "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("AGOTO",        "V",          "V",  $STMT, $NSCF, $EBB,
      $NK, 1, $MC, $MCSTMT, $HAS_NEXT_PREV);

  &OP("ALTENTRY",     "V",          "V",  $STMT, $NSCF,
      $MC, $MCSTMT, $HAS_NEXT_PREV, $HAS_SYM);

  &OP("ARRAY",        "p",          "V",  $EXP, $MC, $MCARRAY,
      $HAS_NDIM, $HAS_ESIZE);

  &OP("ARRAYEXP",     "i,f,z,M",    "V",  $EXP, $MC, $MCEXP);

  &OP("ARRSECTION",   "p",          "V",  $EXP, $MC, $MCARRAY, $HAS_NDIM, $HAS_ESIZE);

  &OP("ASHR",         "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("ASSERT",		"V",	"V",	$STMT, $HAS_OFFSET, $NK, 1,
	$HAS_NEXT_PREV, $MC, $MCSTMT);

  &OP("BACKWARD_BARRIER",	"V",	"V",  $STMT, $NSCF, $MC, $MCSTMT, 
      $HAS_NEXT_PREV, $HAS_BARRIER);

  &OP("BAND",         "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("BIOR",         "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("BLOCK",        "V",          "V",  $SCF, $MC, $MCSCF,
      $HAS_NEXT_PREV);

  &OP("BNOR",         "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("BNOT",         "i",          "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("BXOR",         "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

#CALL can only have a limited range of return types
  &OPKEEP(I1CALL);  &OPKEEP(I2CALL);  &OPKEEP(I4CALL);  &OPKEEP(I8CALL);
  &OPKEEP(U1CALL);  &OPKEEP(U2CALL);  &OPKEEP(U4CALL);  &OPKEEP(U8CALL);
  &OPKEEP(I4I4CALL); &OPKEEP(I8I8CALL); &OPKEEP(U4U4CALL); &OPKEEP(U8U8CALL);
  &OPKEEP(I5CALL); &OPKEEP(U5CALL);
  &OPKEEP(F4CALL);  &OPKEEP(F8CALL);  &OPKEEP(FQCALL);
  &OPKEEP(C4CALL);  &OPKEEP(C8CALL);  &OPKEEP(VCALL);
  &OPKEEP(F4F4CALL); &OPKEEP(F4F8CALL); &OPKEEP(F8F4CALL); &OPKEEP(F8F8CALL);
  &OPKEEP(A4CALL); &OPKEEP(A8CALL); &OPKEEP(MCALL)
  &OPKEEP(F10CALL); &OPKEEP(F16CALL);
  &OPKEEP(CQCALL);  &OPKEEP(C10CALL); &OPKEEP(C16CALL);
  &OP("CALL",         "s,i,f,z,V,p,M",  "i,F4,F8,V,p,M",  $STMT, $CALL, $EBB,
      $MC, $MCCALL, $HAS_NEXT_PREV, $HAS_SYM, $HAS_FLAGS);

  &OP("CAND",         "b",          "V",  $EXP, $NK, 2, $MC, $MCEXP, $BOOL);

  &OP("CASEGOTO",     "V",          "V",  $STMT, $NSCF, $LEAF,
      $NK, 0, $MC, $MCSTMT, $HAS_NEXT_PREV, $HAS_VALUE, $HAS_LBL_NUM);

  &OP("CEIL",         "i",	    "f",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("CIOR",         "b",          "V",  $EXP, $NK, 2, $MC, $MCEXP, $BOOL);

  &OP("COMMA",         "i,f,z,p,M",   "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("COMMENT",       "V",          "V",  $STMT, $LEAF, $NK, 0, $MC, $MCSTMT,
      $HAS_NEXT_PREV, $HAS_SYM, $NE);

  &OP("COMPGOTO",     "V",          "V",  $STMT, $NSCF, $MC, $MCSCF, $EBB,
      $HAS_NEXT_PREV, $HAS_NE, $HAS_LAST_LABEL);

  &OP("PAIR",     "z",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

#  &OP("COMPLEX",      "z",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("CONST",        "i,f,z,p",         "V",
      $EXP,        $LEAF, $NK, 0, $MC, $MCEXP, $HAS_SYM);

  &OP("CSELECT",      "i,f,z,b,p,M,V","V",  $EXP, $NK, 3, $MC, $MCEXP);

  &OPIGN("I8I8CVT"); &OPIGN("I4I4CVT"); &OPIGN("I5I5CVT");
  &OPIGN("U8U8CVT"); &OPIGN("U4U4CVT"); &OPIGN("U5U5CVT");
  &OPIGN("F4F4CVT"); &OPIGN("F8F8CVT"); &OPIGN("FQFQCVT");
  &OPIGN("A4A4CVT"); &OPIGN("A8A8CVT");
  &OPIGN("F10F10CVT"); &OPIGN("F16F16CVT");
# &OPIGN("U8I8CVT"); &OPIGN("U4I4CVT"); &OPIGN("I8U8CVT"); &OPIGN("I4U4CVT");
# &OPIGN("A4I4CVT"); &OPIGN("A4U4CVT"); &OPIGN("I4A4CVT"); &OPIGN("U4A4CVT");
# &OPIGN("A8I8CVT"); &OPIGN("A8U8CVT"); &OPIGN("I8A8CVT"); &OPIGN("U8A8CVT");
  &OPIGN("I16BCVT"); &OPIGN("U16BCVT"); 
  &OPIGN("F4BCVT"); &OPIGN("F8BCVT"); &OPIGN("FQBCVT"); &OPIGN("F10BCVT");
  &OPIGN("F16BCVT");
  &OPIGN("A4BCVT"); &OPIGN("A8BCVT");

  &OP("CVT",          "i,f,p",      "i,f,p,b",$EXP, $NK, 1, $MC, $MCEXP);

  &OP("CVTL",         "i",          "V",  $EXP, $NK, 1, $MC, $MCEXP, $HAS_BITS);

  &OP("DIV",          "i,f,z",      "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("DIVREM",       "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

# DO_LOOP has 5 or 6 kids, depending on possible LOOP_INFO
  &OP("DO_LOOP",      "V",          "V",  $SCF, $MC, $MCSCF,
      $HAS_NEXT_PREV);

  &OP("DO_WHILE",     "V",          "V",  $SCF, $NK, 2, $MC, $MCSCF,
      $HAS_NEXT_PREV);

  &OPIGN("I4BEQ");   &OPIGN("I8BEQ");   &OPIGN("U4BEQ");   &OPIGN("U8BEQ");

  &OP("EQ",           "b,I4,I8,U4,U8",          "i,f,z,p,b",
      $EXP, $CMP, $NK, 2, $MC, $MCEXP, $BOOL);

  &OP("EVAL",         "V",          "V",  $STMT, $NK, 1, $MC, $MCSTMT,
      $HAS_NEXT_PREV);

  &OP("EXC_SCOPE_BEGIN",   "V",      "V",  $STMT, $NSCF, $MC, $MCSTMT, 
      $HAS_NEXT_PREV, $HAS_OFFSET, $HAS_EREG_SUPP);

  &OP("EXC_SCOPE_END",   "V",        "V", $STMT, $NSCF, $MC, $MCSTMT, 
      $HAS_NEXT_PREV, $HAS_OFFSET);

  &OP("FALSEBR",       "V",          "V",  $STMT, $NSCF, $EBB,
      $NK, 1, $MC, $MCSTMT, $HAS_NEXT_PREV, $HAS_LBL_NUM);

  &OP("FLOOR",        "i",	    "f",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("FORWARD_BARRIER",	"V",	"V",  $STMT, $NSCF, $MC, $MCSTMT, 
      $HAS_NEXT_PREV, $HAS_BARRIER);

  &OP("FUNC_ENTRY",   "V",          "V",  $SCF, $MC, $MCHDR,
      $HAS_NEXT_PREV, $HAS_SYM);

  &OP("GE",           "b,I4,I8,U4,U8",          "i,f,p",
      $EXP, $CMP, $NK, 2, $MC, $MCEXP, $BOOL);

  &OP("GOTO",         "V",          "V",  $STMT, $NSCF, $LEAF, $EBB,
      $NK, 0, $MC, $MCSTMT, $HAS_NEXT_PREV, $HAS_LBL_NUM);

  &OP("GT",           "b,I4,I8,U4,U8",          "i,f,p",
      $EXP, $CMP, $NK, 2, $MC, $MCEXP, $BOOL);

  &OP("HIGHMPY",       "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("HIGHPART",     "i",          "V",  $EXP, $NK, 1, $MC, $MCEXP);

#ICALL can only have a limited range of return types
  &OPKEEP(I1ICALL);  &OPKEEP(I2ICALL);  &OPKEEP(I4ICALL);  &OPKEEP(I5ICALL); &OPKEEP(I8ICALL);
  &OPKEEP(U1ICALL);  &OPKEEP(U2ICALL);  &OPKEEP(U4ICALL);  &OPKEEP(U5ICALL);  &OPKEEP(U8ICALL);
  &OPKEEP(I4I4ICALL); &OPKEEP(I8I8ICALL); &OPKEEP(U4U4ICALL); &OPKEEP(U8U8ICALL);
  &OPKEEP(F4ICALL);  &OPKEEP(F8ICALL);  &OPKEEP(FQICALL);
  &OPKEEP(C4ICALL);  &OPKEEP(C8ICALL);  &OPKEEP(VICALL);
  &OPKEEP(F4F4ICALL); &OPKEEP(F4F8ICALL); &OPKEEP(F8F4ICALL); &OPKEEP(F8F8ICALL);
  &OPKEEP(A4ICALL); &OPKEEP(A8ICALL); 
  &OPKEEP(MICALL);
  &OPKEEP(F10ICALL), &OPKEEP(F16ICALL);
  &OPKEEP(CQICALL),  &OPKEEP(C10ICALL), &OPKEEP(C16ICALL);
  &OP("ICALL",        "s,i,f,z,M,V,p",  "i,F4,F8,V,p",  $STMT, $CALL, $EBB,
      $MC, $MCCALL, $HAS_NEXT_PREV, $HAS_1TY, $HAS_FLAGS);

  &OP("IDNAME",       "V",           "V",
      $EXP,        $LEAF, $NK, 0, $MC, $MCEXP, $HAS_SYM, $HAS_OFFSET);

  &OP("IF",           "V",          "V",  $SCF, $NK, 3, $MC, $MCSCF,
      $HAS_NEXT_PREV);

  &OP("ILDA",          "p",           "V",
      $EXP,        $NK, 1, $MC, $MCEXP,
      $HAS_OFFSET, $HAS_1TY, $HAS_FIELD_ID);

  &OP("ILDBITS",         "i",  "s,I4,U4,I8,U8",  $EXP, $LOAD, $NK, 1, $MC, $MCLDST,
      $HAS_2TY, $HAS_OFFSET);

#ILOAD can only have a limited range of return types
  &OPKEEP(I8I8ILOAD);  &OPKEEP(I8I5ILOAD);  &OPKEEP(I8I2ILOAD);  &OPKEEP(I8I1ILOAD);  &OPKEEP(I8I4ILOAD);
  &OPKEEP(I5I5ILOAD);  &OPKEEP(I5I4ILOAD);  &OPKEEP(I5I2ILOAD);  &OPKEEP(I5I1ILOAD); &OPKEEP(I5I8ILOAD);
  &OPKEEP(I4I4ILOAD);  &OPKEEP(I4I2ILOAD);  &OPKEEP(I4I1ILOAD);  &OPKEEP(I4I8ILOAD);  &OPKEEP(I4I5ILOAD);
  &OPKEEP(U8U8ILOAD);  &OPKEEP(U8U5ILOAD);  &OPKEEP(U8U2ILOAD);  &OPKEEP(U8U1ILOAD);  &OPKEEP(U8U4ILOAD);
  &OPKEEP(U5U5ILOAD);  &OPKEEP(U5U4ILOAD);  &OPKEEP(U5U2ILOAD);  &OPKEEP(U5U1ILOAD);  &OPKEEP(U5U8ILOAD);
  &OPKEEP(U4U4ILOAD);  &OPKEEP(U4U2ILOAD);  &OPKEEP(U4U1ILOAD);  &OPKEEP(U4U8ILOAD);  &OPKEEP(U4U5ILOAD);
  &OPKEEP(F4F4ILOAD);  &OPKEEP(F8F8ILOAD);  &OPKEEP(FQFQILOAD);
  &OPKEEP(C4C4ILOAD);  &OPKEEP(C8C8ILOAD);  &OPKEEP(CQCQILOAD);
  &OPKEEP(A4A4ILOAD);  &OPKEEP(A8A8ILOAD);  &OPKEEP(MMILOAD)
  &OPKEEP(I4BSILOAD);  &OPKEEP(I5BSILOAD);  &OPKEEP(I8BSILOAD);
  &OPKEEP(U4BSILOAD);  &OPKEEP(U5BSILOAD);  &OPKEEP(U8BSILOAD);
  &OPKEEP(F10F10ILOAD); &OPKEEP(F16F16ILOAD);
  &OPKEEP(C10C10ILOAD); &OPKEEP(C16C16ILOAD);
  &OPKEEP(BBILOAD);
  &OP("ILOAD",         "b,i,f,z,p,M",  "b,i,f,z,s,p,M,bs",  $EXP, $LOAD, $NK, 1, $MC, $MCLDST,
      $HAS_2TY, $HAS_OFFSET, $HAS_FIELD_ID);

  &OP("ILOADX",        "f",          "V",  $EXP, $LOAD, $NK, 2, $MC, $MCLDST,
      $HAS_2TY);

  &OP("SECONDPART",     "f",          "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("INTCONST",     "b,i,p",           "V",
      $EXP,        $LEAF, $NK, 0, $MC, $MCEXP,
      $HAS_VALUE);

#INTRINSIC_CALL can only have a limited range of return types
  &OPKEEP(I1INTRINSIC_CALL);  &OPKEEP(I2INTRINSIC_CALL);  &OPKEEP(I4INTRINSIC_CALL);  &OPKEEP(I5INTRINSIC_CALL);  &OPKEEP(I8INTRINSIC_CALL);
  &OPKEEP(U1INTRINSIC_CALL);  &OPKEEP(U2INTRINSIC_CALL);  &OPKEEP(U4INTRINSIC_CALL);  &OPKEEP(U5INTRINSIC_CALL);  &OPKEEP(U8INTRINSIC_CALL);
  &OPKEEP(I4I4INTRINSIC_CALL); &OPKEEP(I8I8INTRINSIC_CALL); &OPKEEP(U4U4INTRINSIC_CALL); &OPKEEP(U8U8INTRINSIC_CALL);
  &OPKEEP(F4INTRINSIC_CALL);  &OPKEEP(F8INTRINSIC_CALL);  &OPKEEP(FQINTRINSIC_CALL);
  &OPKEEP(C4INTRINSIC_CALL);  &OPKEEP(C8INTRINSIC_CALL);  &OPKEEP(VINTRINSIC_CALL);
  &OPKEEP(F4F4INTRINSIC_CALL); &OPKEEP(F4F8INTRINSIC_CALL); &OPKEEP(F8F4INTRINSIC_CALL); &OPKEEP(F8F8INTRINSIC_CALL);
  &OPKEEP(A4INTRINSIC_CALL); &OPKEEP(A8INTRINSIC_CALL); &OPKEEP(MINTRINSIC_CALL);
  &OPKEEP(F10INTRINSIC_CALL); &OPKEEP(F16INTRINSIC_CALL);
  &OPKEEP(CQINTRINSIC_CALL);
  &OPKEEP(C10INTRINSIC_CALL); &OPKEEP(C16INTRINSIC_CALL);
  &OP("INTRINSIC_CALL","s,i,f,z,V,p,M", "i,F4,F8,V,p,M",  $STMT, $CALL, $EBB,
      $MC, $MCCALL, $HAS_NEXT_PREV, $HAS_INUMBER, $HAS_FLAGS);

  &OP("INTRINSIC_OP", "i,f,z,b,p,s,M",  "V",  $EXP, $MC, $MCEXP,
      $HAS_FLAGS, $HAS_INUMBER);

  &OP("IO",           "V",          "V",  $STMT, $EBB, $MC, $MCSTMT,
      $HAS_NEXT_PREV, $HAS_FLAGS, $HAS_INUMBER);

  &OP("IO_ITEM",      "V",          "V",  $EXP, $HAS_INUMBER, $MC, $MCEXP,
	$HAS_1TY);

  &OP("ISTBITS",      "V",          "s,I4,U4,I8,U8",  $STMT, $STORE, $NK, 2,
      $MC, $MCLDST, $HAS_NEXT_PREV, $HAS_OFFSET, $HAS_1TY);

  &OP("ISTORE",        "V",    "b,s,i,f,z,M,p,bs",  $STMT, $STORE, $NK, 2,
      $MC, $MCLDST, $HAS_NEXT_PREV, $HAS_OFFSET, $HAS_1TY, $HAS_FIELD_ID);

  &OP("ISTOREX",       "V",          "f",  $STMT, $STORE, $NK, 3,
      $MC, $MCLDST, $HAS_NEXT_PREV, $HAS_1TY);

# LABEL has 0 or 1 kids, but treat as variable kids so filled in dynamically
  &OP("LABEL",        "V",          "V",  $STMT, $NSCF,
      $MC, $MCSTMT, $HAS_NEXT_PREV, $HAS_LBL_NUM, $HAS_FLAGS, $NE);

  &OP("LAND",         "b",          "V",  $EXP, $NK, 2, $MC, $MCEXP, $BOOL);

  &OP("LDA",          "p",           "V",
      $EXP,        $LEAF, $NK, 0, $MC, $MCEXP,
      $HAS_SYM, $HAS_OFFSET, $HAS_1TY, $HAS_FIELD_ID);

  &OP("LDBITS",       "i",          "s,I4,U4,I8,U8",
      $EXP, $LOAD, $LEAF, $NK, 0, $MC, $MCLDST,
      $HAS_SYM, $HAS_OFFSET, $HAS_1TY);

#LDID can only have a limited range of return types
  &OPKEEP(I8I8LDID);  &OPKEEP(I8I5LDID);  &OPKEEP(I8I2LDID);  &OPKEEP(I8I1LDID);  &OPKEEP(I8I4LDID);
  &OPKEEP(I5I5LDID);  &OPKEEP(I5I4LDID);  &OPKEEP(I5I2LDID);  &OPKEEP(I5I1LDID); &OPKEEP(I5I8LDID);
  &OPKEEP(I4I4LDID);  &OPKEEP(I4I2LDID);  &OPKEEP(I4I1LDID);  &OPKEEP(I4I8LDID); &OPKEEP(I4I5LDID);
  &OPKEEP(U8U8LDID);  &OPKEEP(U8U5LDID);  &OPKEEP(U8U2LDID);  &OPKEEP(U8U1LDID);  &OPKEEP(U8U4LDID);
  &OPKEEP(U5U5LDID);  &OPKEEP(U5U4LDID);  &OPKEEP(U5U2LDID);  &OPKEEP(U5U1LDID);  &OPKEEP(U5U8LDID);
  &OPKEEP(U4U4LDID);  &OPKEEP(U4U2LDID);  &OPKEEP(U4U1LDID);  &OPKEEP(U4U8LDID);  &OPKEEP(U4U5LDID);
  &OPKEEP(F4F4LDID);  &OPKEEP(F8F8LDID);  &OPKEEP(FQFQLDID);
  &OPKEEP(C4C4LDID);  &OPKEEP(C8C8LDID);  &OPKEEP(CQCQLDID);
  &OPKEEP(A4A4LDID);  &OPKEEP(A8A8LDID);  &OPKEEP(MMLDID);
  &OPKEEP(I4BSLDID);  &OPKEEP(I5BSLDID);  &OPKEEP(I8BSLDID);
  &OPKEEP(U4BSLDID);  &OPKEEP(U5BSLDID);  &OPKEEP(U8BSLDID);
  &OPKEEP(F10F10LDID); &OPKEEP(F16F16LDID);
  &OPKEEP(C10C10LDID); &OPKEEP(C16C16LDID);
  &OPKEEP(BBLDID);
  &OP("LDID",         "b,i,f,z,p,M",       "b,i,f,z,s,p,M,bs",
      $EXP, $LOAD, $LEAF, $NK, 0, $MC, $MCLDST,
      $HAS_SYM, $HAS_OFFSET, $HAS_1TY, $HAS_FIELD_ID);

  &OP("LE",           "b,I4,U4,I8,U8",          "i,f,p",
      $EXP, $CMP, $NK, 2, $MC, $MCEXP, $BOOL);

  &OP("LIOR",         "b",          "V",  $EXP, $NK, 2, $MC, $MCEXP, $BOOL);

  &OP("LNOT",         "b",          "V",  $EXP, $NK, 1, $MC, $MCEXP, $BOOL);

# LOOP_INFO has 0-2 kids
  &OP("LOOP_INFO",	"V",	"V",	$EXP, $HAS_2OFFSETS,
      $HAS_FLAGS, $MC, $MCEXP);

  &OP("LOWPART",      "i",          "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("LSHR",         "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("LT",           "b,I4,U4,I8,U8",          "i,f,p",
      $EXP, $CMP, $NK, 2, $MC, $MCEXP, $BOOL);

  &OP("MADD",         "i,f",        "V",  $EXP, $NK, 3, $MC, $MCEXP);

  &OP("MAX",          "i,f,p",      "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("MAXPART",      "i,f",        "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("MIN",          "i,f,p",      "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("MINMAX",       "i,f,p",      "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("MINPART",      "i,f",        "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("MLOAD",        "M",          "V",  $EXP, $LOAD, $NK, 2, $MC, $MCLDST,
      $HAS_1TY, $HAS_OFFSET, $HAS_FIELD_ID);

  &OP("MOD",          "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("MPY",          "i,f,z,p",      "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("MSTORE",	      "V",          "V",  $STMT, $STORE, $NK, 3,
      $MC, $MCLDST, $HAS_NEXT_PREV, $HAS_OFFSET, $HAS_1TY, $HAS_FIELD_ID);

  &OP("MSUB",         "f",          "V",  $EXP, $NK, 3, $MC, $MCEXP);

  &OPIGN("I4BNE");   &OPIGN("I8BNE");   &OPIGN("U4BNE");   &OPIGN("U8BNE");

  &OP("NE",           "b,I4,I8,U4,U8",          "b,i,f,z,p",
      $EXP, $CMP, $NK, 2, $MC, $MCEXP, $BOOL);

  &OP("NEG",          "i,f,z,p",      "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("NMADD",        "f",          "V",  $EXP, $NK, 3, $MC, $MCEXP);

  &OP("NMSUB",        "f",          "V",  $EXP, $NK, 3, $MC, $MCEXP);

  &OP("OPTPARM",       "i,f,z",	      "V",  $EXP, $NK, 1, $MC, $MCEXP, $NE);

  &OP("OPT_CHI",       "V",	      "V", $STMT, $MC, $MCSTMT, $HAS_NEXT_PREV);

  &OP("OPT_RESERVE2",  "V",           "V", $STMT, $MC, $MCSTMT, $NE);

  &OP("PAREN",        "f,z",        "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("PARM",       "i,f,M,z,V,p",   "V",  $EXP, $NK, 1, $MC, $MCEXP, $NE,
	$HAS_1TY, $HAS_FLAGS);

#PICCALL can only have a limited range of return types
  &OPKEEP(I1PICCALL);  &OPKEEP(I2PICCALL);  &OPKEEP(I4PICCALL);  &OPKEEP(I5PICCALL);  &OPKEEP(I8PICCALL);
  &OPKEEP(U1PICCALL);  &OPKEEP(U2PICCALL);  &OPKEEP(U4PICCALL);  &OPKEEP(U5PICCALL);  &OPKEEP(U8PICCALL);
  &OPKEEP(I4I4PICCALL); &OPKEEP(I8I8PICCALL); &OPKEEP(U4U4PICCALL); &OPKEEP(U8U8PICCALL);
  &OPKEEP(F4PICCALL);  &OPKEEP(F8PICCALL);  &OPKEEP(FQPICCALL);
  &OPKEEP(C4PICCALL);  &OPKEEP(C8PICCALL);  &OPKEEP(VPICCALL);
  &OPKEEP(F4F4PICCALL); &OPKEEP(F4F8PICCALL); &OPKEEP(F8F4PICCALL); &OPKEEP(F8F8PICCALL);
  &OPKEEP(A4PICCALL); &OPKEEP(A8PICCALL);
  &OPKEEP(F10PICCALL); &OPKEEP(F16PICCALL);
  &OP("PICCALL",        "s,i,f,z,V,p",  "i,F4,F8,V,p",  $STMT, $CALL, $EBB,
      $MC, $MCCALL, $HAS_NEXT_PREV, $HAS_SYM, $HAS_FLAGS);

  &OP("PRAGMA",       "V",          "V",  $STMT, $LEAF, $NK, 0, $MC, $MCPR,
      $HAS_NEXT_PREV, $HAS_VALUE, $HAS_OFFSET, $HAS_SYM, $NE); 

  &OP("PREFETCH",     "V",          "V",  $STMT, $NK, 1, $MC, $MCSTMT,
      $HAS_NEXT_PREV, $HAS_FLAGS, $HAS_OFFSET, $PREF);

  &OP("PREFETCHX",     "V",          "V",  $STMT, $NK, 2, $MC, $MCSTMT,
      $HAS_NEXT_PREV, $HAS_FLAGS, $HAS_OFFSET, $PREF);

  &OP("RCOMMA",        "i,f,z,p,M",   "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("FIRSTPART",     "f",          "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("RECIP",        "f,z",        "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("REGION",       "V",          "V",  $SCF, $NK, 3, $MC, $MCHDR,
      $HAS_NEXT_PREV, $HAS_EREG_SUPP);

  &OP("REGION_EXIT",  "V",          "V",  $STMT, $LEAF, $NSCF, $EBB,
      $NK, 0, $MC, $MCSTMT, $HAS_NEXT_PREV, $HAS_LBL_NUM);

  &OP("REM",          "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("RETURN",       "V",          "V",  $STMT, $NSCF, $EBB,
      $NK, 0, $MC, $MCSTMT, $HAS_NEXT_PREV);

  &OP("RETURN_VAL",   "s,i,f,z,p,M",  "V", $STMT, $NSCF, $EBB,
      $NK, 1, $MC, $MCSTMT, $HAS_NEXT_PREV);

  &OP("RND",          "i",	    "f",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("RSQRT",        "f,z",        "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("SELECT",       "i,f,z,b,p",  "B,V",  $EXP, $NK, 3, $MC, $MCEXP);

  &OP("SHL",          "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("SQRT",         "f,z",        "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("STBITS",         "V",          "s,I4,U4,I8,U8", $STMT, $STORE, $NK, 1,
      $MC, $MCLDST, $HAS_NEXT_PREV, $HAS_SYM, $HAS_OFFSET, $HAS_1TY);

  &OP("STID",         "V",          "b,s,i,f,z,M,p,bs", $STMT, $STORE, $NK, 1,
      $MC, $MCLDST, $HAS_NEXT_PREV, $HAS_SYM, $HAS_OFFSET, $HAS_1TY, $HAS_FIELD_ID);

  &OP("SUB",          "i,f,z,p",      "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("SWITCH",       "V",          "V",  $STMT, $NSCF, $MC, $MCSCF, $EBB,
      $HAS_NEXT_PREV, $HAS_NE, $HAS_LAST_LABEL);

  &OP("TAS",          "s,i,f,z,p",    "V",  $EXP, $NK, 1, $MC, $MCEXP,
      $HAS_1TY);

  &OP("TRAP",		"V",	"V",	$STMT, $HAS_OFFSET, $NK, 0, 
	$HAS_NEXT_PREV, $MC, $MCSTMT);

  &OP("TRIPLET",	"i",	"V",	$EXP, $NK, 3, $MC, $MCEXP);

  &OP("TRUEBR",       "V",          "V",  $STMT, $NSCF, $EBB,
      $NK, 1, $MC, $MCSTMT, $HAS_NEXT_PREV, $HAS_LBL_NUM);

  &OP("TRUNC",        "i",	    "f",  $EXP, $NK, 1, $MC, $MCEXP);

#  &OP("VFCALL",        "s,i,f,z,V,p",  "i,F4,F8,V,p",  $STMT, $CALL, $EBB,
#      $MC, $MCCALL, $HAS_NEXT_PREV, $HAS_1TY, $HAS_FLAGS);

  &OPIGN("VFCALL");

  &OP("VFCALL",        "V",  "V",  $STMT, $CALL, $EBB,
      $MC, $MCCALL, $HAS_NEXT_PREV, $HAS_1TY, $HAS_FLAGS);

  &OP("WHERE",		"V",	"V",	$SCF, $NK, 3, $MC, $MCSCF, $HAS_NEXT_PREV);

  &OP("WHILE_DO",     "V",          "V",  $SCF, $NK, 2, $MC, $MCSCF,
      $HAS_NEXT_PREV);

  &OP("XGOTO",     "V",          "V",  $STMT, $NSCF, $NK, 2, $MC, $MCSCF, $EBB,
      $HAS_NEXT_PREV, $HAS_NE, $HAS_SYM);

  &OP("XMPY",          "i",          "V",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("XPRAGMA",      "V",          "V",  $STMT, $NK, 1, $MC, $MCPR,
      $HAS_NEXT_PREV, $HAS_OFFSET, $HAS_SYM, $NE); 

  &OP("AFFIRM",   "V", "V",  $STMT, $NK, 1, $MC, $MCSTMT, $HAS_NEXT_PREV);

  &OP("ALLOCA",   "p",  "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("DEALLOCA", "V",      "V",  $STMT, $MC, $MCSTMT, $HAS_NEXT_PREV);

  &OP("LDMA",     "p",   "V",  $EXP, $NK, 0, $MC, $MCEXP, $HAS_SYM, 
       $HAS_OFFSET, $LEAF, $HAS_1TY, $HAS_FIELD_ID);

  &OP("ASM_STMT", "V",          "V",  $STMT, $MC, $MCSTMT, 
            $HAS_NEXT_PREV, $HAS_SYM, $HAS_FLAGS);

  &OP("ASM_EXPR", "i,p,f,z",  "V",  $EXP, $MC, $MCEXP, $HAS_SYM, $HAS_FLAGS);

  &OP("ASM_INPUT", "V",   "V",  $EXP, $NK, 1, $MC, $MCEXP, $HAS_SYM);

  &OPIGN("U4U8RROTATE"); &OPIGN("U8U1RROTATE");
  &OPIGN("U8U2RROTATE"); &OPIGN("U8U4RROTATE");

  &OP("RROTATE",   "U4,U8",  "U1,U2,U4,U8",  $EXP, $NK, 2, $MC, $MCEXP);

  &OP("LDA_LABEL", "p",  "V",  $EXP, $NK, 0, $MC, $MCEXP, $LEAF, $HAS_1TY, $HAS_LBL_NUM);

  &OP("GOTO_OUTER_BLOCK",  "V",  "V",  $STMT, $NK, 0, $MC, $MCSTMT, $NSCF, $EBB, $HAS_NEXT_PREV, $LEAF, $HAS_LBL_NUM);

  &OP("EXTRACT_BITS",  "I4,I8,U4,U8",  "V",  $EXP, $NK, 1, $MC, $MCEXP);

  &OP("COMPOSE_BITS",  "I4,I8,U4,U8",  "V",  $EXP, $NK, 2, $MC, $MCEXP);

#
# Generate the statically initialized table of functions called
# by the simplifier for each generic operator. This must be done after all
# opcodes are defined. It is done in this file so that when new opcodes
# and operators are added, the simplifier tables are appropriately updated
#
  &SIMP_OP("CVT","simp_cvt");
  &SIMP_OP("TAS","simp_cvt");
  &SIMP_OP("TRUNC","simp_cvt");
  &SIMP_OP("NEG","simp_neg");
  &SIMP_OP("ABS","simp_abs");
  &SIMP_OP("SQRT","simp_recip");
  &SIMP_OP("FIRSTPART","simp_cvt");
  &SIMP_OP("SECONDPART","simp_cvt");
  &SIMP_OP("BNOT","simp_not");
  &SIMP_OP("LNOT","simp_not");
  &SIMP_OP("ADD","simp_add_sub");
  &SIMP_OP("SUB","simp_add_sub");
  &SIMP_OP("MPY","simp_times");
  &SIMP_OP("DIV","simp_div");
  &SIMP_OP("MOD","simp_mod_rem");
  &SIMP_OP("REM","simp_mod_rem");
  &SIMP_OP("MAX","simp_min_max");
  &SIMP_OP("MIN","simp_min_max");
  &SIMP_OP("CAND","simp_cand");
  &SIMP_OP("CIOR","simp_cior");
  &SIMP_OP("BAND","simp_band");
  &SIMP_OP("BIOR","simp_bior");
  &SIMP_OP("BNOR","simp_bnor");
  &SIMP_OP("BXOR","simp_bxor");
  &SIMP_OP("LAND","simp_land");
  &SIMP_OP("LIOR","simp_lior");
  &SIMP_OP("SHL","simp_shift");
  &SIMP_OP("ASHR","simp_shift");
  &SIMP_OP("LSHR","simp_shift");
  &SIMP_OP("RECIP","simp_recip");
  &SIMP_OP("RSQRT","simp_recip");
  &SIMP_OP("EQ","simp_eq_neq");
  &SIMP_OP("NE","simp_eq_neq");
  &SIMP_OP("LT","simp_relop");
  &SIMP_OP("LE","simp_relop");
  &SIMP_OP("GT","simp_relop");
  &SIMP_OP("GE","simp_relop");

  &END_OP();

# end of main program

}

###########################################################################
###########################################################################
###########################################################################
###########################################################################
###
### PART II: The perl routines to implement these tables and generate C code.
###
###########################################################################
###########################################################################
###########################################################################
###########################################################################


sub OUTFILES {
  $#_ == 5 || die "OUTFILES: requires six arguments exactly";

  open(HFILET, ">" . $_[0]);
  open(HFILED, ">" . $_[1]);
  open(CFILET, ">" . $_[2]);
  open(SFILET, ">" . $_[3]);

  open(HFILE_MTYPES, ">" . $_[4]);
  open(CFILE_MTYPES, ">" . $_[5]);

  printf(HFILET "/* $_[0]: This file automatically generated. */\n\n");
  printf(HFILED "/* $_[1]: This file automatically generated. */\n\n");
  printf(CFILET "/* $_[2]: This file automatically generated. */\n\n");
  printf(SFILET "/* $_[3]: This file automatically generated. */\n\n");
  printf(HFILE_MTYPES "/* $_[4]: This file automatically generated. */\n\n");
  printf(CFILE_MTYPES "/* $_[5]: This file automatically generated. */\n\n");

  &copyright_notice(HFILET);
  &copyright_notice(HFILED);
  &copyright_notice(CFILET);
  &copyright_notice(SFILET);
  &copyright_notice(HFILE_MTYPES);

  # header stuff:
  printf(HFILE_MTYPES "#ifndef mtypes_INCLUDED\n");
  printf(HFILE_MTYPES "#define mtypes_INCLUDED\n");
  printf(HFILE_MTYPES "#ifdef __cplusplus\n");
  printf(HFILE_MTYPES "extern \"C\" {\n");
  printf(HFILE_MTYPES "#endif\n\n");

  printf(HFILE_MTYPES "#include \"config_targ.h\" \t\t /* for ALIGN */\n\n");

  # description comment:
  printf(HFILE_MTYPES "/* ==================================================================== \n");
  printf(HFILE_MTYPES " * ==================================================================== \n");
  printf(HFILE_MTYPES " * \n");
  printf(HFILE_MTYPES " * Module: mtypes.h \n");
#  printf(HFILE_MTYPES " * \$Revision$ \n");
#  printf(HFILE_MTYPES " * \$Date$ \n");
#  printf(HFILE_MTYPES " * \$Author$ \n");
#  printf(HFILE_MTYPES " * \$Source$ \n");
  printf(HFILE_MTYPES " * \n");
  printf(HFILE_MTYPES " * Revision history: \n");
  printf(HFILE_MTYPES " *  11-Oct-89 - Original Version \n");
  printf(HFILE_MTYPES " *  19-May-01 - File generated automatically \n");
  printf(HFILE_MTYPES " * \n");
  printf(HFILE_MTYPES " * Description: \n");
  printf(HFILE_MTYPES " * \n");
  printf(HFILE_MTYPES " * Define IDs for the types supported by the target machine.  Not all \n");
  printf(HFILE_MTYPES " * of the predefined types will be supported on a given machine. \n");
  printf(HFILE_MTYPES " * \n");
  printf(HFILE_MTYPES " * ==================================================================== \n");
  printf(HFILE_MTYPES " * ==================================================================== \n");
  printf(HFILE_MTYPES " */ \n\n");

  &copyright_notice(CFILE_MTYPES);

  printf("Automatically generating $_[0]\n");
  printf("Automatically generating $_[1]\n");
  printf("Automatically generating $_[2]\n");
  printf("Automatically generating $_[3]\n");
  printf("Automatically generating $_[4]\n");
  printf("Automatically generating $_[5]\n");
}

####################################################################
#                   MTYPE_CLASS description
####################################################################

sub BEGIN_TYPECLASS {
    $classcount = 0;
    $classname[$classcount] = "UNKNOWN";
    $baseclass{'UNKNOWN'} = 1;
}

sub NEW_TYPECLASS {
    $classcount++;
    $classname[$classcount] = $_[0];
    $baseclass{$_[0]} = 1;

#    print STDOUT "$classcount: $classname[$classcount]\n";
}

sub ABBREVCLASS {
    my($i);
    my($newclass) = $_[0];

    # sanity check: make sure that the abbrevtype components are basetypes.

    !defined($abbrevclass{$newclass}) || die "ABBREVCLASS: $newclass redefined";
    for ($i = 1; $i <= $#_; $i++) {
	my($class) = $_[$i];
	defined($baseclass{$class}) || die "ABBREVCLASS: $class is not a baseclass";
    }

    $abbrevclass{$newclass} = join(",", @_[1 .. $#_]);
}

sub END_TYPECLASS {
    my ($i);
    my($key);

    # includes for mtypes.cxx file:
    printf(CFILE_MTYPES "#include \"defs.h\" \n");
    printf(CFILE_MTYPES "#include \"mtypes.h\" \n\n");

    # emit MTYPE_CLASS stuff:
    printf(HFILE_MTYPES "/* Type_class_bits */ \n");

    printf(HFILE_MTYPES "#define %sUNKNOWN \t 0x00\n", $MTYPE_CLASS_PREFIX);
    for ($i = 1; $i <= $classcount; $i++) {
	printf(HFILE_MTYPES "#define %s%s \t 0x%02x\n", $MTYPE_CLASS_PREFIX, $classname[$i], (1 << ($i-1)));
    }

    # emit abbreviated classes:
    foreach $key (keys %abbrevclass) {
	my(@abbrev_str) = split(",", $abbrevclass{$key});
	my($abbrev_val);
	printf(HFILE_MTYPES "#define %s", $MTYPE_CLASS_PREFIX);
	printf(HFILE_MTYPES "%s_", $abbrev_str[0]);
	$abbrev_val = $MTYPE_CLASS_PREFIX . $abbrev_str[0];
	for ($i = 1; $i < $#abbrev_str; $i++) {
	    printf(HFILE_MTYPES "%s_", $abbrev_str[$i]);
	    $abbrev_val = join("|", $MTYPE_CLASS_PREFIX . $abbrev_str[$i], $abbrev_val);
	}
	printf(HFILE_MTYPES "%s \t", $abbrev_str[$#abbrev_str]);
	$abbrev_val = join("|", $MTYPE_CLASS_PREFIX . $abbrev_str[$#abbrev_str], $abbrev_val);
	printf(HFILE_MTYPES "(%s)\n", $abbrev_val);
    }
    printf(HFILE_MTYPES "\n");
}

####################################################################
#                    WHIRLTYPE description
####################################################################

sub BEGIN_WHIRLTYPE {
    undef %typeval;
    $type_count = 0;
}

####################################################################
#
#  Information about a WHIRL TYPE is specified as:
#
#    1. typename, eg. "B" for boolean
#    2. typeclass, eg. "INTEGER" for integral class
#    3. typedesc, eg. "32-bit integer", only used for emitting comments
#    4. typealias, eg. "STR" then define looks like define STRING STR
#
####################################################################
sub WHIRLTYPE {
    my($typename) = @_[0];
    my($typeclass) = @_[1];
    my($typedesc) = @_[2];
    my($typealias) = @_[3];
    my($typebitsize) = @_[4];
    my($typebytesize) = @_[5];
    my($typealign) = @_[6];
    my($typeorder) = @_[7];
    my($typecomplement) = @_[8];

    my($i);

    $basetype{$typename} = 1;
    $typeval{$typename} = ++$type_count;
    $mtype_id[$type_count] = $typename;
    # make typeclass string:
    if (defined($baseclass{$typeclass})) {
	$mtype_class[$type_count] = $typeclass;
    }
    else {
	# it must be an abbrev class
	my(@abbrev_str) = split(",", $abbrevclass{$typeclass});
	my($abbrev_val) = $abbrev_str[0];
	for ($i = 1; $i < $#abbrev_str; $i++) {
	    $abbrev_val = join("_", $abbrev_val, $abbrev_str[$i]);
	}
	$abbrev_val = join("_", $abbrev_val, $abbrev_str[$#abbrev_str]);
	$mtype_class[$type_count] = $abbrev_val;
    }

    $mtype_desc[$type_count] = $typedesc;
    if ($typealias ne "") {
	$mtype_alias[$type_count] = $typealias;
    }
    $mtype_bitsize[$type_count] = $typebitsize;
    $mtype_bytesize[$type_count] = $typebytesize;
    $mtype_align[$type_count] = $typealign;
    $mtype_order[$type_count] = $typeorder;
    $mtype_complement[$type_count] = $typecomplement;
}

sub ABBREVTYPE {
  my($i);

  $newtype = $_[$0];

  # sanity check: make sure that the abbrevtype components are basetypes.

  !defined($abbrevtype{$newtype}) || die "ABBREVTYPE: $newtype redefined";
  for ($i = 1; $i <= $#_; $i++) {
    my($type) = $_[$i];
    defined($basetype{$type}) || die "ABBREVTYPE: $type is not a basetype";
  }

  $abbrevtype{$newtype} = join(",", @_[1 .. $#_]);
}

sub WHIRLTYPE_NEXTALIGN {
    my($idx) = $typeval{$_[0]};
    $mtype_nextalign[$idx] = $_[1];
}

sub WHIRLTYPE_PREVALIGN {
    my($idx) = $typeval{$_[0]};
    $mtype_prevalign[$idx] = $_[1];
}

sub WHIRLTYPE_COMPLEXTOREAL {
    my($idx) = $typeval{$_[0]};
    $mtype_complex_to_real[$idx] = $_[1];
}

sub WHIRLTYPE_COMPARISON {
    my($idx) = $typeval{$_[0]};
    $mtype_comparison[$idx] = $_[1];
}


#
# generate the #defines in the .h for the type system, and generate
# a mapping to strings for the .c file.
#

sub END_WHIRLTYPE {
    my($i);
  my($key);
  my($tname);

  printf(HFILE_MTYPES "/* The predefined machine data types, present on many machines: */\n");

  printf(CFILE_MTYPES "TYPE_DESC Machine_Types[] = { \n");

  printf(HFILE_MTYPES "#define %sUNKNOWN\t %d\n", $MTYPE_PREFIX, 0);
  printf(CFILE_MTYPES "  { %sUNKNOWN, 0, 0, 0, TARG_NONE_ALIGN, 0, 0, 0, 0, 0, \"\",0,0, %sUNKNOWN }, \n", $MTYPE_PREFIX, $MTYPE_PREFIX);
  printf(HFILE_MTYPES "#define %sFIRST\t %d\n", $MTYPE_PREFIX, 1);

  my($cnt) = 1;
  for ($i = 1; $i <= $type_count; $i++) {
    my($tname) = $MTYPE_PREFIX . $mtype_id[$i];
    my($comment) = $mtype_desc[$i];
    if (defined($mtype_alias[$i])) {
      printf(HFILE_MTYPES "#define %s\t %s\n", $tname, $MTYPE_PREFIX . $mtype_alias[$i]);
    }
    else {
      printf(HFILE_MTYPES "#define %s\t %d\t", $tname, $cnt++);
      printf(HFILE_MTYPES "/* %s */\n", $comment);

      # print the descriptor table into the mtypes.cxx file:
      my($signed);
      my($float);
      my($sep);
      # is the type signed ?
      if ($mtype_class[$i] eq "INTEGER" ||
#	  $mtype_class[$i] eq "DOUBLE_INTEGER" ||
#	  $mtype_class[$i] eq "DOUBLE_FLOAT" ||
	  $mtype_class[$i] eq "FLOAT") {
	  $signed = 1;
      }
      else {
	  $signed = 0;
      }
      # is the type float ?
      if ($mtype_class[$i] eq "FLOAT" ||
#	  $mtype_class[$i] eq "DOUBLE_FLOAT" ||
	  $mtype_class[$i] eq "COMPLEX_FLOAT") {
	  $float = 1;
      }
      else {
	  $float = 0;
      }
      # is it the last one in the table ?
      if ($i == $type_count) {
	  $sep = "";
      }
      else {
	  $sep = ",";
      }
      # print the info:
      printf(CFILE_MTYPES "  { %s, %d, %d, %d, %s, %d, %d, %d, %d, 0, \"%s\", %s%s, %d, %s%s }%s \n", $tname, $mtype_bitsize[$i], $mtype_bytesize[$i], $mtype_bytesize[$i], $mtype_align[$i], $mtype_bytesize[$i], $mtype_bytesize[$i], $signed, $float, $mtype_id[$i], $MTYPE_CLASS_PREFIX, $mtype_class[$i], $mtype_order[$i], $MTYPE_PREFIX, $mtype_complement[$i], $sep);
    }
  }

  printf(HFILE_MTYPES "\n");
  printf(HFILE_MTYPES "/* must define MTYPE_LAST as the index of the last one defined. */\n");
  printf(HFILE_MTYPES "#define %s\t %d\n", $MTYPE_PREFIX . "LAST", $cnt-1);
  printf(HFILE_MTYPES "\n");

  printf(CFILE_MTYPES "}; \n\n");


  # define the MTYPE type:
  printf(HFILE_MTYPES "/* Define the type: */ \n");
  printf(HFILE_MTYPES "typedef UINT8	%s; \n", $MTYPE_TYPE);
  printf(HFILE_MTYPES "typedef mUINT8	m%s; \n\n", $MTYPE_TYPE);

#######################################################################

    printf(HFILET "#ifndef mtypes_INCLUDED\n");
    printf(HFILET "#include \"mtypes.h\"\n");
    printf(HFILET "#endif\n\n");
}

####################################################################
#                       MTYPE DESCRIPTOR
####################################################################

sub BEGIN_WHIRLDESC {
    $whirlcount = 0;
}

sub WHIRLDESC {
    my($field) = $_[0];
    my($fieldtype) = $_[1];
    my($fielddesc) = $_[2];

    $whirlfield[$whirlcount] = $field;
    $whirltype[$whirlcount] = $fieldtype;
    $whirldesc[$whirlcount] = $fielddesc;
    $whirlcount++;
}

sub END_WHIRLDESC {
    my ($i);

    printf(HFILE_MTYPES "/* Define the type descriptor: */ \n");
    printf(HFILE_MTYPES "typedef struct type_desc { \n");

    for ($i = 0; $i < $whirlcount; $i++) {
	printf(HFILE_MTYPES "  %s\t %s; \t /* %s */\n", $whirltype[$i], $whirlfield[$i], $whirldesc[$i]);
    }

    printf(HFILE_MTYPES "} TYPE_DESC; \n\n");

    printf(HFILE_MTYPES "/* Types which are not supported in memory should have memory sizes \n");
    printf(HFILE_MTYPES " * and alignment values of 0. */ \n");
    printf(HFILE_MTYPES "\n");

    # declare MTYPE description table and accesses:
    printf(HFILE_MTYPES "/* Declare the type descriptor table: */ \n");
    printf(HFILE_MTYPES "extern TYPE_DESC Machine_Types[]; \n\n");

    printf(HFILE_MTYPES "/* Define the access functions: */ \n");
    for ($i = 0; $i < $whirlcount; $i++) {
	#
	# don't do alignment here, it's target-specific now
	#
#	if ($whirlfield[$i] ne "alignment") {
	    printf(HFILE_MTYPES "#define %s%s(n)\t (Machine_Types[n].%s)\n", $MTYPE_PREFIX, $whirlfield[$i], $whirlfield[$i]);
#	}
    }

    # HACK: some additional defines found in the Pro64, remove in the
    #       future !
    printf(HFILE_MTYPES "#define MTYPE_signed(n)	MTYPE_signed_type(n) \n");
    printf(HFILE_MTYPES "#define MTYPE_float(n)	        MTYPE_float_type(n) \n");
    printf(HFILE_MTYPES "#define MTYPE_size_reg(n)	MTYPE_bit_size(n) \n");
    printf(HFILE_MTYPES "#define MTYPE_size_min(n)	MTYPE_bit_size(n) \n");
    printf(HFILE_MTYPES "#define MTYPE_size_best(n)	MTYPE_bit_size(n) \n");
    printf(HFILE_MTYPES "#define MTYPE_align_min(n)	MTYPE_alignment(n) \n");
    printf(HFILE_MTYPES "#define MTYPE_align_req(n)	MTYPE_alignment(n) \n");
    printf(HFILE_MTYPES "#define MTYPE_align_best(n)	MTYPE_alignment(n) \n");
    printf(HFILE_MTYPES "\n");

    # Following should really be cleaned up using WHIRL CLASSes
    printf(HFILE_MTYPES "/* define register classes */ \n");
    printf(HFILE_MTYPES "#define MTYPE_is_integral(n)	(MTYPE_type_class(n) & MTYPE_CLASS_INTEGER) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_signed(n)	(MTYPE_type_class(n)==MTYPE_CLASS_INTEGER) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_unsigned(n)	(MTYPE_type_class(n)==MTYPE_CLASS_UNSIGNED_INTEGER) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_float(n)	(MTYPE_type_class(n) & MTYPE_CLASS_FLOAT) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_complex(n)	(MTYPE_type_class(n) & MTYPE_CLASS_COMPLEX) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_str(n)		(MTYPE_type_class(n)==MTYPE_STR) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_m(n)		((n)==MTYPE_M) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_void(n)	((n)==MTYPE_V) \n\n");

    printf(HFILE_MTYPES "#define MTYPE_is_quad(n)	((n)==MTYPE_FQ || (n)==MTYPE_CQ) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_pointer(n)	((n)==Pointer_type || (n)==Pointer_type2) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_boolean(n)	((n)==Boolean_type || (n)==Boolean_type2) \n\n");

    printf(HFILE_MTYPES "/* This is to distinguish INTEGER, POINTER and BOOLEAN classes */ \n");
    printf(HFILE_MTYPES "#define MTYPE_is_class_boolean(n) (MTYPE_type_class(n) & MTYPE_CLASS_BOOLEAN) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_class_pointer(n) (MTYPE_type_class(n) & MTYPE_CLASS_POINTER) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_class_integer(n) ((MTYPE_type_class(n) & MTYPE_CLASS_INTEGER) && !(MTYPE_type_class(n) & MTYPE_CLASS_POINTER) && !(MTYPE_type_class(n) & MTYPE_CLASS_BOOLEAN)) \n\n");


#    printf(HFILE_MTYPES "#define MTYPE_is_longlong(n) ((MTYPE_type_class(n) & MTYPE_CLASS_INTEGER) && (MTYPE_type_class(n) & MTYPE_CLASS_DOUBLE))  \n");
#    printf(HFILE_MTYPES "#define MTYPE_is_double(n) ((MTYPE_type_class(n) & MTYPE_CLASS_FLOAT) && (MTYPE_type_class(n) & MTYPE_CLASS_DOUBLE)) \n\n");

    printf(HFILE_MTYPES "/* \n");
    printf(HFILE_MTYPES " * These MTYPEs are split into I4/U4/F4 if\n");
    printf(HFILE_MTYPES " * the flag Only_32_Bit_Ops is TRUE.\n");
    printf(HFILE_MTYPES " */ \n");
    printf(HFILE_MTYPES "#define MTYPE_is_longlong(n) (n == MTYPE_I8 || n == MTYPE_U8) \n");
    printf(HFILE_MTYPES "#define MTYPE_is_double(n)   (n == MTYPE_F8) \n");

    # TODO: understand this TypeMask business:

    printf(HFILE_MTYPES "/* Register size in bytes */ \n");
    printf(HFILE_MTYPES "#define	MTYPE_RegisterSize(n)	MTYPE_byte_size(n) \n\n");

    printf(HFILE_MTYPES "#define MTYPE_is_size_double(n)	(MTYPE_bit_size(n) == MTYPE_bit_size(MTYPE_I8)) \n\n");

    printf(HFILE_MTYPES "/* Define a mask of machine types, for use in register descriptors: */ \n");
    printf(HFILE_MTYPES "typedef UINT32 MTYPE_MASK; \n\n");

    printf(HFILE_MTYPES "/* Convert TYPE_ID to MTYPE_MASK: */ \n");
    printf(HFILE_MTYPES "#define Type_Mask(t)	( ((MTYPE_MASK) 1) << (t) ) \n\n");

    printf(HFILE_MTYPES "/* Operations on type masks: */ \n");
    printf(HFILE_MTYPES "#define TMASK_Element(m,k)	(((m) & Type_Mask(k))!=0) \n");
    printf(HFILE_MTYPES "#define TMASK_And(m1,m2)	((m1) & (m2)) \n");
    printf(HFILE_MTYPES "#define TMASK_Or(m1,m2)		((m1) | (m2)) \n");
    printf(HFILE_MTYPES "#define TMASK_Included(m1,m2)	(TMASK_And(m1,m2)==(m1)) \n\n");

    printf(HFILE_MTYPES "/* Define which types are available on the target: */ \n");
    printf(HFILE_MTYPES "extern MTYPE_MASK Machine_Types_Available; \n");
    printf(HFILE_MTYPES "#define MTYPE_Avail(k)	TMASK_Element(Machine_Types_Available,k) \n\n");

}

####################################################################
#                       FUNCTIONAL INTERFACE
####################################################################

sub BEGIN_WHIRLFUNC {
    $funccount = 0;

    # describe the functional interface in the mtypes.h file:

    printf(HFILE_MTYPES "/* ======================================================================= \n");
    printf(HFILE_MTYPES " * \n");
    printf(HFILE_MTYPES " *  Exported Functions \n");
    printf(HFILE_MTYPES " * \n");
    printf(HFILE_MTYPES " *    char * Mtype_Name ( TYPE_ID b) \n");
    printf(HFILE_MTYPES " * \n");
    printf(HFILE_MTYPES " *	Routine to provide printable type name. \n");
    printf(HFILE_MTYPES " * \n");
    printf(HFILE_MTYPES " * \n");
    printf(HFILE_MTYPES " *    TYPE_ID Mtype_AlignmentClass(INT32 align, mUINT8 class) \n");
    printf(HFILE_MTYPES " * \n");
    printf(HFILE_MTYPES " *	Routine to return a type that matches exact byte alignment \n");
    printf(HFILE_MTYPES " *	and class \n");
    printf(HFILE_MTYPES " * \n");
    printf(HFILE_MTYPES " * \n");
    printf(HFILE_MTYPES " *    TYPE_ID Mtype_TransferSign(TYPE_ID type) \n");
    printf(HFILE_MTYPES " * \n");
    printf(HFILE_MTYPES " *	Routine to return the unsigned type corresponding to type \n");
    printf(HFILE_MTYPES " * \n");
    printf(HFILE_MTYPES "/* ======================================================================= \n");
    printf(HFILE_MTYPES " */ \n\n");

}

sub END_WHIRLFUNC {
    my($i);

    # Following is the functional interface. It is reproduced exactly
    # as it is in the Pro64. Some of these functions don't belong here.
    # This all should be cleaned up ! 
    # TODO: ALL OF THIS SHOULD BE TABLES !!

    # some tables in the mtypes.cxx file:

    printf(CFILE_MTYPES "static %s Machine_Next_Alignment[] = { \n", $MTYPE_TYPE);
    printf(CFILE_MTYPES "  /* %sUNKNOWN */ \t %sUNKNOWN", $MTYPE_PREFIX, $MTYPE_PREFIX);
    for ($i = 1; $i < $type_count; $i++) {
	if (!defined($mtype_alias[$i])) {
	    my($tname) = $MTYPE_PREFIX . $mtype_id[$i];
	    my($nname);
	    if (defined($mtype_nextalign[$i])) {
		$nname = $MTYPE_PREFIX . $mtype_nextalign[$i];
	    }
	    else {
		$nname = $MTYPE_PREFIX . "UNKNOWN";
	    }
	    printf(CFILE_MTYPES ",\n  /* %s */ \t %s", $tname, $nname);
	}
    }
    printf(CFILE_MTYPES "\n}; \n\n");

    printf(CFILE_MTYPES "static %s Machine_Prev_Alignment[] = { \n", $MTYPE_TYPE);
    printf(CFILE_MTYPES "  /* %sUNKNOWN */ \t %sUNKNOWN", $MTYPE_PREFIX, $MTYPE_PREFIX);
    for ($i = 1; $i < $type_count; $i++) {
	if (!defined($mtype_alias[$i])) {
	    my($tname) = $MTYPE_PREFIX . $mtype_id[$i];
	    my($nname);
	    if (defined($mtype_prevalign[$i])) {
		$nname = $MTYPE_PREFIX . $mtype_prevalign[$i];
	    }
	    else {
		$nname = $MTYPE_PREFIX . "UNKNOWN";
	    }
	    printf(CFILE_MTYPES ",\n  /* %s */ \t %s", $tname, $nname);
	}
    }
    printf(CFILE_MTYPES "\n}; \n\n");

    # some mask stuff ??
    printf(CFILE_MTYPES "%sMASK Machine_Types_Available = 0x1fdffe; \n\n", $MTYPE_PREFIX);

    ################################################
    ##    Mtype_Name ()
    ################################################

    printf(HFILE_MTYPES "extern char * Mtype_Name( %s ); \n", $MTYPE_TYPE);

    printf(CFILE_MTYPES "/* ==================================================================== \n");
    printf(CFILE_MTYPES " * Mtype_Name \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Return a string containing a printable name for an MTYPE. \n");
    printf(CFILE_MTYPES " * ==================================================================== \n");
    printf(CFILE_MTYPES " */ \n");

    printf(CFILE_MTYPES "char * \n");
    printf(CFILE_MTYPES "Mtype_Name (%s b) \n", $MTYPE_TYPE);
    printf(CFILE_MTYPES "{ \n");
    printf(CFILE_MTYPES "  static char buf[32]; \n\n");

    printf(CFILE_MTYPES "  if ( b > 0 && b <= %sLAST ) { \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    return %sname(b); \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "  } else { \n");
    printf(CFILE_MTYPES "    sprintf (buf, \"BETYPE_%s\", b); \n", "%1d");
    printf(CFILE_MTYPES "    return buf; \n");
    printf(CFILE_MTYPES "  } \n");
    printf(CFILE_MTYPES "} \n\n");

    ################################################
    ##    Mtype_AlignmentClass
    ################################################

    printf(HFILE_MTYPES "extern %s Mtype_AlignmentClass( INT32 , mUINT8 ); \n", $MTYPE_TYPE);

    printf(CFILE_MTYPES "/* ==================================================================== \n");
    printf(CFILE_MTYPES " * Mtype_AlignmentClass \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Return MTYPE corresponding to alignment(in bytes) and class \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " *	TODO -- this really belongs a matrix (align X class) \n");
    printf(CFILE_MTYPES " * ==================================================================== \n");
    printf(CFILE_MTYPES " */ \n");
    printf(CFILE_MTYPES "%s  \n", $MTYPE_TYPE);
    printf(CFILE_MTYPES "Mtype_AlignmentClass(INT32 align, mUINT8 type_class) \n");
    printf(CFILE_MTYPES "{ \n");
    printf(CFILE_MTYPES "  INT32	i; \n\n");

    printf(CFILE_MTYPES "  for(i = 0; i < %sLAST; i++) \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "  { \n");
    printf(CFILE_MTYPES "    if ((%stype_class(i) == type_class) && \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "	(%salign_min(i) == align)) \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "      return %sid(i); \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "  } \n\n");

    printf(CFILE_MTYPES "  return %sUNKNOWN;  \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "} \n\n");

    ################################################
    ##    TYPE_ID Mtype_Promote_to_A4A8(TYPE_ID x)
    ################################################

    printf(HFILE_MTYPES "extern %s Mtype_Promote_to_A4A8( %s ); \n", $MTYPE_TYPE, $MTYPE_TYPE);

    printf(CFILE_MTYPES "/* ==================================================================== \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Mtype_Promote_to_A4A8 \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Convert I4 or U4 to A4, and I8 or U8 to A8; otherwise, do nothing. \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * ==================================================================== \n");
    printf(CFILE_MTYPES " */ \n");
    printf(CFILE_MTYPES "%s Mtype_Promote_to_A4A8(%s x) \n", $MTYPE_TYPE, $MTYPE_TYPE);
    printf(CFILE_MTYPES "{ \n");
    printf(CFILE_MTYPES "  if (! %sis_integral(x)) \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    return x; \n");
    printf(CFILE_MTYPES "  if (%sbyte_size(x) < 4) \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    return x; \n");
    printf(CFILE_MTYPES "  if (%sbyte_size(x) == 4) \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    return %sA4; \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "  return %sA8; \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "} \n\n");

    ################################################
    ##    TYPE_ID Mtype_TransferSign( TYPE_ID, TYPE_ID )
    ################################################

    printf(HFILE_MTYPES "extern %s Mtype_TransferSign( %s, %s ); \n", $MTYPE_TYPE, $MTYPE_TYPE, $MTYPE_TYPE);

    printf(CFILE_MTYPES "/* ==================================================================== \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Mtype_TransferSign \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Return signed/unsigned version of y depending on sign of x. \n");
    printf(CFILE_MTYPES " * If either type is A4 or A8, return the A[48] of y. \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * ==================================================================== \n");
    printf(CFILE_MTYPES " */ \n");
    printf(CFILE_MTYPES "%s Mtype_TransferSign(%s x, %s y) \n", $MTYPE_TYPE, $MTYPE_TYPE, $MTYPE_TYPE);
    printf(CFILE_MTYPES "{ \n");
    printf(CFILE_MTYPES "  if (y == %sA4 || y == %sA8) \n", $MTYPE_PREFIX, $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    return y; \n");
    printf(CFILE_MTYPES "  if (x == %sA4 || x == %sA8) \n", $MTYPE_PREFIX, $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    return Mtype_Promote_to_A4A8(y); \n");
    printf(CFILE_MTYPES "  if (%ssigned(x) ^ %ssigned(y)) { \n", $MTYPE_PREFIX, $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    return %scomplement(y); \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "  } \n");
    printf(CFILE_MTYPES "  return y; \n");
    printf(CFILE_MTYPES "} \n\n");

    ################################################
    ##    TYPE_ID Mtype_TransferSize(TYPE_ID x, TYPE_ID y)
    ################################################

    printf(HFILE_MTYPES "extern %s Mtype_TransferSize( %s, %s ); \n", $MTYPE_TYPE, $MTYPE_TYPE, $MTYPE_TYPE);

    printf(CFILE_MTYPES "/* ==================================================================== \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Mtype_TransferSize \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Return the mtype version of y taking on the size of x. \n");
    printf(CFILE_MTYPES " * If y is A4 or A8 and x's size is smaller than 4 bytes, return U1 or U2. \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * ==================================================================== \n");
    printf(CFILE_MTYPES " */ \n");
    printf(CFILE_MTYPES "%s Mtype_TransferSize(%s x, %s y) \n", $MTYPE_TYPE, $MTYPE_TYPE, $MTYPE_TYPE);
    printf(CFILE_MTYPES "{ \n");
    printf(CFILE_MTYPES "  if (y == %sA4 || y == %sA8) { \n", $MTYPE_PREFIX, $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    switch (%sbyte_size(x)) { \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    case 1: return %sU1; \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    case 2: return %sU2; \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    case 4: return %sA4; \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    case 8: return %sA8; \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    } \n");
    printf(CFILE_MTYPES "  } \n");
    printf(CFILE_MTYPES "  switch (%sbyte_size(x)) { \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "  case 1: return MTYPE_signed(y) ? MTYPE_I1 : MTYPE_U1; \n");
    printf(CFILE_MTYPES "  case 2: return MTYPE_signed(y) ? MTYPE_I2 : MTYPE_U2; \n");
    printf(CFILE_MTYPES "  case 4: return MTYPE_signed(y) ? MTYPE_I4 : MTYPE_U4; \n");
    printf(CFILE_MTYPES "  case 8: return MTYPE_signed(y) ? MTYPE_I8 : MTYPE_U8; \n");
    printf(CFILE_MTYPES "  } \n");
    printf(CFILE_MTYPES "  return MTYPE_UNKNOWN; \n");
    printf(CFILE_MTYPES "} \n\n");

    ################################################
    ##    TYPE_ID MTYPE_TransferSize(INT32 x, TYPE_ID y)
    ################################################

    printf(HFILE_MTYPES "extern %s MTYPE_TransferSize( INT32, %s ); \n", $MTYPE_TYPE, $MTYPE_TYPE);

    printf(CFILE_MTYPES "/* ==================================================================== \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * MTYPE_TransferSize \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Return the mtype version of y taking on the size x. \n");
    printf(CFILE_MTYPES " * If y is A4 or A8 and x's size is smaller than 4 bytes, return U1 or U2. \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * ==================================================================== \n");
    printf(CFILE_MTYPES " */ \n");
    printf(CFILE_MTYPES "%s MTYPE_TransferSize(INT32 x, %s y) \n", $MTYPE_TYPE, $MTYPE_TYPE);
    printf(CFILE_MTYPES "{ \n");
    printf(CFILE_MTYPES "  if (y == %sA4 || y == %sA8) { \n", $MTYPE_PREFIX, $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    switch (x) { \n");
    printf(CFILE_MTYPES "    case 1: return %sU1; \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    case 2: return %sU2; \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    case 4: return %sA4; \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    case 8: return %sA8; \n", $MTYPE_PREFIX);
    printf(CFILE_MTYPES "    } \n");
    printf(CFILE_MTYPES "  } \n");
    printf(CFILE_MTYPES "  switch (x) { \n");
    printf(CFILE_MTYPES "  case 1: return MTYPE_signed(y) ? MTYPE_I1 : MTYPE_U1; \n");
    printf(CFILE_MTYPES "  case 2: return MTYPE_signed(y) ? MTYPE_I2 : MTYPE_U2; \n");
    printf(CFILE_MTYPES "  case 4: return MTYPE_signed(y) ? MTYPE_I4 : MTYPE_U4; \n");
    printf(CFILE_MTYPES "  case 8: return MTYPE_signed(y) ? MTYPE_I8 : MTYPE_U8; \n");
    printf(CFILE_MTYPES "  } \n");
    printf(CFILE_MTYPES "  return MTYPE_UNKNOWN; \n");
    printf(CFILE_MTYPES "} \n\n");


    ################################################
    ##    TYPE_ID Mtype_complex_to_real(TYPE_ID x, TYPE_ID y)
    ################################################

    printf(HFILE_MTYPES "extern %s Mtype_complex_to_real( %s ); \n", $MTYPE_TYPE, $MTYPE_TYPE);

    printf(CFILE_MTYPES "static %s Table_complex_to_real[] = { \n", $MTYPE_TYPE);
    printf(CFILE_MTYPES "  /* %sUNKNOWN */ \t %sUNKNOWN", $MTYPE_PREFIX, $MTYPE_PREFIX);
    for ($i = 1; $i < $type_count; $i++) {
	if (!defined($mtype_alias[$i])) {
	    my($tname) = $MTYPE_PREFIX . $mtype_id[$i];
	    my($nname);
	    if (defined($mtype_complex_to_real[$i])) {
		$nname = $MTYPE_PREFIX . $mtype_complex_to_real[$i];
	    }
	    else {
		$nname = $tname;
	    }
	    printf(CFILE_MTYPES ",\n  /* %s */ \t %s", $tname, $nname);
	}
    }
    printf(CFILE_MTYPES "\n}; \n\n");

    ################################################
    ##    TYPE_ID Mtype_complex_to_real(TYPE_ID type)
    ################################################

    printf(CFILE_MTYPES "/* ==================================================================== \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Mtype_complex_to_real \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Return real type corresponding to complex \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * ==================================================================== \n");
    printf(CFILE_MTYPES " */ \n");
    printf(CFILE_MTYPES "TYPE_ID Mtype_complex_to_real(TYPE_ID type) \n");
    printf(CFILE_MTYPES "{ \n");

#  This is what it used to be:
#
#  if (MTYPE_is_complex(type))
#  {
#    switch(type) {
#    case MTYPE_C4:
#	return MTYPE_F4;
#    case MTYPE_C8:
#	return MTYPE_F8;
#    case MTYPE_CQ:
#	return MTYPE_FQ;
#    }
#  }
#  return type;

    printf(CFILE_MTYPES "  return Table_complex_to_real[type]; \n");
    printf(CFILE_MTYPES "} \n\n");

    ################################################
    ##    TYPE_ID  MTYPE_comparison(TYPE_ID)
    ################################################

    printf(CFILE_MTYPES "static %s Table_comparison[] = { \n", $MTYPE_TYPE);
    printf(CFILE_MTYPES "  /* %sUNKNOWN */ \t %sUNKNOWN", $MTYPE_PREFIX, $MTYPE_PREFIX);
    for ($i = 1; $i < $type_count; $i++) {
	if (!defined($mtype_alias[$i])) {
	    my($tname) = $MTYPE_PREFIX . $mtype_id[$i];
	    my($nname);
	    if (defined($mtype_comparison[$i])) {
		$nname = $MTYPE_PREFIX . $mtype_comparison[$i];
	    }
	    else {
		$nname = $tname;
	    }
	    printf(CFILE_MTYPES ",\n  /* %s */ \t %s", $tname, $nname);
	}
    }
    printf(CFILE_MTYPES "\n}; \n\n");


    printf(HFILE_MTYPES "extern %s Mtype_comparison( %s ); \n", $MTYPE_TYPE, $MTYPE_TYPE);

    printf(CFILE_MTYPES "/* ==================================================================== \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * MTYPE_comparison(TYPE_ID) \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Return a canonicalized type for a comparison \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * ==================================================================== \n");
    printf(CFILE_MTYPES " */ \n");
    printf(CFILE_MTYPES "%s  Mtype_comparison(%s type) \n", $MTYPE_TYPE, $MTYPE_TYPE);
    printf(CFILE_MTYPES "{ \n");

#  This is what it used to be:
#
#  switch(type)
#  {
#  case MTYPE_I1:
#  case MTYPE_I2:
#    return MTYPE_I4;
#  case MTYPE_U1:
#  case MTYPE_U2:
#    return MTYPE_U4;
#  default:
#    return type;
#  }


    printf(CFILE_MTYPES "  return Table_comparison[type]; \n");
    printf(CFILE_MTYPES "} \n\n");

    ################################################
    ##    TYPE_ID Mtype_next_alignment(TYPE_ID)
    ################################################

    printf(HFILE_MTYPES "extern %s Mtype_next_alignment( %s ); \n", $MTYPE_TYPE, $MTYPE_TYPE);

    printf(CFILE_MTYPES "/* ==================================================================== \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Mtype_next_alignment() \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Return the next best alignment type (or MTYPE_UNKNOWN) \n");
    printf(CFILE_MTYPES " * This is used to iterate thru types to improve alignment \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * ==================================================================== \n");
    printf(CFILE_MTYPES " */ \n");
    printf(CFILE_MTYPES "%s Mtype_next_alignment(%s type) \n", $MTYPE_TYPE, $MTYPE_TYPE);
    printf(CFILE_MTYPES "{ \n");
    printf(CFILE_MTYPES "  return Machine_Next_Alignment[type]; \n");
    printf(CFILE_MTYPES "} \n\n");

    ################################################
    ##    TYPE_ID Mtype_prev_alignment(TYPE_ID)
    ################################################

    printf(HFILE_MTYPES "extern %s Mtype_prev_alignment( %s ); \n", $MTYPE_TYPE, $MTYPE_TYPE);

    printf(CFILE_MTYPES "/* ==================================================================== \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Mtype_prev_alignment() \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * Return the prevevious alignment (or MTYPE_UNKNOWN) \n");
    printf(CFILE_MTYPES " * \n");
    printf(CFILE_MTYPES " * ==================================================================== \n");
    printf(CFILE_MTYPES " */ \n");
    printf(CFILE_MTYPES "%s Mtype_prev_alignment(%s type) \n", $MTYPE_TYPE, $MTYPE_TYPE);
    printf(CFILE_MTYPES "{ \n");
    printf(CFILE_MTYPES "  return Machine_Prev_Alignment[type]; \n");
    printf(CFILE_MTYPES "} \n\n");

    printf(HFILE_MTYPES "\n");
    printf(CFILE_MTYPES "\n");
}

####################################################################
#                       PROPERTIES
####################################################################

sub BEGIN_PROPERTY {
  $prop_cnt = 0;
}

sub NEW_PROPERTY {
  $#_ == 1 || die "Bad number of args to NEW_PROPERTY";
  ($_[0] && $_[1]) || die "missing property or type in NEW_PROPERTY";
  $prop_isv[$prop_cnt] = 0;
  $prop_name[$prop_cnt] = $_[0];
  $prop_type[$prop_cnt] = $_[1];
  $prop_number{$prop_name[$prop_cnt]} = $prop_cnt;
  $prop_cnt++;
}

sub NEW_VALUED_PROPERTY {
  # "i"        integral value
  # "e"        enumeration value i.e. copy the string
  # "s"        string value, i.e. put quotation marks around the string

  $#_ == 2 || $#_ == 3 || die "Bad number of args to NEW_PROPERTY";
  ($_[0] && $_[1]) || die "missing property or type in NEW_PROPERTY";
  $prop_isv[$prop_cnt] = 1;
  $prop_name[$prop_cnt] = $_[0];
  $prop_type[$prop_cnt] = $_[1];
  $prop_reptype[$prop_cnt] = $_[2];
  $prop_default_v[$prop_cnt] = $_[3] if ($#_ == 3);
  $prop_number{$prop_name[$prop_cnt]} = $prop_cnt;
  $prop_name[$prop_cnt] ne 'flag' ||
    die "$prop_name[$prop_cnt]: valued property cannot be flag";
  $prop_reptype[$prop_cnt] eq "i" ||
    $prop_reptype[$prop_cnt] eq "e" ||
      $prop_reptype[$prop_cnt] eq "s" ||
	die "illegal prop_reptype: $prop_reptype[$prop_cnt]";
  $prop_cnt++;
}

# END_PROPERTY
#
# process all properties: make a C structure containing all properties,
# and write accessor functions.
#
# This procedure defines and exports
#
# prop_flag_cnt          the number of flag properties.
# INFO                   the name of the C opcode information object
# INFO_STRUCT            the name of the C opcode information object structure
# PROPERTY_PREFIX        the prefix for properties that are flags
# VALUED_PROPERTY_PREFIX the prefix for properties that are values
# opcode_string_size     bytes allocated for the opcode name
#
# also defined by the properties are
#
# prop_cnt               the number op properties ($#prop_name+1)
# prop_isv               array indexed by number, flag, whether is valued
# prop_name              array indexed by number, of name
# prop_type              array indexed by number, of user specified C type
# prop_reptype           "i" C integer; "e" C enum; "s" C string
# prop_default_v         array indexed by number, of value (defined when isv)
# prop_number            assoc array mapping name->number, inverse of prop_name
#
# Limit properties to 32.  More than that, either return a different field or
# compare to zero or something.  I don't want (1<<54) being returned and then
# cast to an int.

sub END_PROPERTY {
  my($i);
  my(%prop_name_seen);

  $prop_flag_cnt = 0;
  $INFO = $GENERAL_PREFIX . "info";
  $INFO_STRUCT = $GENERAL_PREFIX . "info_struct";
  $PROPERTY_PREFIX = $GENERAL_PREFIX . "PROPERTY_";
  $opcode_string_size = 23;

  # define the property and info structure

  printf(HFILET "/* operators, types, and attributes of the operators */\n\n");
  printf(HFILET "extern struct %s {\n", $INFO_STRUCT);
  printf(HFILET "  char%s_name[%d];\n", &tabs(2, 6), $opcode_string_size);

  for ($i = 0; $i < $prop_cnt; $i++) {
    my($pname) = $prop_name[$i];
    my($ptype) = $prop_type[$i];

    !defined($prop_name_seen{$pname}) || die "property $pname redefined";

    if ($ptype eq 'flag') {
      $prop_flag_cnt++;
    }
    else {
      printf(HFILET "  %s%s%s;\n", $ptype, &tabs(2, 2, $ptype), $pname);
    }
  }

  if ($prop_flag_cnt > 0) {
    if ($prop_flag_cnt <= 32) {
      $prop_flag_type = "mUINT32";
    }
    elsif ($prop_flag_cnt <= 64) {
      $prop_flag_type = "mUINT64";
    }
    else {
      die "too many properties: %d";
    }
    printf(HFILET "  %s%s_flags;\n", $prop_flag_type, &tabs(2, 9));
  }

  printf(HFILET "} %s[];\n\n", $INFO);

  # #define any flags of interest (for flags) into the .h file.

  if ($prop_flag_cnt > 0) {
    printf(HFILET "/* Flag property bits, field _flag */\n\n");
    my($bit) = 1;
    for ($i = 0; $i < $prop_cnt; $i++) {
      my($ptype) = $prop_type[$i];
      next if ($ptype ne 'flag');
      my($pname) = $prop_name[$i];
      my($pflag) = $PROPERTY_PREFIX . $pname;
      printf(HFILET "#define %s%s0x%08x\n", $pflag, &tabs(6, 8, $pflag), $bit);
      $bit *= 2;
    }
    printf(HFILET "\n");
  }

  # put accessor macros for fields into the .h file.

  my($paranoid_check) = "  Is_True(op >= " . $GOP_TYPE . "_FIRST && " .
    "op <= " . $GOP_TYPE . "_LAST, (\"Bad operator %d\", op));\n";

  # put accessor macros for properties into the .h file.

  printf(HFILED "/* Inlines for looking up attribute values */\n\n");

  for ($i = 0; $i < $prop_cnt; $i++) {
    my($pname) = $prop_name[$i];
    my($ptype) = $prop_type[$i];

    if ($ptype eq 'flag') {
      my($pflag) = $PROPERTY_PREFIX . $pname;
      my($prefix) = $property_accessor_prefix{$pname};
      if ($prefix eq '') {$prefix = $PROPERTY_ACCESSOR_PREFIX};
      printf(HFILED "/*REFERENCED*/\n");
      printf(HFILED "inline %s \n", $prop_flag_type);
      printf(HFILED "%s (%s op)\n{\n%s" .
	            "  return (%s) %s [op]._flags & %s;\n}\n\n",
	     $prefix . $pname, $GOP_TYPE, $paranoid_check,
	     $prop_flag_type, $INFO, $pflag);
    }
    elsif ($prop_isv[$i]) {
      printf(HFILED "/*REFERENCED*/\n");
      printf(HFILED "inline %s\n", $ptype);
      printf(HFILED "%s (%s op)\n{\n%s  return %s[op].%s;\n}\n\n",
	     $VALUED_PROPERTY_ACCESSOR_PREFIX . $pname,
	     $GOP_TYPE, $paranoid_check, $INFO, $pname);
    }
    else {
      my($prefix) = $property_accessor_prefix{$pname};
      if ($prefix eq '') {$prefix = $PROPERTY_ACCESSOR_PREFIX};
      printf(HFILED "/*REFERENCED*/\n");
      printf(HFILED "inline UINT32 %s(%s op)\n{\n%s" .
	            "  return (UINT32) %s[op].%s;\n}\n\n",
	     $prefix . $pname, $OP_TYPE, $paranoid_check, $INFO, $pname);
    }
  }

  # handle black-box that doesn't have associated property
  printf(HFILED "/*REFERENCED*/\n");
  printf(HFILED "inline BOOL \n");
  printf(HFILED "OPERATOR_is_black_box (OPERATOR op)\n");
  printf(HFILED "{\n%s", $paranoid_check);
  printf(HFILED "  return ( op == OPR_IO );\n");
  printf(HFILED "}\n");

  # handle newest SGI additions:
  printf(HFILED "\n");
  printf(HFILED "/* Compatibility functions */\n");
  printf(HFILED "#if 0\n");
  printf(HFILED "extern OPCODE   OPCODE_is_valid_opcode_table[];\n");
  printf(HFILED "#define OPCODE_MAKE_VALID(x) (OPCODE_is_valid_opcode_table[(x)])\n");
  printf(HFILED "#endif\n\n");

  printf(HFILED "#if 1\n");
  printf(HFILED "#define Is_Valid_Opcode Is_Valid_Opcode_FUNC\n");
  printf(HFILED "#else\n");
  printf(HFILED "#define Is_Valid_Opcode(opcode) (OPCODE_is_valid_opcode_table[(opcode)]!=OPC_UNKNOWN)\n");
  printf(HFILED "#endif\n\n");

  printf(HFILED "#ifdef __cplusplus\n");
  printf(HFILED "extern \"C\" BOOL Is_Valid_Opcode_FUNC (OPCODE op);\n");
  printf(HFILED "BOOL Is_Valid_Opcode_Parts(OPERATOR opr, TYPE_ID rtype, TYPE_ID desc);\n");
  printf(HFILED "#else\n");
  printf(HFILED "extern BOOL Is_Valid_Opcode_FUNC (OPCODE op);\n");
  printf(HFILED "#endif /* __cplusplus */\n\n");

  # the old stuff is finally usefull ...

  $paranoid_check = "  Is_True(Is_Valid_Opcode (op), (\"Bad opcode %d\", op));\n";

  printf(HFILED "/*REFERENCED*/\n");
  printf(HFILED "inline %s \n", $GOP_TYPE);
  printf(HFILED "%s_operator (%s op)\n{\n%s" . 
	        "  return (%s)(op & 0xFF);\n}\n\n",
	 $OP_TYPE, $OP_TYPE, $paranoid_check,
	 $GOP_TYPE);
  printf(HFILED "/*REFERENCED*/\n");
  printf(HFILED "inline %s \n", $MTYPE_TYPE);
  printf(HFILED "%s_rtype (%s op)\n{\n%s" . 
	        "  return (%s)((op >> 8) & 0x1F);\n}\n\n",
	 $OP_TYPE, $OP_TYPE, $paranoid_check,
	 $MTYPE_TYPE);
  printf(HFILED "/*REFERENCED*/\n");
  printf(HFILED "inline %s \n", $MTYPE_TYPE);
  printf(HFILED "%s_desc (%s op)\n{\n%s" .
	        "  return (%s)((op >> 13) & 0x1F);\n}\n\n",
	 $OP_TYPE, $OP_TYPE, $paranoid_check,
	 $MTYPE_TYPE);
  printf(HFILED "extern char* %s_name (%s op);\n", 
         $OP_TYPE, $OP_TYPE);

  # more attributes:

  printf(HFILED "\n");
  printf(HFILED "/* Inlines for looking up attribute values */\n\n");

  for ($i = 0; $i < $prop_cnt; $i++) {
    my($pname) = $prop_name[$i];
    my($ptype) = $prop_type[$i];


    if ($ptype eq 'flag') {
      my($pflag) = $PROPERTY_PREFIX . $pname;
      my($op_prefix);
      my($gop_prefix);
      if ($property_accessor_prefix{$pname} eq '') {
	  $gop_prefix = $PROPERTY_ACCESSOR_PREFIX;
	  $op_prefix = $OP_TYPE . "_is_";
      }
      else {
	  $gop_prefix = $property_accessor_prefix{$pname};
	  $op_prefix = $OP_TYPE . "_has_";
      }
      printf(HFILED "/*REFERENCED*/\n");
      printf(HFILED "inline %s\n", $prop_flag_type);
      printf(HFILED "%s (%s op)\n{\n%s", 
	     $op_prefix . $pname,
	     $OP_TYPE, $paranoid_check);
      printf(HFILED "  return (%s (%s_operator (op)));\n}\n\n",
	     $gop_prefix . $pname,
	     $OP_TYPE);
    }
    elsif ($prop_isv[$i]) {
      printf(HFILED "/*REFERENCED*/\n");
      printf(HFILED "inline %s\n", $ptype);
      printf(HFILED "%s (%s op)\n{\n%s", 
	     $OP_TYPE . "_" . $pname,
	     $OP_TYPE, $paranoid_check);
      printf(HFILED "  return (%s (%s_operator (op)));\n}\n\n",
	     $VALUED_PROPERTY_ACCESSOR_PREFIX . $pname,
	     $OP_TYPE);
    }
    else {
      my($prefix) = $property_accessor_prefix{$pname};
      if ($prefix eq '') {$prefix = $PROPERTY_ACCESSOR_PREFIX};
      printf(HFILED "/*REFERENCED*/\n");
      printf(HFILED "inline UINT32 %s(%s op)\n{\n%s" .
	            "  return (UINT32) %s[op].%s;\n}\n\n",
	     $prefix . $pname, $OP_TYPE, $paranoid_check, $INFO, $pname);
    }
  }

  # handle black-box that doesn't have associated property
  printf(HFILED "/*REFERENCED*/\n");
  printf(HFILED "inline BOOL \n");
  printf(HFILED "OPCODE_is_black_box (OPCODE op)\n");
  printf(HFILED "{\n%s", $paranoid_check);
  printf(HFILED "  return (OPERATOR_is_black_box (OPCODE_operator (op)));\n");
  printf(HFILED "}\n");
}

sub SIMP_OP {
    my($oname) = $_[0];
    my($sfunc) = $_[1];
    $oname = $GOP_PREFIX . $oname;
    $simp_func_name{$oname} = $sfunc;
}

sub BEGIN_OP {
}

#
# OP communicates to END_OP via
#       gop_cnt: the number of distinct generic operators
#       gop_name: maps the gop number (1 to gop_cnt) to the name
#       gop_shortname: as above, but without the prefix.
#       gop_info: maps gop number to an ^-separated data structure containing
#           "^rtype1^desc1^props1^rtype2^desc2^props2^..."
#           where rtype is the return type name
#           where desc is the descriptor type name
#           where prop are all the properties, connected via @.
#

# comment for all operators with a given name, e.g. ADD
sub GOPCOMMENT {
  $gopcomment{$_[0]} = $_[1];
}

# comment for specific opcode with a given name, e.g. F8ADD
sub OPCOMMENT {
  $opcomment{$OP_PREFIX . $_[0]} = $_[1];
}

sub OPIGN {
  $ignoring_on = 1;
  $opignore{$OP_PREFIX . $_[0]} = 1;
  die "Cannot both ignore and keep" if $keeping_on == 1
}

sub OPKEEP {
  $keeping_on = 1;
  $opkeep{$OP_PREFIX . $_[0]} = 1;
  die "Cannot both ignore and keep" if $ignoring_on == 1
}

sub OP {
  my($tt);
  my($dd);
  my($i);

  my($gname) = $_[0];
  my($rdesc) = $_[1];
  my($ddesc) = $_[2];

  # First of all remember this OPs signature: "i,p,z:V" for
  # example. Signature is sorted bytypenumber. Add OP to
  # the table hashed by its signature. Later this is used
  # to produce OPCODE_name() and Is_Valid_Opcode_Parts() 
  # routines.

  my(@rl) = sort bytypename (split(',', $rdesc));
  my(@dl) = sort bytypename (split(',', $ddesc));
  my($signature) = join (':', join(',',@rl), join(',',@dl));
  push(@{$Class{$signature}}, $gname);
  
#  printf(STDOUT "$gname: $signature\n");

  # Now the rest of it:

  my(@rtype) = &makebasetypearray($_[1]);
  my(@desc) = &makebasetypearray($_[2]);
  my($props) = join("@", @_[3 .. $#_]);

  $keeping{$gname} = $keeping_on;
  $ignoring{$gname} = $ignoring_on;
  $keeping_on = 0;
  $ignoring_on = 0;

  for ($i = 3; $i <= $#_; $i++) {
    my($pname) = $_[$i];
    my($pnum) = $prop_number{$pname};
    defined($pnum) || die "unknown property $pname for $gname";
    $i++ if ($prop_isv[$pnum]);
  }

  if (!defined($gop_number{$gop})) {
    $gop_number{$gname} = ++$gop_cnt;
    $gop_name[$gop_cnt] = $GOP_PREFIX . $gname;
    $gop_shortname[$gop_cnt] = $gname;
  }

  # store with each gop name a list of legal types and flags.

  my($gnum) = $gop_number{$gname};

  for $tt (@rtype) {
    for $dd (@desc) {
      # if this tt and dd match a previously entered one, make sure
      # the properties are the same.  If no match, put in gop_info.

      my(@data) = split(/\^/, $gop_info[$gnum]);
      my($i);
      my($duplicate_seen) = 0;
      for ($i = 1; $i < $#data; $i += 3) {
	if ($data[$i] eq $tt && $data[$i+1] eq $dd) {
	  $duplicate_seen = 1;
	  $data[$i+2] == $props ||
	    die "$gname (rtype:$tt, desc:$dd) has inconsistent flags" .
	      "$data[$i+2] and $props";
	  break;
	}
      }
      if ($duplicate_seen == 0) {
	$gop_info[$gnum] = join("^", $gop_info[$gnum], $tt, $dd,
				$props);
      }
    }
  }
}

#
# Now that we've seen all the operators, generate initialization code.
#

sub END_OP {
  my($gnum);
  my($gsname);
  my($rtscnt);
  my($dscnt);
  my(@opfirst);
  my(@oplast);
  my($i) = 1;
  my($j);

  #
  # '#define' the generic operators and put in the .h file.
  #

  printf(HFILET "/* Definition of type %s */\n\n", $GOP_TYPE);
  printf(HFILET "#define OPR_DIVPART OPR_LOWPART\n");
  printf(HFILET "#define OPR_REMPART OPR_HIGHPART\n");
  printf(HFILET "#define OPR_COMPLEX OPR_PAIR\n");
  printf(HFILET "#define OPR_REALPART OPR_FIRSTPART\n");
  printf(HFILET "#define OPR_IMAGPART OPR_SECONDPART\n");
  printf(HFILET "\n");
  printf(HFILET "typedef enum {\n");
  printf(HFILET "  %s = %d,\n", $GOP_TYPE . "_UNKNOWN", 0);
  printf(HFILET "  %s = %d,\n", $GOP_TYPE . "_FIRST", $i);

  for ($gnum = 1; $gnum <= $gop_cnt; $gnum++) {
    my($gname) = $gop_name[$gnum];
    printf(HFILET "  %s = %d,\n", $gname, $i++);
  }
  printf(HFILET "  %s = %d\n", $GOP_TYPE . "_LAST", $i-1);
  printf(HFILET "} %s;\n\n", $GOP_TYPE);

  #
  # create the simplifier function dispatch table
  #
  printf(SFILET "typedef simpnode (*simpfunction)(OPCODE, simpnode, ");
  printf(SFILET "simpnode, BOOL, BOOL);\n\n");
  printf(SFILET "static \n");
  printf(SFILET "simpfunction simplify_function_table[OPERATOR_LAST+1]={\n");
  printf(SFILET "NULL, /* index 0 is not used */\n");

  for ($gnum = 1; $gnum <= $gop_cnt; $gnum++) {
    my($gname) = $gop_name[$gnum];
    my($sfunc) = $simp_func_name{$gname};
    if ($sfunc) {
	printf(SFILET "$sfunc,\t /* $gname */\n");
    } else {
	printf(SFILET "NULL, \t/* $gname */\n");
    }
  }
  printf(SFILET "};\n");

  # go through gop_info, making opcodes for the HFILET, and simultaneously,
  # fill in the info table for the opcodes in the CFILET.
  # Also, create arrays opfirst and oplast so print out the first/last
  # gop table when we're through printing out this.

  printf(HFILET "/* Definition of type %s */\n\n", $OP_TYPE);
  printf(HFILET "#define OPC_I4DIVPART OPC_I4LOWPART\n");
  printf(HFILET "#define OPC_I8DIVPART OPC_I8LOWPART\n");
  printf(HFILET "#define OPC_U4DIVPART OPC_U4LOWPART\n");
  printf(HFILET "#define OPC_U8DIVPART OPC_U8LOWPART\n");
  printf(HFILET "#define OPC_I4REMPART OPC_I4HIGHPART\n");
  printf(HFILET "#define OPC_I8REMPART OPC_I8HIGHPART\n");
  printf(HFILET "#define OPC_U4REMPART OPC_U4HIGHPART\n");
  printf(HFILET "#define OPC_U8REMPART OPC_U8HIGHPART\n");
  printf(HFILET "\n");

  printf(HFILET "#define OPC_C4COMPLEX   OPC_C4PAIR\n");
  printf(HFILET "#define OPC_C8COMPLEX   OPC_C8PAIR\n");
  printf(HFILET "#define OPC_CQCOMPLEX   OPC_CQPAIR\n");
  printf(HFILET "#define OPC_C10COMPLEX  OPC_C10PAIR\n");
  printf(HFILET "#define OPC_C16COMPLEX  OPC_C16PAIR\n");
  printf(HFILET "#define OPC_F4REALPART  OPC_F4FIRSTPART\n");
  printf(HFILET "#define OPC_F8REALPART  OPC_F8FIRSTPART\n");
  printf(HFILET "#define OPC_FQREALPART  OPC_FQFIRSTPART\n");
  printf(HFILET "#define OPC_F10REALPART OPC_F10FIRSTPART\n");
  printf(HFILET "#define OPC_F16REALPART OPC_F16FIRSTPART\n");
  printf(HFILET "#define OPC_F4IMAGPART  OPC_F4SECONDPART\n");
  printf(HFILET "#define OPC_F8IMAGPART  OPC_F8SECONDPART\n");
  printf(HFILET "#define OPC_FQIMAGPART  OPC_FQSECONDPART\n");
  printf(HFILET "#define OPC_F10IMAGPART OPC_F10SECONDPART\n");
  printf(HFILET "#define OPC_F16IMAGPART OPC_F16SECONDPART\n");
  printf(HFILET "\n");

  printf(HFILET "#define RTYPE(x) (x<<8)\n");
  printf(HFILET "#define DESC(x)  (x<<13)\n");
  printf(HFILET "\n");

  printf(HFILET "typedef enum {\n");
  printf(HFILET "  %s\t = %d,\n", $OP_TYPE . "_UNKNOWN", 0);
  printf(HFILET "  %s\t = %d,\n", $OP_TYPE . "_FIRST", 1);

  printf(CFILET "/* Initialization of operator information */\n\n");

  # emit included files
  printf(CFILET "#include \"errors.h\"\n");
  printf(CFILET "#include \"opcode.h\"\n");
  printf(CFILET "#include \"config.h\"\n\n");


  printf(CFILET "struct %s %s[OPERATOR_LAST+1] = {\n\n" .
	 "  {\"UNKNOWN_OPERATOR\"},\n" ,
	 $INFO_STRUCT, $INFO);

  $opcnt = 0;
  for ($gnum = 1; $gnum <= $gop_cnt; $gnum++) {
    my(%rts);
    my(%ds);

    my($gsname) = $gop_shortname[$gnum];
    my($gname) = $GOP_PREFIX . $gsname;
    my(@data) = split(/\^/, $gop_info[$gnum]);

    for ($i = 1; $i < $#data; $i += 3) {
      $rts{$data[$i]} = 1;
      $ds{$data[$i+1]} = 1;
    }

    # don't know a better way to cnt the elements in an assoc array
    $rtscnt = 0;
    while (($dummy, $dummy2) = each %rts) {
      $rtscnt++;
    }
    $rtscnt > 0 || die "bad rtscnt for $gsname";
    $dscnt = 0;
    while (($dummy, $dummy2) = each %ds) {
      $dscnt++;
    }
    $dscnt > 0 || die "bad dscnt for $gsname";

    $opfirst[$gnum] = $opcnt+1;

####################################################################


    # print out the info fields. This is no fun.  Here's a slow way:
    # for each property in the world, it is either on the property
    # list or not.  If it's not, then value is zero.  If it is, value
    # is one.  Exception: if it's a flag, then either _flags field
    # has that bit set or not.

    # looks like all the properties are the same for all opcodes:
    $#data > 0 || die "$gname: no opcodes are specified!";
    my(@p) = split(/@/, $data[3]);
    my($ftext) = "";
    printf(CFILET "\n  {\"%s\", \n", $gname);

    #
    # first put properties and their values into an associative array
    # for easy future access.  Put a dummy value in if not a value-prop.
    #
    my(%pr);
    my($pcnt);
    for ($pcnt = 0; $pcnt <= $#p; $pcnt++) {
      my($pname) = $p[$pcnt];
      my($pnum) = $prop_number{$pname};
      my($ptype) = $prop_type[$pnum];
      defined($pnum) || die "$gname: unknown property $pname, 2nd check!";
      $pr{$pname} = ($prop_isv[$pnum]) ? $p[++$pcnt] : "<flagset>";
    }

    #
    # Now go through all properties and see which are defined
    #

    my($pnum);
    for ($pnum = 0; $pnum < $prop_cnt; $pnum++) {
      my($pname) = $prop_name[$pnum];
      my($ptype) = $prop_type[$pnum];

      if ($ptype eq 'flag') {
	# flag, so set if has value
	if (defined($pr{$pname})) {
	  $pr{$pname} eq "<flagset>" ||
	    die "$gname: non-val attribute $pname initialized: $pr{$pname}";
	  my($pp) = $PROPERTY_PREFIX . $pname;
	  $ftext = ($ftext eq "") ? $pp : $ftext . "\t|\n   " . $pp;
	}
      }
      elsif (!$prop_isv[$pnum]) {
	# not a value attribute, so either zero or 1.
	my($val) = 0;
	if (defined($pr{$pname})) {
	  $pr{$pname} eq "<flagset>" ||
	    die "$gname: non-val attribute $pname initialized: $pr{$pname}";
	  $val = 1;
	}

        my($outstring);
        $outstring = "   %d /* %s */,\n" if ($prop_reptype[$pnum] eq "i");
        $outstring = "   %s /* %s */,\n" if ($prop_reptype[$pnum] eq "e");
        $outstring = "   \"%s\" /* %s */,\n" if ($prop_reptype[$pnum] eq "s");
        printf(CFILET $outstring, $val, $pname);
      }
      else {
        # a value attribute, which was either supplied a value
        # or has a default

        my($val) = defined($pr{$pname}) ? $pr{$pname} :
	  defined($prop_default_v[$pnum]) ? $prop_default_v[$pnum] :
	    die "$gname: val'd attribute $pname not supplied, has no default";

        my($outstring);
        $outstring = "   %d /* %s */,\n" if ($prop_reptype[$pnum] eq "i");
        $outstring = "   %s /* %s */,\n" if ($prop_reptype[$pnum] eq "e");
        $outstring = "   \"%s\" /* %s */,\n" if ($prop_reptype[$pnum] eq "s");
        printf(CFILET $outstring, $val, $pname);
      }
    }

    if ($prop_flag_cnt > 0) {
      printf(CFILET "   %s", ($ftext eq "" ? "0" : $ftext));
    }
    printf(CFILET "},\n");

#######################################################################

    for ($i = 1; $i < $#data; $i += 3) {
      $opcnt++;

      my($rt) = $data[$i];
      my($d) = $data[$i+1];
      my($name) = $OP_PREFIX;

      ($name = $name . $rt) unless ($rtscnt <= 1);
      # rather than check for only 1 dscnt, instead check for V ds
      ($name = $name . $d) unless ($d eq 'V');
      $name = $name . $gsname;

      if (($ignoring{$gsname} && $opignore{$name}) ||
	  ($keeping{$gsname} && !$opkeep{$name})) {
	$opcnt--;
	next;
      }

      if ($do_keep) {
	printf "%s, %s\n", $name, $opkeep{$name}
      }

      $rt = $MTYPE_PREFIX . $rt;
      $d = $MTYPE_PREFIX . $d;

      # define the opcodes

      printf(HFILET "  %s\t = %s + RTYPE(%s) + DESC(%s),", 
	     $name, $gname, $rt, $d);
      if (defined($opcomment{$name})) {
	printf(HFILET "  /* %s */", $opcomment{$name});
      }
      if (defined($gopcomment{$gsname})) {
	printf(HFILET "  /* %s */", $gopcomment{$gsname});
      }
      printf(HFILET "\n");

      !defined($names_check{$name}) ||
	die "duplicate opcode name $name from $gnum";
      $names_check{$name} = $opcnt;
      $names[$opcnt] = $name;

      length($name) < $opcode_string_size ||
	die "$name: op string size $opcode_string_size too short";

    }


    $oplast[$gnum] = $opcnt;
  }

  printf(HFILET "  %s = 0x3FFFF\n", $OP_TYPE . "_LAST", $opcnt);
  printf(HFILET "} %s;\n\n", $OP_TYPE);

  printf(HFILET "/* typedef UINT32 %s; */\n\n", $OP_TYPE);

  printf(CFILET "};\n\n");



  printf(HFILET "#undef RTYPE\n");
  printf(HFILET "#undef DESC\n\n");

  #
  # close out the ifdef
  #

  printf(HFILET "#ifdef __cplusplus\n");
  printf(HFILET "}\n");
  printf(HFILET "#endif\n\n");

  printf(HFILET "#endif /* ifndef opcode_gen_core_INCLUDED */\n");

#######################################################################

  ### First print out the BOOL tables:
  my(%pattern_seen);
  foreach $key (keys %Class) {
    my($rtype);
    my($dtype);

    ($rtype, $dtype) = split(':', $key);
    if (!defined($pattern_seen{$rtype})) {
      &MAKE_TABLE($rtype);
      $pattern_seen{$rtype} = 1;
    }
    if (!defined($pattern_seen{$dtype})) {
      &MAKE_TABLE($dtype);
      $pattern_seen{$dtype} = 1;
    }
  }
  printf(CFILET "\n");

########################################################################
#  Now I need to emit some C code 

########################################################################
#   breakpoint

  printf(CFILET "void\n");
  printf(CFILET "breakpoint ()\n");
  printf(CFILET "{\n");
  printf(CFILET "}\n\n");

########################################################################
#   Is_Valid_Opcode_Parts
#

  printf(CFILET "BOOL\n");
  printf(CFILET "Is_Valid_Opcode_Parts (%s opr, TYPE_ID rtype, TYPE_ID desc)\n", $GOP_TYPE);
  printf(CFILET "{\n");
  printf(CFILET "  BOOL valid;\n\n");

  printf(CFILET "       if (opr   < OPERATOR_FIRST || opr   > OPERATOR_LAST) valid = FALSE;\n");
  printf(CFILET "  else if (rtype < %sFIRST    || rtype > %sLAST)    valid = FALSE;\n", $MTYPE_PREFIX, $MTYPE_PREFIX);
  printf(CFILET "  else if (desc  < %sFIRST    || desc  > %sLAST)    valid = FALSE;\n\n", $MTYPE_PREFIX, $MTYPE_PREFIX);

  printf(CFILET "  else  {\n");
  printf(CFILET "    switch (opr) {\n");

  ### Printout the switch:
  foreach $key (keys %Class) {
    my(@ops) = @{$Class{$key}};
    my($op);
    my($special_case) = 0;
    my($rtype);
    my($dtype);
    my($last_not_keep_ignore) = 0;

    while ($#ops >= 0) {
      $op = pop(@ops);
      printf(CFILET "      case %s:\n", $GOP_PREFIX . $op);

      $last_not_keep_ignore = 1;

      ######################################################
      # check if there are OPIGN/OPKEEPs
      #
      my($gnum) = $gop_number{$op};
      my($gsname) = $gop_shortname[$gnum];
      my(@data) = split(/\^/, $gop_info[$gnum]);

      # A special case that should be treated by removing VFCALL from
      # the OPERATOR list altogether (I'll do it later) ...
      #
      if ($gsname eq "VFCALL") {
	  # ignore it ...
      }
      elsif ($keeping{$op}) {
	  $last_not_keep_ignore = 0;
	  printf(CFILET "        if (");

          # whether it's in OPKEEP or not:
	  my($i);
	  my($first) = 1;
	  for ($i = 1; $i < $#data; $i += 3) {
	      my($rt) = $data[$i];
	      my($d) = $data[$i+1];
	      my($name) = $OP_PREFIX;

	      ($name = $name . $rt) unless ($rtscnt <= 1);
	      # rather than check for only 1 dscnt, instead check for V ds
	      ($name = $name . $d) unless ($d eq 'V');
	      $name = $name . $gsname;

	      if ($opkeep{$name}) {
		  if ($first) {
		      $first = 0;
		      printf(CFILET "   !(rtype == MTYPE_%s && desc == MTYPE_%s)", $rt, $d);
		  }
		  else {
		      printf(CFILET "\n          && !(rtype == MTYPE_%s && desc == MTYPE_%s)", $rt, $d);
		  }
	      }
	  }

	  printf(CFILET ") {\n\n");
	  printf(CFILET "          valid = FALSE;\n");
	  printf(CFILET "        }\n");
	  printf(CFILET "        else {\n");
	  printf(CFILET "          valid = TRUE;\n");
	  printf(CFILET "        }\n");
	  printf(CFILET "        break;\n\n");


      }
      elsif ($ignoring{$op}) {
	  $last_not_keep_ignore = 0;
	  printf(CFILET "        if (");

	  # whether it's in OPIGN or not:
	  my($i);
	  my($first) = 1;
	  for ($i = 1; $i < $#data; $i += 3) {
	      my($rt) = $data[$i];
	      my($d) = $data[$i+1];
	      my($name) = $OP_PREFIX;

	      ($name = $name . $rt) unless ($rtscnt <= 1);
	      # rather than check for only 1 dscnt, instead check for V ds
	      ($name = $name . $d) unless ($d eq 'V');
	      $name = $name . $gsname;

	      if ($opignore{$name}) {
		  if ($first) {
		      $first = 0;
		      printf(CFILET "   (rtype == MTYPE_%s && desc == MTYPE_%s)", $rt, $d);
		  }
		  else {
		      printf(CFILET "\n          || (rtype == MTYPE_%s && desc == MTYPE_%s)", $rt, $d);
		  }
	      }
	  }
	  printf(CFILET ") {\n\n");
	  printf(CFILET "          valid = FALSE;\n");
	  printf(CFILET "        }\n");

	  printf(CFILET "        else {\n");
	  ($rtype,$dtype) = split(/:/,$key);
	  my($rtp) = join('_',split(',',$rtype));
	  my($dtp) = join('_',split(',',$dtype));
	  printf(CFILET "          // [RTYPE]: %s [DESC]: %s \n", $rtype,$dtype);
	  printf(CFILET "          valid = Is_%s%s[rtype] && Is_%s%s[desc];\n", 
                         $MTYPE_PREFIX, $rtp, $MTYPE_PREFIX, $dtp);
	  printf(CFILET "        }\n");
	  printf(CFILET "        break;\n\n");
      }
      ######################################################
    }

    if ($last_not_keep_ignore == 1) {
	($rtype,$dtype) = split(/:/,$key);
	my($rtp) = join('_',split(',',$rtype));
	my($dtp) = join('_',split(',',$dtype));
	printf(CFILET "        // [RTYPE]: %s [DESC]: %s \n", $rtype,$dtype);
	printf(CFILET "        valid = Is_%s%s[rtype] && Is_%s%s[desc];\n", 
                         $MTYPE_PREFIX, $rtp, $MTYPE_PREFIX, $dtp);
	printf(CFILET "        break;\n\n");
    }

  }

  printf(CFILET "      default:\n");
  printf(CFILET "        valid = FALSE;\n");
  printf(CFILET "        break;\n");
  printf(CFILET "    }\n");
  printf(CFILET "  }\n\n");
  printf(CFILET "  if (valid == FALSE)\n");
  printf(CFILET "    breakpoint ();\n\n");

  printf(CFILET "  return valid;\n");
  printf(CFILET "}\n\n");

###########################################################################
###   Is_Valid_Opcode_FUNC
###

  printf(CFILET "BOOL\n");
  printf(CFILET "Is_Valid_Opcode_FUNC (OPCODE opc)\n");
  printf(CFILET "{\n");
  printf(CFILET "  OPERATOR opr   = (OPERATOR) (((UINT32) opc) & 0xFF);\n");
  printf(CFILET "  TYPE_ID  rtype = (TYPE_ID)  ((((UINT32) opc) >> 8) & 0x1F);\n");
  printf(CFILET "  TYPE_ID  desc  = (TYPE_ID)  ((((UINT32) opc) >> 13) & 0x1F);\n\n");

  printf(CFILET "  return Is_Valid_Opcode_Parts (opr, rtype, desc);\n");
  printf(CFILET "}\n\n");

###########################################################################
###   OPCODE_name

  my($SFMT) = "%s";

  printf(CFILET "char*\n");
  printf(CFILET "OPCODE_name (OPERATOR opr, TYPE_ID rtype, TYPE_ID desc)\n");
  printf(CFILET "{\n");
  printf(CFILET "  static char buffer [64];\n\n");

  printf(CFILET "  Is_True(Is_Valid_Opcode_Parts (opr, rtype, desc),\n");
  printf(CFILET "\t\t\t (\"Bad opcode %s %s %s\", opr, rtype, desc));\n\n",
            "%d", "%d", "%d");

  printf(CFILET "  switch (opr) {\n\n");

  foreach $key (keys %Class) {
    my(@ops) = @{$Class{$key}};
    my($op);
    my($rtype);
    my($dtype);

    while ($#ops >= 0) {
      $op = pop(@ops);

      # special cases printed separately: 
      #     OPR_MLOAD.
      if ($op ne 'MLOAD') {
	  printf(CFILET "      case %s:\n", $GOP_PREFIX . $op);
      }
    }

    ($rtype,$dtype) = split(/:/,$key);
    printf(CFILET "        // [RTYPE]: %s [DESC]: %s \n", $rtype,$dtype);

    if ($rtype eq "V") {
      if ($dtype eq "V") {
        printf(CFILET "        sprintf (buffer, \"%s%s\", &OPERATOR_info [opr]._name [4]);\n", $OP_PREFIX, $SFMT);
      }
      elsif (&is_in_set($dtype, "V")) {
	printf(CFILET "        if (desc == MTYPE_V)\n");
	printf(CFILET "          sprintf (buffer, \"%s%s\", &OPERATOR_info [opr]._name [4]);\n", $OP_PREFIX, $SFMT);
	printf(CFILET "        else\n");
	printf(CFILET "          sprintf (buffer, \"%s%s%s\", MTYPE_name(desc), &OPERATOR_info [opr]._name [4]);\n", $OP_PREFIX, $SFMT, $SFMT);
      }
      else {
        printf(CFILET "        sprintf (buffer, \"%s%s%s\", MTYPE_name(desc), &OPERATOR_info [opr]._name [4]);\n", $OP_PREFIX, $SFMT, $SFMT);
      }
    }
    else {
      if ($dtype eq "V") {
        printf(CFILET "        sprintf (buffer, \"%s%s%s\", MTYPE_name(rtype), &OPERATOR_info [opr]._name [4]);\n", $OP_PREFIX, $SFMT, $SFMT);
      }
      elsif (&is_in_set($dtype, "V")) {
	printf(CFILET "        if (desc == MTYPE_V)\n");
	printf(CFILET "          sprintf (buffer, \"%s%s%s\", MTYPE_name(rtype), &OPERATOR_info [opr]._name [4]);\n", $OP_PREFIX, $SFMT, $SFMT);
	printf(CFILET "        else\n");
        printf(CFILET "          sprintf (buffer, \"%s%s%s%s\", MTYPE_name(rtype), MTYPE_name(desc), &OPERATOR_info [opr]._name [4]);\n", $OP_PREFIX, $SFMT, $SFMT, $SFMT);
      }
      else {
        printf(CFILET "        sprintf (buffer, \"%s%s%s%s\", MTYPE_name(rtype), MTYPE_name(desc), &OPERATOR_info [opr]._name [4]);\n", $OP_PREFIX, $SFMT, $SFMT, $SFMT);
      }
    }

    printf(CFILET "        break;\n\n");
  }

  # Now the special cases:
  printf(CFILET "    case %sMLOAD: \n", $GOP_PREFIX);
  printf(CFILET "      // [RTYPE] : M [DESC] : V \n");
  printf(CFILET "      sprintf (buffer, \"%s%s\", &OPERATOR_info [opr]._name [4]);\n", $OP_PREFIX, $SFMT);
  printf(CFILET "      break;\n\n");


  printf(CFILET "    default:\n");
  printf(CFILET "      buffer [0] = 0;\n");
  printf(CFILET "      break;\n");
  printf(CFILET "  }\n\n");

  printf(CFILET "  return buffer;\n");
  printf(CFILET "}\n\n");

###########################################################################
###   OPCODE_name

  printf(CFILET "char*\n");
  printf(CFILET "OPCODE_name (OPCODE opc)\n");
  printf(CFILET "{\n");
  printf(CFILET "  OPERATOR opr   = (OPERATOR) (((UINT32) opc) & 0xFF);\n");
  printf(CFILET "  TYPE_ID  rtype = (TYPE_ID)  ((((UINT32) opc) >> 8) & 0x1F);\n");
  printf(CFILET "  TYPE_ID  desc  = (TYPE_ID)  ((((UINT32) opc) >> 13) & 0x1F);\n\n");

  printf(CFILET "  return OPCODE_name (opr, rtype, desc);\n");
  printf(CFILET "}\n\n");

########## close the files:

  close(HFILET);
  close(HFILED);
  close(CFILET);
  close(SFILET);

  printf(HFILE_MTYPES "#ifdef __cplusplus \n");
  printf(HFILE_MTYPES "} \n");
  printf(HFILE_MTYPES "#endif \n");
  printf(HFILE_MTYPES "#endif /* mtypes_INCLUDED */ \n");
  close(HFILE_MTYPES);

  close(CFILE_MTYPES);
}

###########################################################################
###
### Utility routines
###
###########################################################################

#
# is_in_set: is @_[1] mtype in set of types @_[0]
#
# Uses the global associative array abbrevtype, which contains the mapping from
# types into basetypes, e.g. abbrevtype{"i"} -> I,J,K,L.

sub is_in_set {

  # @_[0] is actually a set of basetypes; @_[1] is a mtype we're
  # comparing against.
  my(@entries) = &makebasetypearray(@_[0]);
  my($type) = @_[1];
  my($found) = 0;

  for ($tid = 0; $tid <= $#entries; $tid++) {
    if ($entries[$tid] eq $type) {
      $found = 1;
    }
  }

  $found;
}

#
# MAKE_TABLE -- there are some tables defining MTYPE properties in 
# the opcode_gen_core.cxx. This routine produces a table Is_MTYPE_XXX,
# where XXX is in @_[0]. It sets types listed in @_[0] (in the form
# "I,J,K,L") to 1, and others to 0.
#
sub MAKE_TABLE {

  my($entries) = @_[0];
  my($found);
  my($tname);

  my($x) = join('_',split(',',$entries));

  printf(CFILET "static BOOL\n");
  printf(CFILET "Is_%s%s [%sLAST+1] = {\n", 
                       $MTYPE_PREFIX, $x, $MTYPE_PREFIX);
  printf(CFILET "  0, /* %sUNKNOWN */\n", $MTYPE_PREFIX);

  for ($i = 1; $i < $type_count; $i++) {
    $tname = $MTYPE_PREFIX . $mtype_id[$i];
    if (!defined($mtype_alias[$i])) {
      $found = &is_in_set($entries, $mtype_id[$i]);
      printf(CFILET "  %d, /* %s */\n", $found, $tname);
    }
  }

  $tname = $MTYPE_PREFIX . $mtype_id[$type_count];
  $found = &is_in_set($entries, $mtype_id[$type_count]);
  printf(CFILET "  %d  /* %s */\n", $found, $tname);

  printf(CFILET "};\n\n");
}

#
# makebasetypearray: change a type descriptor containing comma separated
# types, e.g. "i,F", into an array containing the equivalent base types, e.g.
# I J K L F.
#
# Uses the global associative array abbrevtype, which contains the mapping from
# types into basetypes, e.g. abbrevtype{"i"} -> I,J,K,L.

sub makebasetypearray {
  my(@x) = split(',', pop(@_)); # e.g. x might now contain i and F.
  my(%b);			# holds all the return basetypes.
  my($i);

  for ($i = 0; $i <= $#x; $i++) {
    if (defined($abbrevtype{$x[$i]})) {
      # type specified is actually a set of basetypes
      my(@entries) = split(",", $abbrevtype{$x[$i]});
      while($#entries >= 0) {
	$b{pop(@entries)} = 1;
      }
    }
    else {
      defined($basetype{$x[$i]}) || die "unknown type $x[$i]";
      $b{$x[$i]} = 1;
    }
  }

  sort bytypenumber keys(%b);
}

#
# Sort by type number
#
sub bytypenumber { $typeval{$a} <=> $typeval{$b}; }

sub bytypename { $a cmp $b; }

#
# given a string, decide how many tabs to use.  The first arg is the number
# of tabstops to go out to.  The second is how far out we've already gone.
# The third, if supplied, is the size of a string that follows before the
# tabbing
#

sub tabs {
  $#_ == 1 || $#_ == 2 || die "Bad number of args to tabs";

  my($tabstops) = $_[0];
  my($out) = $_[1] + (($#_ == 2) ? length($_[2]) : 0);
  my($nt) = $tabstops - int($out/8);

  $string = $nt <= 0 ? " " : ("\t" x $nt);
}

sub copyright_notice {
    my($FILE) = $_[0];

    printf($FILE "/*\n\n");

    printf($FILE "  Copyright (C) 2001 ST Microelectronics, Inc.  All Rights Reserved.\n\n");

    printf($FILE "  This program is free software; you can redistribute it and/or modify it\n");
    printf($FILE "  under the terms of version 2 of the GNU General Public License as\n");
    printf($FILE "  published by the Free Software Foundation.\n\n");

    printf($FILE "  This program is distributed in the hope that it would be useful, but\n");
    printf($FILE "  WITHOUT ANY WARRANTY; without even the implied warranty of\n");
    printf($FILE "  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n");  

    printf($FILE "  Further, this software is distributed without any warranty that it is\n");
    printf($FILE "  free of the rightful claim of any third person regarding infringement \n");
    printf($FILE "  or the like.  Any license provided herein, whether implied or \n");
    printf($FILE "  otherwise, applies only to this software file.  Patent licenses, if \n");
    printf($FILE "  any, provided herein do not apply to combinations of this program with \n");
    printf($FILE "  other software, or any other product whatsoever.\n\n");

    printf($FILE "  You should have received a copy of the GNU General Public License along\n");
    printf($FILE "  with this program; if not, write the Free Software Foundation, Inc., 59\n");
    printf($FILE "  Temple Place - Suite 330, Boston MA 02111-1307, USA.\n\n");

    printf($FILE "  Contact information:  ST Microelectronics, Inc., \n");
    printf($FILE "  address, or:\n\n");

    printf($FILE "  http://www.st.com\n\n");

    printf($FILE "  For further information regarding this notice, see:\n\n");

    printf($FILE "  http://mcdt home page\n\n");

    printf($FILE "*/\n\n");
}
