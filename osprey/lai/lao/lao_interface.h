

#define i386 1
#define linux 1
#define unix 1



#define Except_REQUIRE(t) 
#define Except_CHECK(t) 
typedef struct Memory_ *Memory;
typedef struct Label_ *Label;
typedef struct Symbol_ *Symbol;
typedef struct Temporary_ *Temporary;
typedef struct Operation_ *Operation;
typedef struct BasicBlock_ *BasicBlock;
typedef struct LoopScope_ *LoopScope;


/*
 * !!!!	MDS.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

//
#define ECL_INCLUDED 


/*
 * This file contains all the definitions that are generated by configure
 * and must be visible in the installed version
 */

#define ECL_NTRACE_UNDEF 1
#define ECL_NDTOR_UNDEF 1
#define ECL_NXMLIO_UNDEF 1

#define ECL_DEBUG 1


/*
 * Set ECL_OPTIMIZE according to __OPTIMIZE__ (defined by gcc and icc) and NDEBUG.
 */
#define ECL_OPTIMIZE 0







#define MDS_FAMILY "arm"
#define MDS_FAMILY_arm 1


//






/*
 * Platform --	Enumeration.
 */
typedef uint8_t Platform;
extern const int Platform__COUNT;
#define Platform__UNDEF 0

/*
 * Resource --	Enumeration.
 */
typedef uint8_t Resource;
extern const int Resource__COUNT;
#define Resource__FIXME 8
#define Resource__UNDEF 0
#define Resource__ISSUE 1

/*
 * Processor --	Enumeration.
 */
typedef uint8_t Processor;
extern const int Processor__COUNT;
#define Processor__UNDEF 0
#define Processor__DEFAULT 1

/*
 * Encoding --	Enumeration.
 */
typedef uint8_t Encoding;
extern const int Encoding__COUNT;
#define Encoding__UNDEF 0

#define Encoding_SIZE_MAX 4





/*
 * NativeType --	Enumeration.
 */
typedef uint8_t NativeType;
extern const int NativeType__COUNT;
#define NativeType__UNDEF 0

/*
 * StorageCell --	Enumeration.
 */
typedef uint8_t StorageCell;
extern const int StorageCell__COUNT;
extern const int StorageCell__Volatile;
extern const int StorageCell__Control;
extern const int StorageCell__Memory;
#define StorageCell__UNDEF 0

#define RegisterStorageCells_COUNT_MAX 32





/*
 * Register --	Enumeration.
 */
typedef uint8_t Register;
extern const int Register__COUNT;
#define Register__FIXME 128
#define Register__UNDEF 0
#define Register__Volatile (Register__COUNT + 0)
#define Register__Control (Register__COUNT + 1)
#define Register__Memory (Register__COUNT + 2)
#define Register__XCOUNT (Register__COUNT + 3)

#define RegisterSet_WORDTYPE uint32_t
#define RegisterList_COUNT_MAX 74





#define RegisterSet_WORDTYPE uint32_t
#define RegisterSet_WORDBITS (sizeof(RegisterSet_WORDTYPE)*8)
#define RegisterSet_MAJOR(member) ((Register)(member)/(RegisterSet_WORDBITS))
#define RegisterSet_MINOR(member) ((Register)(member)&(RegisterSet_WORDBITS - 1))
typedef uint32_t RegisterSetWord;

/*
 * RegFile --	Enumeration.
 */
typedef uint8_t RegFile;
extern const int RegFile__COUNT;
#define RegFile__FIXME 8
#define RegFile__UNDEF 0

/*
 * RegClass --	Enumeration.
 */
typedef uint8_t RegClass;
extern const int RegClass__COUNT;
#define RegClass__UNDEF 0

/*
 * RegMask --	Enumeration.
 */
typedef uint8_t RegMask;
extern const int RegMask__COUNT;
#define RegMask__UNDEF 0

/*
 * Modifier --	Enumeration.
 */
typedef uint8_t Modifier;
extern const int Modifier__COUNT;
#define Modifier__UNDEF 0

/*
 * ModifierMember --	Enumeration.
 */
typedef uint8_t ModifierMember;
extern const int ModifierMember__COUNT;
#define ModifierMember__UNDEF 0

/*
 * Relocation --	Enumeration.
 */
typedef uint8_t Relocation;
extern const int Relocation__COUNT;
#define Relocation__UNDEF 0

/*
 * Immediate --	Enumeration.
 */
typedef uint8_t Immediate;
extern const int Immediate__COUNT;
#define Immediate__UNDEF 0

#define ImmediateRelocations_COUNT_MAX 1





/*
 * Operand --	Enumeration.
 */
typedef uint8_t Operand;
extern const int Operand__COUNT;
#define Operand__UNDEF 0

#define Operands_COUNT_MAX 7
#define Operands_IMMEDIATE_COUNT_MAX 2
#define Operands_REGMASK_COUNT_MAX 1







/*
 * Operands --	Enumeration.
 */
typedef uint8_t Operands;
extern const int Operands__COUNT;
#define Operands__UNDEF 0

/*
 * Format --	Enumeration.
 */
typedef uint8_t Format;
extern const int Format__COUNT;
#define Format__UNDEF 0

/*
 * Syntax --	Enumeration.
 */
typedef uint8_t Syntax;
extern const int Syntax__COUNT;
#define Syntax__UNDEF 0

/*
 * Instance --	Enumeration.
 */
typedef uint16_t Instance;
extern const int Instance__COUNT;
#define Instance__UNDEF 0

/*
 * Operator --	Enumeration.
 */
typedef uint16_t Operator;
extern const int Operator__COUNT;
#define Operator__UNDEF 0
#define Operator_ENTRY 1
#define Operator_LABEL 2
#define Operator_FALL 3
#define Operator_LOOP 4
#define Operator_GOTO 5
#define Operator_GOTRUE 6
#define Operator_GOFALSE 7
#define Operator_JUMP 8
#define Operator_CALL 9
#define Operator_LINK 10
#define Operator_RETURN 11
#define Operator_PHI 12
#define Operator_PSI 13
#define Operator_SIGMA 14
#define Operator_KILL 15
#define Operator_PCOPY 16
#define Operator_ECOPY 17
#define Operator_LCOPY 18
#define Operator_COPY 19
#define Operator_SKIP 20
#define Operator_LNOT 21
#define Operator_BNOT 22
#define Operator_NEG 23
#define Operator_ADD 24
#define Operator_SUB 25
#define Operator_MUL 26
#define Operator_DIV 27
#define Operator_REM 28
#define Operator_SHL 29
#define Operator_ASHR 30
#define Operator_LSHR 31
#define Operator_LAND 32
#define Operator_LIOR 33
#define Operator_LXOR 34
#define Operator_BAND 35
#define Operator_BIOR 36
#define Operator_BXOR 37
#define Operator_MIN 38
#define Operator_MAX 39
#define Operator_SELECT 40
#define Operator_APPLY 41

#define OperatorParameterArray_COUNT_MAX 11
#define OperatorParameter_CONFLICTS_COUNT_MAX 4






/*
 * Bundling --	Enumeration.
 */
typedef uint8_t Bundling;
extern const int Bundling__COUNT;
#define Bundling__UNDEF 0
#define Bundling__BIAS 1

/*
 * Template --	Enumeration.
 */
typedef uint16_t Template;
extern const int Template__COUNT;
#define Template__UNDEF 0

/*
 * Bundle --	Enumeration.
 */
typedef uint16_t Bundle;
extern const int Bundle__COUNT;
#define Bundle__UNDEF 0

#define Bundle_ISSUE_MAX 0
#define BundleMatch_COUNT_MAX 0






/*
 * Reservation --	Enumeration.
 */
typedef uint8_t Reservation;
extern const int Reservation__COUNT;
#define Reservation__FIXME 32
#define Reservation__UNDEF 0

#define Reservation_COLUMNS_COUNT_MAX 6





/*
 * Scheduling --	Enumeration.
 */
typedef uint8_t Scheduling;
extern const int Scheduling__COUNT;
#define Scheduling__UNDEF 0

/*
 * Convention --	Enumeration.
 */
typedef uint8_t Convention;
extern const int Convention__COUNT;
#define Convention__UNDEF 0
#define Convention__DEFAULT 1

//



/*
 * !!!!	Platform.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Platform_name_ --	Names for the Platform enumeration.
 */
extern const char *
Platform_name_(Platform THIS);

/*
 * Platform_charWidth --	This Platform charWidth.
 */
int
Platform_charWidth(Platform THIS);

/*
 * Platform_addrWidth --	This Platform addrWidth.
 */
int
Platform_addrWidth(Platform THIS);

//
typedef enum {
  PlatformEndian__UNDEF,
  PlatformEndian_Little,
  PlatformEndian_Big,
  PlatformEndian__
} enum_PlatformEndian;
typedef uint8_t PlatformEndian;

/*
 * Platform_endian --	Endian of THIS Platform.
 */
PlatformEndian
Platform_endian(Platform THIS);






/*
 * !!!!	Resource.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Pack a vector of Resource__ units in a word.
 */
union ResourceVector_ {
  uint8_t UNITS[sizeof(uint64_t)/sizeof(uint8_t)];
  uint64_t PACKED;
};
typedef union ResourceVector_ ResourceVector_, *ResourceVector;
typedef const union ResourceVector_ *const_ResourceVector;
typedef union ResourceVector_ *restrict restrict_ResourceVector;
#define ResourceVector_UNITS(THIS) ((THIS)->UNITS)
#define ResourceVector_PACKED(THIS) ((THIS)->PACKED)
#define ResourceVector__PACKED(THIS) (&(THIS)->PACKED)

/*
 * ResourceVector_clear --	Clear THIS ResourceVector.
 */




static inline void
ResourceVector_clear(ResourceVector THIS) {
  *(&(THIS)->PACKED) = 0;
}


/*
 * ResourceVector_accumulate --	Accumulate =that= ResourceVector to =THIS= ResourceVector.
 */




static inline void
ResourceVector_accumulate(ResourceVector THIS, const_ResourceVector that)
{
  *(&(THIS)->PACKED) += ((that)->PACKED);
}


/*
 * ResourceVector_accept --	True if =THIS= + =increase= <= =limit=.
 */






static inline bool
ResourceVector_accept(const_ResourceVector THIS,
                      const_ResourceVector increase,
                      const_ResourceVector limit)
{
  uint64_t mask = 0x8080808080808080ULL;
  uint64_t x = ((limit)->PACKED);
  uint64_t y = ((THIS)->PACKED) + ((increase)->PACKED);
  x |= mask; // Set high bit of each unit.
  x -= y; // Carry does not propagate across units.
  x &= mask; // Grab high bits after substract.
  return x == mask; // High bit change means THIS + increase > limit.
}


/*
 * ResourceVector_maxMerge --	Max-merge =that= ResourceVector into =THIS= ResourceVector.
 *
 * Return:	true if the merge changed =THIS= else false.
 */




static inline bool
ResourceVector_maxMerge(ResourceVector THIS, const_ResourceVector that)
{
  uint64_t mask = 0x8080808080808080ULL;
  uint64_t x = ((that)->PACKED);
  uint64_t y = ((THIS)->PACKED);
  uint64_t z = x, t = 0;
  z |= mask; // Set high bit of each unit.
  z -= y; // Carry does not propagate across units.
  z ^= mask; // z = (that - THIS).
  t = mask & z; // Grab the sign bits of (that - THIS).
  t = (t << 1) - (t >> 7); // All ones if (that < THIS) else all zeros.
  z &= ~t; // z = MAX(that - THIS, 0).
  y += z; // y = MAX(that, THIS).
  *(&(THIS)->PACKED) = y;
  return z != 0;
}


/*
 * ResourceTable --	Maintains the Resource state for Instruction scheduling.
 *
 * Each VECTORS element is the resource usage for a date (modulo ResourceTable_CLP2HORIZON).
 * The dates considered are never earlier than the ResourceTable WINDOWSTART.
 */
struct ResourceTable_ {
  //@args	Processor processor, int windowSize
  uint8_t WINDOWSIZE;
  uint16_t CLP2HORIZON;
  int16_t WINDOWSTART;
  const_ResourceVector AVAILABILITY;
  //@access VECTORS	(ResourceVector_ *)((ResourceTable)(THIS) + 1)
};
typedef struct ResourceTable_ ResourceTable_, *ResourceTable;
typedef const struct ResourceTable_ *const_ResourceTable;
typedef struct ResourceTable_ * restrict_ResourceTable;

extern ResourceTable
ResourceTable_Ctor(ResourceTable THIS, Processor processor, int windowSize);

extern ResourceTable
ResourceTable_Copy(ResourceTable THIS, const_ResourceTable that);

extern void
ResourceTable_Dtor(ResourceTable THIS);

extern size_t
ResourceTable_Size(Processor processor, int windowSize);

#define ResourceTable_WINDOWSIZE(THIS) ((THIS)->WINDOWSIZE)
#define ResourceTable__WINDOWSIZE(THIS) (&(THIS)->WINDOWSIZE)
#define ResourceTable_CLP2HORIZON(THIS) ((THIS)->CLP2HORIZON)
#define ResourceTable__CLP2HORIZON(THIS) (&(THIS)->CLP2HORIZON)
#define ResourceTable_WINDOWSTART(THIS) ((THIS)->WINDOWSTART)
#define ResourceTable__WINDOWSTART(THIS) (&(THIS)->WINDOWSTART)
#define ResourceTable_AVAILABILITY(THIS) ((THIS)->AVAILABILITY)
#define ResourceTable__AVAILABILITY(THIS) (&(THIS)->AVAILABILITY)
#define ResourceTable_VECTORS(THIS) ((ResourceVector_ *)((ResourceTable)(THIS) + 1))


//
void
ResourceTable_reset(ResourceTable THIS, int windowStart);

//
bool
ResourceTable_fitReservation(ResourceTable THIS, Reservation reservation, int startDate);

//
bool
ResourceTable_isFull(const_ResourceTable THIS, const_ResourceVector column, int startDate);

//
int
ResourceTable_tryReservation(ResourceTable THIS, Reservation reservation, int startDate);

//
void
ResourceTable_addReservation(ResourceTable THIS, Reservation reservation, int startDate);

//
void
ResourceTable_advance(ResourceTable THIS, int newDate);

//
bool
ResourceTable_merge(ResourceTable THIS, const_ResourceTable that, int delay);

//
bool
ResourceTable_pretty(const_ResourceTable THIS, FILE *file);

/*
 * Resource_name_ --	Names for the Resource enumeration.
 */
extern const char *
Resource_name_(Resource THIS);
extern const char *
Resource_name(Resource THIS);

/*
 * Resource_availability --	This Resource availability units for a Processor.
 */
int
Resource_availability(Resource THIS, Processor processor);






/*
 * !!!!	Processor.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Processor_name_ --	Names for the Processor enumeration.
 */
extern const char *
Processor_name_(Processor THIS);

/*
 * Processor_minTaken --	This Processor minTaken.
 */
int
Processor_minTaken(Processor THIS);

/*
 * Processor_maxTakenCost --	This processor maximum branch taken cost.
 */
int
Processor_maxTakenCost(Processor THIS);

/*
 * Processor_interlocks --	Whether THIS Processor interlocks registers.
 */
bool
Processor_interlocks(Processor THIS);

/*
 * Processor_availability --	This Processor availability of Resource(s).
 */
const_ResourceVector
Processor_availability(Processor THIS);

//
bool
Processor_DTD(FILE *file);

//
bool
Processor_XML(FILE *file);






/*
 * !!!!	Encoding.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Expand MDS-generated macros that typedef PlatformInt and PlatformUInt.
 */
typedef int32_t PlatformInt; //FIXME! PlatformInt_TYPEDEF
typedef uint32_t PlatformUInt; //FIXME! PlatformUInt_TYPEDEF

/*
 * Encoding_name_ --	Names for the Encoding enumeration.
 */
extern const char *
Encoding_name_(Encoding THIS);

/*
 * Encoding_processor --	This Encoding Processor.
 */
Processor
Encoding_processor(Encoding THIS);

/*
 * Encoding_wordCount --	This Encoding word count.
 */
uint8_t
Encoding_wordCount(Encoding THIS);

/*
 * Encoding_wordSize --	This Encoding word size.
 */
uint8_t
Encoding_wordSize(Encoding THIS);

/*
 * Encoding_decode --	This Encoding decode function.
 */
typedef Instance (*EncodingDecode)(const void *buffer);
EncodingDecode
Encoding_decode(Encoding THIS);






/*
 * !!!!	NativeType.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * NativeType_name_ --	Names for the NativeType enumeration.
 */
extern const char *
NativeType_name_(NativeType THIS);

/*
 * NativeType_format --	This NativeType bit syntax.
 */
const char *
NativeType_format(NativeType THIS);

/*
 * NativeType_width --	This NativeType bit width.
 */
unsigned
NativeType_width(NativeType THIS);

/*
 * NativeType_signed --	This NativeType is signed.
 */
bool
NativeType_signed(NativeType THIS);

/*
 * NativeType_sizeOf --	This NativeType size in bytes when stored to memory.
 */
unsigned
NativeType_sizeOf(NativeType THIS);

/*
 * NativeType_align --	This NativeType Alignment Base
 */
unsigned
NativeType_align(NativeType THIS);

/*
 * NativeType_slice --	This NativeType slice width in bits.
 */
unsigned
NativeType_slice(NativeType THIS);






/*
 * !!!!	Storage.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * StorageCell_name_ --	Names for the StorageCell enumeration.
 */
extern const char *
StorageCell_name_(StorageCell THIS);
extern const char *
StorageCell_name(StorageCell THIS);






/*
 * !!!!	Register.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Register_name_ --	Names for the Register enumeration.
 */
extern const char *
Register_name_(Register THIS);
extern const char *
Register_name(Register THIS);

/*
 * Register_names --	The names of THIS Register.
 */
const char **
Register_names(Register THIS);

/*
 * Register_regFile --	The RegFile of THIS Register.
 */
RegFile
Register_regFile(Register THIS);

/*
 * Register_isWired --	True if THIS Register is wired.
 */
bool
Register_isWired(Register THIS);

/*
 * RegisterStorageCells --	Sequence of StorageCell(s).
 */
struct RegisterStorageCells_ {
  int8_t COUNT;
  StorageCell ITEMS[32];
};
typedef struct RegisterStorageCells_ RegisterStorageCells_, *RegisterStorageCells;
typedef const struct RegisterStorageCells_ *const_RegisterStorageCells;
typedef struct RegisterStorageCells_ * restrict_RegisterStorageCells;

#define RegisterStorageCells_COUNT(THIS) ((THIS)->COUNT)
#define RegisterStorageCells__COUNT(THIS) (&(THIS)->COUNT)
#define RegisterStorageCells_ITEMS(THIS) ((THIS)->ITEMS)
#define RegisterStorageCells__ITEMS(THIS) (&(THIS)->ITEMS)


/*
 * RegisterStorageCells_count --	Count of StorageCell(s) in THIS RegisterStorageCells.
 */
static inline int
RegisterStorageCells_count(const_RegisterStorageCells THIS)
{
  return ((THIS)->COUNT);
}

/*
 * RegisterStorageCells_items --	StorageCell(s) in THIS RegisterStorageCells.
 */
static inline const StorageCell *
RegisterStorageCells_items(const_RegisterStorageCells THIS)
{
  return ((THIS)->ITEMS);
}

/*
 * RegisterStorageCells_access --	Access a StorageCell in THIS RegisterStorageCells.
 */
static inline StorageCell
RegisterStorageCells_access(const_RegisterStorageCells THIS, int index)
{
  ;
  return (StorageCell)((THIS)->ITEMS)[index];
}

/*
 * RegisterStorageCells_FOREACH_StorageCell --	Iterate THIS RegisterStorageCells.
 */
#define RegisterStorageCells_FOREACH_StorageCell(THIS,cell) { const StorageCell *RegisterStorageCells_ITEMS = RegisterStorageCells_items(THIS); int RegisterStorageCells_COUNT = RegisterStorageCells_count(THIS); int RegisterStorageCells_INDEX = 0; for (; RegisterStorageCells_INDEX < RegisterStorageCells_COUNT; RegisterStorageCells_INDEX++) { int cell = RegisterStorageCells_ITEMS[RegisterStorageCells_INDEX];





#define RegisterStorageCells_ENDEACH_StorageCell } }



/*
 * Register_storageCells --	This Register RegisterStorageCells.
 */
const_RegisterStorageCells
Register_storageCells(Register THIS);

/*
 * Register_minReadStage --	This Register minimum read stage for each Processor.
 */
int
Register_minReadStage(Register THIS, Processor processor);

/*
 * RegisterList --	Non-mutable list of Register(s).
 */
struct RegisterList_ {
  //@args
  uint8_t COUNT;
  Register ITEMS[74];
};
typedef struct RegisterList_ RegisterList_, *RegisterList;
typedef const struct RegisterList_ *const_RegisterList;
typedef struct RegisterList_ * restrict_RegisterList;

extern RegisterList
RegisterList_Ctor(RegisterList THIS);

extern RegisterList
RegisterList_Copy(RegisterList THIS, const_RegisterList that);

extern void
RegisterList_Dtor(RegisterList THIS);

extern size_t
RegisterList_Size(void);

#define RegisterList_COUNT(THIS) ((THIS)->COUNT)
#define RegisterList__COUNT(THIS) (&(THIS)->COUNT)
#define RegisterList_ITEMS(THIS) ((THIS)->ITEMS)
#define RegisterList__ITEMS(THIS) (&(THIS)->ITEMS)


/*
 * RegisterList_count --	Count the Register(s) in THIS RegisterList.
 */
static inline int
RegisterList_count(const_RegisterList THIS)
{
  return ((THIS)->COUNT);
}

/*
 * RegisterList_first --	First item of the RegisterList.
 * Return:       The first Register.
 */
static inline Register
RegisterList_first(const_RegisterList THIS)
{
  ;
  return (Register)((THIS)->ITEMS)[0];
}

/*
 * RegisterList_access --	Access the RegisterList by index.
 * index:        The index.
 * Return:       Corresponding Register.
 */
static inline Register
RegisterList_access(const_RegisterList THIS, int32_t index)
{
  ;
  return (Register)((THIS)->ITEMS)[index];
}

/*
 * RegisterList_items --	For use by RegisterList_FOREACH_Register.
 */
static inline const Register *
RegisterList_items(const_RegisterList THIS)
{
  return ((THIS)->ITEMS);
}

/*
 * RegisterList_FOREACH_Register --	Iterate over THIS RegisterList Register(s).
 */
#define RegisterList_FOREACH_Register(THIS,registre) { const Register *RegisterList_ITEMS = RegisterList_items(THIS); int RegisterList_COUNT = RegisterList_count(THIS), RegisterList_INDEX = 0; for (; RegisterList_INDEX < RegisterList_COUNT; RegisterList_INDEX++) { int registre = RegisterList_ITEMS[RegisterList_INDEX];




#define RegisterList_ENDEACH_Register } }



/*
 * RegisterList_contains --	True if THIS RegisterList contains the given Register.
 */
bool
RegisterList_contains(const_RegisterList THIS, Register member);

/*
 * Register_isLifetime --	Test if THIS Register Lifetime should be minimized.
 */
bool
Register_isLifetime(Register THIS, Convention convention);

/*
 * RegisterSet --	Set of architectural registers.
 *
 * See the CCL/RegisterSet.xcc code to add RegisterSet methods.
 */
struct RegisterSet_ {
  //@args
  RegisterSetWord WORDS[(((Register)(104)/((sizeof(uint32_t)*8))) + 1)];
};
typedef struct RegisterSet_ RegisterSet_, *RegisterSet;
typedef const struct RegisterSet_ *const_RegisterSet;
typedef struct RegisterSet_ * restrict_RegisterSet;

extern RegisterSet
RegisterSet_Ctor(RegisterSet THIS);

extern RegisterSet
RegisterSet_Copy(RegisterSet THIS, const_RegisterSet that);

extern void
RegisterSet_Dtor(RegisterSet THIS);

extern size_t
RegisterSet_Size(void);

#define RegisterSet_WORDS(THIS) ((THIS)->WORDS)
#define RegisterSet__WORDS(THIS) (&(THIS)->WORDS)


/*
 * RegisterSet_words --	Return the RegisterSet word array.
 */
static inline const RegisterSetWord *
RegisterSet_words(const_RegisterSet THIS)
{
  return ((THIS)->WORDS);
}

/*
 * RegisterSet_isEmpty --	True iff THIS RegisterSet is empty.
 */
bool
RegisterSet_isEmpty(const_RegisterSet THIS);

/*
 * RegisterSet_count --	Count members contained in the RegisterSet.
 * Return:	The count of members in THIS RegisterSet.
 */
int
RegisterSet_count(const_RegisterSet THIS);

/*
 * RegisterSet_first --	First Register in THIS RegisterSet.
 */
Register
RegisterSet_first(const_RegisterSet THIS);

/*
 * RegisterSet_empty --	Empty THIS RegisterSet.
 */
void
RegisterSet_empty(RegisterSet THIS);

/*
 * RegisterSet_choose --	Choose and remove a member of the RegisterSet.
 *
 * Return:	Valid Register or Register_ if THIS RegisterSet is empty.
 */
Register
RegisterSet_choose(RegisterSet THIS);

/*
 * RegisterSet_nextMember --	Get the next Register of the RegisterSet.
 */
Register
RegisterSet_nextMember(const_RegisterSet THIS, Register member);

/*
 * RegisterSet_chooseFromLast --	Choose and remove a member of the RegisterSet
 *                               starting from the last_reg, e.g., if rn was
 *                               last used, rn+1 will be return if it is avaiable.
 *
 * Return:	Valid Register or Register_ if THIS RegisterSet is empty.
 */
Register
RegisterSet_chooseFromLast(RegisterSet set, Register last_reg);

/*
 * RegisterSet_contains --	Test a member for containment.
 * Return:	True if THIS RegisterSet contains member.
 */
bool
RegisterSet_contains(const_RegisterSet THIS, Register member);

/*
 * RegisterSet_insert --	Insert a member in THIS RegisterSet.
 * Return:	False iff member was already contained in THIS RegisterSet.
 */
bool
RegisterSet_insert(RegisterSet THIS, Register member);

/*
 * RegisterSet_remove --	Remove a member from THIS RegisterSet.
 * Return:	False iff member was not contained in THIS RegisterSet.
 */
bool
RegisterSet_remove(RegisterSet THIS, Register member);

/*
 * RegisterSet_equals --	Test for RegisterSet equality.
 */
bool
RegisterSet_equals(const_RegisterSet THIS, const_RegisterSet that);

/*
 * RegisterSet_union --	Union of THIS RegisterSet with that RegisterSet.
 */
void
RegisterSet_union(RegisterSet THIS, const_RegisterSet that);

/*
 * RegisterSet_inter --	Intersect THIS RegisterSet with that RegisterSet.
 */
void
RegisterSet_inter(RegisterSet THIS, const_RegisterSet that);

/*
 * RegisterSet_diff --	Remove that RegisterSet members from THIS RegisterSet.
 */
void
RegisterSet_diff(RegisterSet THIS, const_RegisterSet that);

/*
 * RegisterSet_FOREACH_Register --	Iterate over THIS RegisterSet registers
 */
#define RegisterSet_FOREACH_Register(THIS,registre) { int registre = Register__UNDEF; const_RegisterSet RegisterSet_THIS = (THIS); int RegisterSet_COUNT = RegisterSet_WORDCOUNT, RegisterSet_I, RegisterSet_J; for (RegisterSet_I = 0; RegisterSet_I < RegisterSet_COUNT; RegisterSet_I++) { RegisterSetWord RegisterSet_WORD = RegisterSet_WORDS(RegisterSet_THIS)[RegisterSet_I]; for (RegisterSet_J = 0; RegisterSet_J < RegisterSet_WORDBITS; RegisterSet_J++, RegisterSet_WORD >>= 1, registre++) { if (RegisterSet_WORD & 1) {
#define RegisterSet_ENDEACH_Register } } if (RegisterSet_J != RegisterSet_WORDBITS) break; } }






/*
 * RegisterSet_pretty --	Pretty-print THIS RegisterSet.
 */
bool
RegisterSet_pretty(const_RegisterSet THIS, FILE *file);

/*
 * RegisterAction --	Action on a Register for scoreboarding and bundling.
 */
struct RegisterAction_ {
  Register REGISTER; // Implicit register if rank == 0.
  RegClass REGCLASS; // RegClass if not implicit register.
  int8_t XXXINDEX; // Index of argument or result.
  int8_t RANK; // Operand rank in Operands.
  int8_t STAGE; // Access stage in the pipeline.
};
typedef struct RegisterAction_ RegisterAction_, *RegisterAction;
typedef const struct RegisterAction_ *const_RegisterAction;
typedef struct RegisterAction_ * restrict_RegisterAction;

#define RegisterAction_REGISTER(THIS) ((THIS)->REGISTER)
#define RegisterAction__REGISTER(THIS) (&(THIS)->REGISTER)
#define RegisterAction_REGCLASS(THIS) ((THIS)->REGCLASS)
#define RegisterAction__REGCLASS(THIS) (&(THIS)->REGCLASS)
#define RegisterAction_XXXINDEX(THIS) ((THIS)->XXXINDEX)
#define RegisterAction__XXXINDEX(THIS) (&(THIS)->XXXINDEX)
#define RegisterAction_RANK(THIS) ((THIS)->RANK)
#define RegisterAction__RANK(THIS) (&(THIS)->RANK)
#define RegisterAction_STAGE(THIS) ((THIS)->STAGE)
#define RegisterAction__STAGE(THIS) (&(THIS)->STAGE)


/*
 * RegisterAction_register --	Register of THIS RegisterAction.
 */
static inline Register
RegisterAction_register(const_RegisterAction THIS)
{
  return (Register)((THIS)->REGISTER);
}

/*
 * RegisterAction_regClass --	RegClass of THIS RegisterAction.
 */
static inline RegClass
RegisterAction_regClass(const_RegisterAction THIS)
{
  return (RegClass)((THIS)->REGCLASS);
}

/*
 * RegisterAction_xxxIndex --	Index of argument or result OperatorParameter(s).
 */
static inline int
RegisterAction_xxxIndex(const_RegisterAction THIS)
{
  return ((THIS)->XXXINDEX);
}

/*
 * RegisterAction_rank --	Rank of THIS RegisterAction in the Instance Operand list.
 *
 * Return:	0 if the RegisterAction has no corresponding Operand.
 */
static inline int
RegisterAction_rank(const_RegisterAction THIS)
{
  return ((THIS)->RANK);
}

/*
 * RegisterAction_stage --	The pipeline stage of THIS RegisterAction.
 */
static inline int
RegisterAction_stage(const_RegisterAction THIS)
{
  return ((THIS)->STAGE);
}

/*
 * RegisterAction_setStage --	Set the pipeline stage of THIS RegisterAction.
 */
static inline void
RegisterAction_setStage(RegisterAction THIS, int stage)
{
  *(&(THIS)->STAGE) = stage;
}

/*
 * RegisterActionArray --	Array of RegisterAction(s).
 */
struct RegisterActionArray_ {
  uint8_t READCOUNT; // Count of Read RegisterAction(s).
  uint8_t READSTART; // Start index of variant Read RegisterAction(s).
  uint8_t WRITECOUNT; // Count of Write RegisterAction(s).
  uint8_t WRITESTART; // Start index of variant Write RegisterAction(s).
  RegisterAction_ *ITEMS; // This RegisterActionArray items.
};
typedef struct RegisterActionArray_ RegisterActionArray_, *RegisterActionArray;
typedef const struct RegisterActionArray_ *const_RegisterActionArray;
typedef struct RegisterActionArray_ * restrict_RegisterActionArray;

#define RegisterActionArray_READCOUNT(THIS) ((THIS)->READCOUNT)
#define RegisterActionArray__READCOUNT(THIS) (&(THIS)->READCOUNT)
#define RegisterActionArray_READSTART(THIS) ((THIS)->READSTART)
#define RegisterActionArray__READSTART(THIS) (&(THIS)->READSTART)
#define RegisterActionArray_WRITECOUNT(THIS) ((THIS)->WRITECOUNT)
#define RegisterActionArray__WRITECOUNT(THIS) (&(THIS)->WRITECOUNT)
#define RegisterActionArray_WRITESTART(THIS) ((THIS)->WRITESTART)
#define RegisterActionArray__WRITESTART(THIS) (&(THIS)->WRITESTART)
#define RegisterActionArray_ITEMS(THIS) ((THIS)->ITEMS)
#define RegisterActionArray__ITEMS(THIS) (&(THIS)->ITEMS)


/*
 * RegisterActionArray_readCount --	Count of Read RegisterAction(s).
 */
static inline int
RegisterActionArray_readCount(const_RegisterActionArray THIS)
{
  return ((THIS)->READCOUNT);
}

/*
 * RegisterActionArray_readStart --	Start index of variant Read RegisterAction(s).
 */
static inline int
RegisterActionArray_readStart(const_RegisterActionArray THIS)
{
  return ((THIS)->READSTART);
}

/*
 * RegisterActionArray_writeCount --	Count of Write RegisterAction(s).
 */
static inline int
RegisterActionArray_writeCount(const_RegisterActionArray THIS)
{
  return ((THIS)->WRITECOUNT);
}

/*
 * RegisterActionArray_writeStart --	Start index of variant Write RegisterAction(s).
 */
static inline int
RegisterActionArray_writeStart(const_RegisterActionArray THIS)
{
  return ((THIS)->WRITESTART);
}

/*
 * RegisterActionArray_count --	Count of Read and Write RegisterAction(s).
 */
static inline int
RegisterActionArray_count(const_RegisterActionArray THIS)
{
  return ((THIS)->READCOUNT) + ((THIS)->WRITECOUNT);
}

/*
 * RegisterActionArray_readActions --	THIS RegisterActionArray read RegisterAction(s).
 */
static inline const RegisterAction_ *
RegisterActionArray_readActions(const_RegisterActionArray THIS)
{
  return ((THIS)->ITEMS) + 0;
}

/*
 * RegisterActionArray_writeActions --	THIS RegisterActionArray write RegisterAction(s).
 */
static inline const RegisterAction_ *
RegisterActionArray_writeActions(const_RegisterActionArray THIS)
{
  return ((THIS)->ITEMS) + ((THIS)->READCOUNT);
}

/*
 * RegisterActionArray_items --	For use by RegisterActionArray_FOREACH_RegisterAction.
 */
static inline const RegisterAction_ *
RegisterActionArray_items(const_RegisterActionArray THIS)
{
  return ((THIS)->ITEMS);
}

/*
 * RegisterActionArray_FOREACH_RegisterAction --	Iterate over THIS RegisterActionArray RegisterAction(s).
 */
#define RegisterActionArray_FOREACH_RegisterAction(THIS,action) { const RegisterAction_ *RegisterActionArray_ITEMS = RegisterActionArray_items(THIS); int RegisterActionArray_COUNT = RegisterActionArray_count(THIS); int RegisterActionArray_INDEX = 0; for (; RegisterActionArray_INDEX < RegisterActionArray_COUNT; RegisterActionArray_INDEX++) { const_RegisterAction action = RegisterActionArray_ITEMS + RegisterActionArray_INDEX;







#define RegisterActionArray_ENDEACH_RegisterAction } }



/*
 * RegisterActionArray_FORREAD_RegisterAction --	Iterate over THIS RegisterActionArray Read RegisterAction(s).
 */
#define RegisterActionArray_FORREAD_RegisterAction(THIS,action) { const RegisterAction_ *RegisterActionArray_ITEMS = RegisterActionArray_items(THIS); int RegisterActionArray_READCOUNT = RegisterActionArray_readCount(THIS); int RegisterActionArray_INDEX = 0; for (; RegisterActionArray_INDEX < RegisterActionArray_READCOUNT; RegisterActionArray_INDEX++) { const_RegisterAction action = RegisterActionArray_ITEMS + RegisterActionArray_INDEX;







#define RegisterActionArray_ENDREAD_RegisterAction } }



/*
 * RegisterActionArray_FORWRITE_RegisterAction --	Iterate over THIS RegisterActionArray Write RegisterAction(s).
 */
#define RegisterActionArray_FORWRITE_RegisterAction(THIS,action) { const RegisterAction_ *RegisterActionArray_ITEMS = RegisterActionArray_items(THIS); int RegisterActionArray_READCOUNT = RegisterActionArray_readCount(THIS); int RegisterActionArray_COUNT = RegisterActionArray_count(THIS); int RegisterActionArray_INDEX = RegisterActionArray_READCOUNT; for (; RegisterActionArray_INDEX < RegisterActionArray_COUNT; RegisterActionArray_INDEX++) { const_RegisterAction action = RegisterActionArray_ITEMS + RegisterActionArray_INDEX;
#define RegisterActionArray_ENDWRITE_RegisterAction } }



//
bool
Register_DTD(FILE *file);

//
bool
Register_XML(FILE *file);






/*
 * !!!!	RegFile.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * RegFile_name_ --	Names for the RegFile enumeration.
 */
extern const char *
RegFile_name_(RegFile THIS);
extern const char *
RegFile_name(RegFile THIS);

/*
 * RegFile_width --	This RegFile Width attribute.
 */
unsigned
RegFile_width(RegFile THIS);

/*
 * RegFile_getNativeType --	Return the default NativeType for THIS RegFile.
 * If THIS regFile has no associated storage type, return NativeType_.
 */
NativeType
RegFile_getNativeType(RegFile THIS);

/*
 * RegFile_lowRegister --	This RegFile low Register.
 */
Register
RegFile_lowRegister(RegFile THIS);

/*
 * RegFile_highRegister --	This RegFile high Register.
 */
Register
RegFile_highRegister(RegFile THIS);

/*
 * RegFile_FOREACH_Register --	Iterate in THIS RegFile Registers
 */
#define RegFile_FOREACH_Register(THIS,reg) { int RegFile_LOWREGISTER = RegFile_lowRegister(THIS), reg; int RegFile_HIGHREGISTER = RegFile_highRegister(THIS); for (reg = RegFile_LOWREGISTER; reg <= RegFile_HIGHREGISTER; reg++) {



#define RegFile_ENDEACH_Register } }



/*
 * RegFile_registerSet --	A RegisterSet with the members of THIS RegFile.
 */
const_RegisterSet
RegFile_registerSet(RegFile THIS);

//
bool
RegFile_DTD(FILE *file);

//
bool
RegFile_XML(FILE *file);






/*
 * !!!!	RegClass.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * RegClass_name_ --	Names for the RegClass enumeration.
 */
extern const char *
RegClass_name_(RegClass THIS);

/*
 * RegClass_regFile --	The RegFile THIS RegClass belongs to.
 */
RegFile
RegClass_regFile(RegClass THIS);

/*
 * RegClass_registerList --	This RegClass Register(s) as a RegisterList.
 */
const_RegisterList
RegClass_registerList(RegClass THIS);
#define RegClass_firstRegister(THIS) RegisterList_first(RegClass_registerList(THIS))
#define RegClass_lastRegister(THIS) RegisterList_last(RegClass_registerList(THIS))

/*
 * RegClass_registerSet --	This RegClass Register(s) as a RegisterSet.
 */
const_RegisterSet
RegClass_registerSet(RegClass THIS);

/*
 * RegClass_minReadStage --	This RegClass minimum read stage for each Processor.
 */
int
RegClass_minReadStage(RegClass THIS, Processor processor);






/*
 * !!!!	RegMask.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * RegMask_name_ --	Names for the RegMask enumeration.
 */
extern const char *
RegMask_name_(RegMask THIS);

/*
 * RegMask_registerList --	This RegMask Register(s) as a RegisterList.
 */
const_RegisterList
RegMask_registerList(RegMask THIS);

/*
 * RegMask_regFile --	The RegFile THIS RegMask belongs to.
 */
RegFile
RegMask_regFile(RegMask THIS);

/*
 * RegMask_registerSet --	This RegMask Register(s) as a RegisterSet.
 */
const_RegisterSet
RegMask_registerSet(RegMask THIS);






/*
 * !!!!	Modifier.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 * Stefan Freudenberger (Stefan.Freudenberger@st.com)
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Modifier_name_ --	Names for the Modifier enumeration.
 */
extern const char *
Modifier_name_(Modifier THIS);

/*
 * Modifier_memberNames --	The member names of THIS Modifier.
 */
const char **
Modifier_memberNames(Modifier THIS);

/*
 * ModifierMember_name_ --	Names for the ModifierMember enumeration.
 */
extern const char *
ModifierMember_name_(ModifierMember THIS);

/*
 * ModifierMember_complement --	Complement the condition of THIS ModifierMember.
 */
ModifierMember
ModifierMember_complement(ModifierMember THIS);

/*
 * !!!! arm-Modifier.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 * Stefan Freudenberger (Stefan.Freudenberger@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */






/*
 * !!!!	Relocation.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Relocation_name_ --	Names for the Relocation enumeration.
 */
extern const char *
Relocation_name_(Relocation THIS);

/*
 * RelocationRelative --	Enumeration for the Relocation_relative values.
 */
typedef enum {
  RelocationRelative__UNDEF,
  RelocationRelative_PC,
  RelocationRelative_GP,
} enum_RelocationRelative;
typedef uint8_t RelocationRelative;
#define Relocation_isRelativePC(THIS) (Relocation_relative(THIS) == RelocationRelative_PC)
#define Relocation_isRelativeGP(THIS) (Relocation_relative(THIS) == RelocationRelative_GP)

/*
 * Relocation_relative --	This Relocation RelocationRelative.
 */
RelocationRelative
Relocation_relative(Relocation THIS);

//
bool
Relocation_DTD(FILE *file);

//
bool
Relocation_XML(FILE *file);






/*
 * !!!!	Immediate.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * ImmediateValue --	Type for the largest Immediate value.
 */
typedef int64_t ImmediateValue;

/*
 * ImmediateConstant --	Base class for decoded Immediate constants.
 */
struct ImmediateConstant_ {
  //@args	ImmediateValue value
  ImmediateValue VALUE; // Value of THIS ImmediateConstant once resolved.
};
typedef struct ImmediateConstant_ ImmediateConstant_, *ImmediateConstant;
typedef const struct ImmediateConstant_ *const_ImmediateConstant;
typedef struct ImmediateConstant_ * restrict_ImmediateConstant;

extern ImmediateConstant
ImmediateConstant_Ctor(ImmediateConstant THIS, ImmediateValue value);

extern ImmediateConstant
ImmediateConstant_Copy(ImmediateConstant THIS, const_ImmediateConstant that);

extern void
ImmediateConstant_Dtor(ImmediateConstant THIS);

extern size_t
ImmediateConstant_Size(ImmediateValue value);

#define ImmediateConstant_VALUE(THIS) ((THIS)->VALUE)
#define ImmediateConstant__VALUE(THIS) (&(THIS)->VALUE)


/*
 * Immediate_name_ --	Names for the Immediate enumeration.
 */
extern const char *
Immediate_name_(Immediate THIS);

/*
 * Immediate_minValue --	This Immediate MinValue attribute.
 */
int64_t
Immediate_minValue(Immediate THIS);

/*
 * Immediate_maxValue --	This Immediate MaxValue attribute.
 */
int64_t
Immediate_maxValue(Immediate THIS);

/*
 * ImmediateRelocations --	Sequence of Relocation(s).
 */
struct ImmediateRelocations_ {
  int8_t COUNT;
  Relocation ITEMS[1];
};
typedef struct ImmediateRelocations_ ImmediateRelocations_, *ImmediateRelocations;
typedef const struct ImmediateRelocations_ *const_ImmediateRelocations;
typedef struct ImmediateRelocations_ * restrict_ImmediateRelocations;

#define ImmediateRelocations_COUNT(THIS) ((THIS)->COUNT)
#define ImmediateRelocations__COUNT(THIS) (&(THIS)->COUNT)
#define ImmediateRelocations_ITEMS(THIS) ((THIS)->ITEMS)
#define ImmediateRelocations__ITEMS(THIS) (&(THIS)->ITEMS)


/*
 * ImmediateRelocations_count --	Count of Relocation(s) in THIS ImmediateRelocations.
 */
static inline int
ImmediateRelocations_count(const_ImmediateRelocations THIS)
{
  return ((THIS)->COUNT);
}

/*
 * ImmediateRelocations_items --	Relocation(s) in THIS ImmediateRelocations.
 */
static inline const Relocation *
ImmediateRelocations_items(const_ImmediateRelocations THIS)
{
  return ((THIS)->ITEMS);
}

/*
 * ImmediateRelocations_access --	Access a Relocation in THIS ImmediateRelocations.
 */
static inline Relocation
ImmediateRelocations_access(const_ImmediateRelocations THIS, int index)
{
  ;
  return (Relocation)((THIS)->ITEMS)[index];
}

/*
 * ImmediateRelocations_FOREACH_Relocation --	Iterate THIS ImmediateRelocations.
 */
#define ImmediateRelocations_FOREACH_Relocation(THIS,relocation) { const Relocation *ImmediateRelocations_ITEMS = ImmediateRelocations_items(THIS); int ImmediateRelocations_COUNT = ImmediateRelocations_count(THIS); int ImmediateRelocations_INDEX = 0; for (; ImmediateRelocations_INDEX < ImmediateRelocations_COUNT; ImmediateRelocations_INDEX++) { int relocation = ImmediateRelocations_ITEMS[ImmediateRelocations_INDEX];






#define ImmediateRelocations_ENDEACH_Relocation } }



/*
 * Immediate_relocations --	This Immediate Relocations.
 */
const_ImmediateRelocations
Immediate_relocations(Immediate THIS);

/*
 * Immediate_canEncode --	Check whether THIS Immediate can encode value.
 */
bool
Immediate_canEncode(Immediate THIS, int64_t value);






/*
 * !!!!	Operand.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

//
typedef PlatformUInt OperandEncoded;
typedef PlatformUInt OperandDecoded;

/*
 * Operand_name_ --	Names for the Operand enumeration.
 */
extern const char *
Operand_name_(Operand THIS);

//
typedef enum {
  OperandType_,
  OperandType_Register,
  OperandType_RegClass,
  OperandType_Immediate,
  OperandType_Modifier,
  OperandType_RegMask,
  OperandType__
} enum_OperandType;
typedef uint8_t OperandType;
extern const char *
OperandType_name_(OperandType THIS);

/*
 * Operand_type --	The OperandType of THIS Operand.
 */
OperandType
Operand_type(Operand THIS);

/*
 * Operand_enum --	The RegClass or Immediate or Modifier or Regmask of THIS Operand.
 */
int
Operand_enum(Operand THIS);

/*
 * Operand_modifier --	The Modifier of THIS Operand.
 */
Modifier
Operand_modifier(Operand THIS);

/*
 * Operand_immediate --	The Immediate of THIS Operand.
 */
Immediate
Operand_immediate(Operand THIS);

/*
 * Operand_regClass --	The RegClass of THIS Operand.
 */
RegClass
Operand_regClass(Operand THIS);

/*
 * Operand_regMask --	The RegMask of THIS Operand.
 */
RegMask
Operand_regMask(Operand THIS);

/*
 * Operand_encode --	This Operand encode function.
 */
typedef void (*OperandEncode)(OperandDecoded decoded, void *restrict opcodes);
OperandEncode
Operand_encode(Operand THIS);

/*
 * Operand_encodeImmediateValue --	Encode a ImmediateValue.
 */
static inline void
Operand_encodeImmediateValue(Operand THIS, ImmediateValue value, void *opcodes)
{
  (*Operand_encode(THIS))((OperandDecoded)(&value), opcodes);
}

/*
 * Operand_decode --	This Operand decode function.
 */
typedef void (*OperandDecode)(const void *restrict opcodes, void *restrict result);
OperandDecode
Operand_decode(Operand THIS);

/*
 * Operand_decodeImmediateValue --	Macro to decode an ImmediateConstant.
 */
#define Operand_decodeImmediateValue(operand,opcodes,value_ptr) (*Operand_decode(operand))(opcodes, (void *restrict)(value_ptr))


/*
 * OperandList --	Sequence of Operand(s).
 */
struct OperandList_ {
  uint8_t COUNT;
  Operand ITEMS[7];
};
typedef struct OperandList_ OperandList_, *OperandList;
typedef const struct OperandList_ *const_OperandList;
typedef struct OperandList_ * restrict_OperandList;

#define OperandList_COUNT(THIS) ((THIS)->COUNT)
#define OperandList__COUNT(THIS) (&(THIS)->COUNT)
#define OperandList_ITEMS(THIS) ((THIS)->ITEMS)
#define OperandList__ITEMS(THIS) (&(THIS)->ITEMS)


/*
 * OperandList_count --	Count the Operand(s) in THIS OperandList.
 */
static inline int
OperandList_count(const_OperandList THIS)
{
  return ((THIS)->COUNT);
}

/*
 * OperandList_access --	Access the Operand at the given index.
 */
static inline Operand
OperandList_access(const_OperandList THIS, int index)
{
  ;
  return (Operand)((THIS)->ITEMS)[index];
}

/*
 * OperandList_items --	For use by OperandList_FOREACH_Operand.
 */
static inline const Operand *
OperandList_items(const_OperandList THIS)
{
  return ((THIS)->ITEMS);
}

/*
 * OperandList_FOREACH_Operand --	Iterate over THIS OperandList Operand(s).
 */
#define OperandList_FOREACH_Operand(THIS,operand) { const Operand *OperandList_ITEMS = OperandList_items(THIS); int OperandList_COUNT = OperandList_count(THIS), OperandList_INDEX = 0; for (; OperandList_INDEX < OperandList_COUNT; OperandList_INDEX++) { int operand = OperandList_ITEMS[OperandList_INDEX];




#define OperandList_ENDEACH_Operand } }



/*
 * Operands_name_ --	Names for the Operands enumeration.
 */
extern const char *
Operands_name_(Operands THIS);

/*
 * Operands_operandList --	This Operands OperandList.
 */
const_OperandList
Operands_operandList(Operands THIS);

/*
 * Operands_FOREACH_Operand --	Iterate over THIS Operands Operand(s).
 */
#define Operands_FOREACH_Operand(THIS,operand) OperandList_FOREACH_Operand(Operands_operandList(THIS), operand) { int Operands_INDEX = OperandList_INDEX;


#define Operands_ENDEACH_Operand } OperandList_ENDEACH_Operand;


/*
 * Operands_count --	This Operands count of Operand(s).
 */
int
Operands_count(Operands THIS);

/*
 * Operands_access --	Access the Operand at the given index.
 */
Operand
Operands_access(Operands THIS, int index);

/*
 * OperandsBuffer --	Buffer used to encode or decode Operands.
 */
struct OperandsBuffer_ {
  //@args
  OperandDecoded DECODED[7];

  ImmediateConstant_ CONSTANTS[2];


  RegisterSet_ REGISTERSETS[1];

};
typedef struct OperandsBuffer_ OperandsBuffer_, *OperandsBuffer;
typedef const struct OperandsBuffer_ *const_OperandsBuffer;
typedef struct OperandsBuffer_ * restrict_OperandsBuffer;

extern OperandsBuffer
OperandsBuffer_Ctor(OperandsBuffer THIS);

extern OperandsBuffer
OperandsBuffer_Copy(OperandsBuffer THIS, const_OperandsBuffer that);

extern void
OperandsBuffer_Dtor(OperandsBuffer THIS);

extern size_t
OperandsBuffer_Size(void);

#define OperandsBuffer_DECODED(THIS) ((THIS)->DECODED)
#define OperandsBuffer__DECODED(THIS) (&(THIS)->DECODED)
#define OperandsBuffer_CONSTANTS(THIS) ((THIS)->CONSTANTS)
#define OperandsBuffer__CONSTANTS(THIS) (&(THIS)->CONSTANTS)
#define OperandsBuffer_REGISTERSETS(THIS) ((THIS)->REGISTERSETS)
#define OperandsBuffer__REGISTERSETS(THIS) (&(THIS)->REGISTERSETS)


/*
 * Operands_encode --	This Operands encode function.
 */
typedef void (*OperandsEncode)(const_OperandsBuffer buffer, void *restrict opcodes);
OperandsEncode
Operands_encode(Operands THIS);

/*
 * Operands_relocatableRank --	Rank of relocatable Immediate in THIS Operands.
 */
int
Operands_relocatableRank(Operands THIS);

/*
 * Operands_relocatableOperand --	Relocatable Operand in THIS Operands.
 */
Operand
Operands_relocatableOperand(Operands THIS);

/*
 * Operands_relocatableImmediate --	Relocatable Immediate in THIS Operands.
 */
Immediate
Operands_relocatableImmediate(Operands THIS);

//






/*
  Operands_decode -- This Operands decode function.
 */
typedef void (*OperandsDecode)(const void *opcodes, OperandsBuffer buffer);
OperandsDecode
Operands_decode(Operands THIS);

//

void
Decode_Operands_(const void *opcodes, OperandsBuffer buffer);







/*
 * !!!!	Format.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Format_name_ --	Names for the Format enumeration.
 */
extern const char *
Format_name_(Format THIS);






/*
 * !!!!	Syntax.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Syntax_name_ --	Names for the Syntax enumeration.
 */
extern const char *
Syntax_name_(Syntax THIS);






/*
 * !!!!	Instance.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Instance_name_ --	Names for the Instance enumeration.
 */
extern const char *
Instance_name_(Instance THIS);

/*
 * Instance_scheduling --	This Instance Scheduling class.
 */
Scheduling
Instance_scheduling(Instance THIS);

/*
 * Instance_encoding --	This Instance Encoding.
 */
Encoding
Instance_encoding(Instance THIS);

//
struct InstanceOpcodes_ {
  //@args	
  uint32_t WORDS[2];
};
typedef struct InstanceOpcodes_ InstanceOpcodes_, *InstanceOpcodes;
typedef const struct InstanceOpcodes_ *const_InstanceOpcodes;
typedef struct InstanceOpcodes_ * restrict_InstanceOpcodes;

extern InstanceOpcodes
InstanceOpcodes_Ctor(InstanceOpcodes THIS);

extern InstanceOpcodes
InstanceOpcodes_Copy(InstanceOpcodes THIS, const_InstanceOpcodes that);

extern void
InstanceOpcodes_Dtor(InstanceOpcodes THIS);

extern size_t
InstanceOpcodes_Size(void);

#define InstanceOpcodes_WORDS(THIS) ((THIS)->WORDS)
#define InstanceOpcodes__WORDS(THIS) (&(THIS)->WORDS)


/*
 * Instance_opcodes --	This Instance opcodes.
 */
const_InstanceOpcodes
Instance_opcodes(Instance THIS);

/*
 * Instance_operands --	This Instance Operands.
 */
Operands
Instance_operands(Instance THIS);

/*
 * Instance_increment --	This Instance PC Increment.
 */
int
Instance_increment(Instance THIS);

/*
 * Instance_mnemonic --	This Instance mnemonic string.
 */
const char *
Instance_mnemonic(Instance THIS);

/*
 * Instance_syntax --	This Instance syntax string.
 */
const char *
Instance_syntax(Instance THIS);

/*
 * Instance_unitCost --	This Instance unit cost estimate.
 */
int
Instance_unitCost(Instance THIS);

/*
 * Instance_actionArray --	This Instance RegisterActionArray.
 */
const_RegisterActionArray
Instance_actionArray(Instance THIS);

/*
 * Instance_operator --	This Instance Operator class.
 */
Operator
Instance_operator(Instance THIS);

/*
 * Instance_makeRegisterActionItems --	Make THIS Instance RegisterActionArray_ITEMS.
 *
 * Only used to replace the MDS-initialized ITEMS with a writeable copy for patching.
 */
RegisterAction_ *
Instance_makeRegisterActionItems(Instance THIS, Memory memory);

//
typedef enum {
  InstanceAttribute_Control,
  InstanceAttribute_MemoryRead,
  InstanceAttribute_MemoryWrite,
  InstanceAttribute_FixRegisterRAW,
} InstanceAttribute;
typedef uint8_t InstanceAttributes;

//
#define Instance_isControl(THIS) (Instance_attributes(THIS)>>InstanceAttribute_Control & 1)

#define Instance_isMemoryRead(THIS) (Instance_attributes(THIS)>>InstanceAttribute_MemoryRead & 1)

#define Instance_isMemoryWrite(THIS) (Instance_attributes(THIS)>>InstanceAttribute_MemoryWrite & 1)

#define Instance_isFixRegisterRAW(THIS) (Instance_attributes(THIS)>>InstanceAttribute_FixRegisterRAW & 1)


/*
 * Instance_attributes --	Access THIS Instance attributes.
 */
InstanceAttributes
Instance_attributes(Instance THIS);

//
unsigned
Instance_fixupRAW(Instance THIS, Instance that);

//
int
Instance_latencyRAW(Instance THIS, Instance that, StorageCell cell);

/*
 * !!!! arm-Instance.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 * Stefan Freudenberger (Stefan.Freudenberger@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */






/*
 * !!!!	Operator.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

//
typedef enum {
  OperatorParameterKind_Read,
  OperatorParameterKind_ReadCond,
  OperatorParameterKind_ReadPred,
  OperatorParameterKind_ReadBase,
  OperatorParameterKind_ReadOffset,
  OperatorParameterKind_ReadStored,
  OperatorParameterKind_ReadTarget,
  OperatorParameterKind_ReadLeft,
  OperatorParameterKind_ReadRight,
  OperatorParameterKind_ReadList,
  OperatorParameterKind_ReadMultiStored,
  OperatorParameterKind_Write,
  OperatorParameterKind_WriteList,
  OperatorParameterKind_WriteMulti,
  OperatorParameterKind__
} enum_OperatorParameterKind;
typedef uint8_t OperatorParameterKind;
extern const char *
OperatorParameterKind_name_(OperatorParameterKind THIS);

//
struct OperatorParameter_ {
  OperatorParameterKind KIND;
  //@access isRead	(OperatorParameter_kind(THIS) < OperatorParameterKind_Write)
  //@access isWrite	(OperatorParameter_kind(THIS) >= OperatorParameterKind_Write)
  int8_t RANK; // The rank of THIS OperatorParameter in the Operand list.
  OperandType TYPE; // The OperandType of THIS OperatorParameter.
  int8_t ENUM; // Modifier|Immediate|RegMask|RegClass|Register enum.
  int8_t SAME;
  int8_t COUNT;
  int8_t CONFLICTS[4];
};
typedef struct OperatorParameter_ OperatorParameter_, *OperatorParameter;
typedef const struct OperatorParameter_ *const_OperatorParameter;
typedef struct OperatorParameter_ * restrict_OperatorParameter;

#define OperatorParameter_KIND(THIS) ((THIS)->KIND)
#define OperatorParameter__KIND(THIS) (&(THIS)->KIND)
#define OperatorParameter_RANK(THIS) ((THIS)->RANK)
#define OperatorParameter__RANK(THIS) (&(THIS)->RANK)
#define OperatorParameter_TYPE(THIS) ((THIS)->TYPE)
#define OperatorParameter__TYPE(THIS) (&(THIS)->TYPE)
#define OperatorParameter_ENUM(THIS) ((THIS)->ENUM)
#define OperatorParameter__ENUM(THIS) (&(THIS)->ENUM)
#define OperatorParameter_SAME(THIS) ((THIS)->SAME)
#define OperatorParameter__SAME(THIS) (&(THIS)->SAME)
#define OperatorParameter_COUNT(THIS) ((THIS)->COUNT)
#define OperatorParameter__COUNT(THIS) (&(THIS)->COUNT)
#define OperatorParameter_CONFLICTS(THIS) ((THIS)->CONFLICTS)
#define OperatorParameter__CONFLICTS(THIS) (&(THIS)->CONFLICTS)
#define OperatorParameter_isRead(THIS) ((OperatorParameter_kind(THIS) < OperatorParameterKind_Write))
#define OperatorParameter_isWrite(THIS) ((OperatorParameter_kind(THIS) >= OperatorParameterKind_Write))


/*
 * OperatorParameter_kind --	OperatorParameterKind of THIS OperatorParameter.
 */
static inline OperatorParameterKind
OperatorParameter_kind(const_OperatorParameter THIS)
{
  return (OperatorParameterKind)((THIS)->KIND);
}

/*
 * OperatorParameter_rank --	Rank of THIS OperatorParameter in the Instance Operand list.
 * Return:	0 if the OperatorParameter has no corresponding Operand.
 */
static inline int
OperatorParameter_rank(const_OperatorParameter THIS)
{
  return ((THIS)->RANK);
}

/*
 * OperatorParameter_type --	The OperandType of THIS OperatorParameter.
 */
static inline OperandType
OperatorParameter_type(const_OperatorParameter THIS)
{
  return (OperandType)((THIS)->TYPE);
}

/*
 * OperatorParameter_enum --	The Modifier/Immediate/RegClass/Regmask of THIS OperatorParameter.
 */
static inline int
OperatorParameter_enum(const_OperatorParameter THIS)
{
  return ((THIS)->ENUM);
}

/*
 * OperatorParameter_same --	The Index of the OperatorParameter that must get
 * the same encoding as THIS OperatorParameter;  -1 if none.  Used to identify
 * Instance Operands that are both read and written.
 */
static inline int
OperatorParameter_same(const_OperatorParameter THIS)
{
  return ((THIS)->SAME);
}

/*
 * OperatorParameter_FOREACH_ConflictIndex --	Iterate over THIS OperatorParameter
 * conflicting OperatorParameter indices .  These Parameters must get different
 * encodings (e.g., different Registers).  The indices are listed in increasing
 * order.
 * Continuing with =continue=, and exiting with =break= or =return= are allowed.
 */
#define OperatorParameter_FOREACH_ConflictIndex(THIS,index) { const int8_t* OperatorParameter_ITER = OperatorParameter_CONFLICTS(THIS); const int8_t* OperatorParameter_FENCE = OperatorParameter_ITER + OperatorParameter_COUNT(THIS); for (; OperatorParameter_ITER < OperatorParameter_FENCE; ++OperatorParameter_ITER) { const int index = *OperatorParameter_ITER;






#define OperatorParameter_ENDEACH_ConflictIndex } }



/*
 * OperatorParameterArray --	Array of OperatorParameter(s).
 */
struct OperatorParameterArray_ {
  int16_t WRITECOUNT;
  int16_t READCOUNT;
  const OperatorParameter_ *ITEMS;
};
typedef struct OperatorParameterArray_ OperatorParameterArray_, *OperatorParameterArray;
typedef const struct OperatorParameterArray_ *const_OperatorParameterArray;
typedef struct OperatorParameterArray_ * restrict_OperatorParameterArray;

#define OperatorParameterArray_WRITECOUNT(THIS) ((THIS)->WRITECOUNT)
#define OperatorParameterArray__WRITECOUNT(THIS) (&(THIS)->WRITECOUNT)
#define OperatorParameterArray_READCOUNT(THIS) ((THIS)->READCOUNT)
#define OperatorParameterArray__READCOUNT(THIS) (&(THIS)->READCOUNT)
#define OperatorParameterArray_ITEMS(THIS) ((THIS)->ITEMS)
#define OperatorParameterArray__ITEMS(THIS) (&(THIS)->ITEMS)


/*
 * OperatorParameterArray_readCount --	Argument count in THIS OperatorParameterArray.
 */
static inline int
OperatorParameterArray_readCount(const_OperatorParameterArray THIS)
{
  return ((THIS)->READCOUNT);
}

/*
 * OperatorParameterArray_writeCount --	Result count in THIS OperatorParameterArray.
 */
static inline int
OperatorParameterArray_writeCount(const_OperatorParameterArray THIS)
{
  return ((THIS)->WRITECOUNT);
}

/*
 * OperatorParameterArray_count --	OperatorParameter count in THIS OperatorParameterArray.
 */
static inline int
OperatorParameterArray_count(const_OperatorParameterArray THIS)
{
  return ((THIS)->READCOUNT) + ((THIS)->WRITECOUNT);
}

/*
 * OperatorParameterArray_items --	For use by OperatorParameterArray_FOREACH_OperatorParameter.
 */
static inline const OperatorParameter_ *
OperatorParameterArray_items(const_OperatorParameterArray THIS)
{
  return ((THIS)->ITEMS);
}

/*
 * OperatorParameterArray_readParameters --	Pointer to the argument OperatorParameter(s).
 */
static inline const OperatorParameter_ *
OperatorParameterArray_readParameters(const_OperatorParameterArray THIS)
{
  return ((THIS)->ITEMS) + ((THIS)->WRITECOUNT);
}

/*
 * OperatorParameterArray_writeParameters --	Pointer to the result OperatorParameter(s).
 */
static inline const OperatorParameter_ *
OperatorParameterArray_writeParameters(const_OperatorParameterArray THIS)
{
  return ((THIS)->ITEMS) + 0;
}

/*
 * OperatorParameterArray_FOREACH_OperatorParameter --	Iterate over THIS OperatorParameterArray OperatorParameter(s).
 */
#define OperatorParameterArray_FOREACH_OperatorParameter(THIS,parameter) { const OperatorParameter_ *OperatorParameterArray_ITEMS = OperatorParameterArray_items(THIS); int OperatorParameterArray_COUNT = OperatorParameterArray_count(THIS); int OperatorParameterArray_INDEX = 0; for (; OperatorParameterArray_INDEX < OperatorParameterArray_COUNT; OperatorParameterArray_INDEX++) { const_OperatorParameter parameter = OperatorParameterArray_ITEMS + OperatorParameterArray_INDEX;







#define OperatorParameterArray_ENDEACH_OperatorParameter } }



/*
 * Operator_name_ --	Names for the Operator enumeration.
 */
extern const char *
Operator_name_(Operator THIS);

//
typedef enum {
  OperatorAttribute_Pseudo,
  OperatorAttribute_ReadList,
  OperatorAttribute_WriteList,
  OperatorAttribute_Control,
  OperatorAttribute_MemoryRead,
  OperatorAttribute_MemoryWrite,
  OperatorAttribute_MemoryProbe,
  OperatorAttribute_Conditional,
  OperatorAttribute_Multi,
} OperatorAttribute;
typedef uint16_t OperatorAttributes;

/*
 * Operator_attributes --	Access THIS Operator attributes.
 */
OperatorAttributes
Operator_attributes(Operator THIS);

/*
 * Operator_instance --	This Operator Instance for a Processor.
 */
Instance
Operator_instance(Operator THIS, Processor processor);

/*
 * Operator_mnemonic --	This Operator Mnemonic attribute.
 */
const char *
Operator_mnemonic(Operator THIS);

/*
 * Operator_parameterArray --	This Operator OperatorParameterArray.
 */
const_OperatorParameterArray
Operator_parameterArray(Operator THIS);

/*
 * Operator_readCount --	This Operator count of argument OperatorParameter(s).
 */
static inline int
Operator_readCount(Operator THIS) {
  const_OperatorParameterArray parameterArray = Operator_parameterArray(THIS);
  return OperatorParameterArray_readCount(parameterArray);
}

/*
 * Operator_writeCount --	This Operator count of result OperatorParameter(s).
 */
static inline int
Operator_writeCount(Operator THIS) {
  const_OperatorParameterArray parameterArray = Operator_parameterArray(THIS);
  return OperatorParameterArray_writeCount(parameterArray);
}

/*
 * Operator_readParameter --	Access the read OperatorParameter at readIndex.
 */
static inline const_OperatorParameter
Operator_readParameter(Operator THIS, int readIndex)
{
  const_OperatorParameterArray parameterArray = Operator_parameterArray(THIS);
  ;

  return OperatorParameterArray_readParameters(parameterArray) + readIndex;
}

/*
 * Operator_writeParameter --	Access the write OperatorParameter at writeIndex.
 */
static inline const_OperatorParameter
Operator_writeParameter(Operator THIS, int writeIndex)
{
  const_OperatorParameterArray parameterArray = Operator_parameterArray(THIS);
  ;

  return OperatorParameterArray_writeParameters(parameterArray) + writeIndex;
}

/*
 * Operator_getReadOperandType --	The Operator read index where the OperandType is.
 */
int8_t
Operator_getReadOperandType(Operator THIS, OperandType type);

//
#define Operator_immediateIndex(THIS) Operator_getReadOperandType(THIS, OperandType_Immediate)


/*
 * Operator_getReadParameterKind --	The Operator read index where the OperatorParameterKind is.
 */
int8_t
Operator_getReadParameterKind(Operator THIS, OperatorParameterKind kind);

//
#define Operator_baseIndex(THIS) Operator_getReadParameterKind(THIS, OperatorParameterKind_ReadBase)


//
#define Operator_offsetIndex(THIS) Operator_getReadParameterKind(THIS, OperatorParameterKind_ReadOffset)


//
#define Operator_storedIndex(THIS) Operator_getReadParameterKind(THIS, OperatorParameterKind_ReadStored)


//
#define Operator_leftIndex(THIS) Operator_getReadParameterKind(THIS, OperatorParameterKind_ReadLeft)

#define Operator_rightIndex(THIS) Operator_getReadParameterKind(THIS, OperatorParameterKind_ReadRight)


/*
 * Operator_isFixRegisterRAW --	True if Register RAW latency needs a fix.
 */
bool
Operator_isFixRegisterRAW(Operator THIS);

/*
 * Operator_selectInstance --	Select a suitable instance for the processor.
 */
Instance
Operator_selectInstance(Operator THIS, Processor processor);

/*
 * Operator_require --	The register lifetime flow requirements.
 */
int
Operator_require(Operator THIS, RegFile regFile);

/*
 * Operator_baseAddressIndex --	The index of THIS Operator base address OperatorParameter(s).
 * Return:	The index starting at 0 of base address OperatorParameter among writes.
 */
int
Operator_baseAddressIndex(Operator THIS);

/*
 * Operator_memoryAccessSize --	Get the access size in bytes of a memory access.
 */
int
Operator_memoryAccessSize(Operator THIS);

/*
 * Operator_isXXX --	Test if THIS Operator is a XXX.
 */
#define Operator_isEntry(THIS) ((THIS) == Operator_ENTRY)
#define Operator_isLabel(THIS) ((THIS) == Operator_LABEL)
#define Operator_isFall(THIS) ((THIS) == Operator_FALL)
#define Operator_isLoop(THIS) ((THIS) == Operator_LOOP)
#define Operator_isPhi(THIS) ((THIS) == Operator_PHI)
#define Operator_isPsi(THIS) ((THIS) == Operator_PSI)
#define Operator_isSigma(THIS) ((THIS) == Operator_SIGMA)
#define Operator_isSsa(THIS) ((THIS) >= Operator_PHI && (THIS) <= Operator_SIGMA)
#define Operator_isKill(THIS) ((THIS) == Operator_KILL)
#define Operator_isECopy(THIS) ((THIS) == Operator_ECOPY)
#define Operator_isLCopy(THIS) ((THIS) == Operator_LCOPY)
#define Operator_isPCopy(THIS) ((THIS) == Operator_PCOPY)
#define Operator_isPseudo(THIS) (Operator_attributes(THIS)>>OperatorAttribute_Pseudo & 1)

#define Operator_isReadList(THIS) (Operator_attributes(THIS)>>OperatorAttribute_ReadList & 1)

#define Operator_isWriteList(THIS) (Operator_attributes(THIS)>>OperatorAttribute_WriteList & 1)

#define Operator_isMulti(THIS) (Operator_attributes(THIS)>>OperatorAttribute_Multi & 1)

#define Operator_isControl(THIS) (Operator_attributes(THIS)>>OperatorAttribute_Control & 1)

#define Operator_isMemoryRead(THIS) (Operator_attributes(THIS)>>OperatorAttribute_MemoryRead & 1)

#define Operator_isMemoryWrite(THIS) (Operator_attributes(THIS)>>OperatorAttribute_MemoryWrite & 1)

#define Operator_isMemoryEffect(THIS) ( (Operator_attributes(THIS) & ((1<<OperatorAttribute_MemoryWrite))) || Operator_isMemoryBarrier(THIS) || Operator_isPrefetch(THIS) )




#define Operator_isMemory(THIS) ( ( Operator_attributes(THIS) & ((1<<OperatorAttribute_MemoryRead)|(1<<OperatorAttribute_MemoryWrite))) || Operator_isMemoryBarrier(THIS) || Operator_isPrefetch(THIS) )





#define Operator_isConditional(THIS) (Operator_attributes(THIS)>>OperatorAttribute_Conditional & 1)

#define Operator_isParCopy(THIS) ((unsigned)((THIS) - Operator_PCOPY) <= (unsigned)(Operator_LCOPY - Operator_PCOPY))


/*
 * Operator_isSeqCopy --	Test if THIS Operator is a COPY.
 *
 * In THIS case result 0 is the destination and argument 0 is the source.
 */
bool
Operator_isSeqCopy(Operator THIS);

/*
 * Operator_isAdd --	Test if THIS Operator is an ADD.
 */
bool
Operator_isAdd(Operator THIS);

/*
 * Operator_isAdditive --	Test if THIS Operator is additive.
 *
 * An operator OP is additive if OP(a, b) = OP(a+c, b-c).
 */
bool
Operator_isAdditive(Operator THIS, int aIndex, int bIndex);

/*
 * Operator_isSubtractive --	Test if THIS Operator is subtractive.
 *
 * An operator OP is subtractive if OP(a, b) = OP(a+c, b+c).
 */
bool
Operator_isSubtractive(Operator THIS, int aIndex, int bIndex);

/*
 * Operator_isTranslative --	Test if THIS Operator is translative.
 *
 * An operator OP is translative if OP(a+c, b+c) = OP(a, b) + c.
 */
bool
Operator_isTranslative(Operator THIS, int aIndex, int bIndex);

/*
 * Operator_isAssociative --	Test if THIS Operator is associative.
 *
 * An operator OP is associative if OP(OP(a, b), c) = OP(a, OP(b, c)).
 */
bool
Operator_isAssociative(Operator THIS, int aIndex, int bIndex);

/*
 * Operator_isCommutative --	Test if THIS Operator is commutative.
 *
 * An operator OP is commutative if OP(a, b) = OP(b, a).
 */
bool
Operator_isCommutative(Operator THIS, int aIndex, int bIndex);

/*
 * Operator_isGoTo --	Test if THIS Operator is a GOTO operator.
 *
 * A GOTO operator branches to a PC-relative or an absolute address, and has one
 * or two targets.
 */
bool
Operator_isGoTo(Operator THIS);

/*
 * Operator_isJump --	Test if THIS Operator is a JUMP operator.
 *
 * A JUMP operator branches to an address contained in a register.
 */
bool
Operator_isJump(Operator THIS);

/*
 * Operator_isBranch --	Test if THIS Operator is a branch operator.
 *
 * A branch is a control-flow change that remains inside the function.
 */
bool
Operator_isBranch(Operator THIS);

/*
 * Operator_isCall --	Test if THIS Operator is a CALL operator.
 *
 * A CALL operator branches to a PC-relative or an absolute address.
 */
bool
Operator_isCall(Operator THIS);

/*
 * Operator_isLink --	Test if THIS Operator is a LINK operator.
 */
bool
Operator_isLink(Operator THIS);

/*
 * Operator_isRoutine --	Test if THIS Operator is a function call operator.
 */
bool
Operator_isRoutine(Operator THIS);

/*
 * Operator_isReturn --	Test if THIS Operator is a function return operator.
 */
bool
Operator_isReturn(Operator THIS);

/*
 * Operator_isGNUASM --	Test if THIS Operator is a GNU ASM.
 */
bool
Operator_isGNUASM(Operator THIS);

/*
 * Operator_isMemoryBarrier --	Test if THIS Operator is a memory barrier.
 */
bool
Operator_isMemoryBarrier(Operator THIS);

/*
 * Operator_isStalling --	Test if THIS Operator is stalling the processor.
 *
 * Should be true for Operators that almost always stall the processor, and not true for
 * Operators that occasionally stall like memory accesses with cache misses.
 */
bool
Operator_isStalling(Operator THIS);

/*
 * Operator_isPrefetch --	Test if THIS Operator prefetches memory.
 */
bool
Operator_isPrefetch(Operator THIS);

/*
 * Operator_isSafeLoad --	Test if THIS Operator is a safe memory load.
 */
bool
Operator_isSafeLoad(Operator THIS);

/*
 * Operator_speculate --	Speculate THIS Operator.
 */
Operator
Operator_speculate(Operator THIS, Processor processor);

/*
 * Operator_predicatePositive --	The predicated on true variant of THIS Operator.
 */
Operator
Operator_predicatePositive(Operator THIS, Processor processor);

/*
 * Operator_predicateNegative --	The predicated on false variant of THIS Operator.
 */
Operator
Operator_predicateNegative(Operator THIS, Processor processor);

/*
 * Operator_predicateIndex --	This Operator predicate argument index.
 */
int
Operator_predicateIndex(Operator THIS);

/*
 * Operator_predicatePolarity --	This Operator predicate polarity.
 */
int
Operator_predicatePolarity(Operator THIS);

/*
 * Operator_unpredicate --	The predicated on false variant of THIS Operator.
 */
Operator
Operator_unpredicate(Operator THIS, Processor processor);

/*
 * Operator_complementWrite --	Complement THIS operator on the designated write parameter.
 */
Operator
Operator_complementWrite(Operator THIS, Processor processor, int32_t writeIndex);

/*
 * Operator_complementRead --	Complement THIS operator on the designated read parameter.
 */
Operator
Operator_complementRead(Operator THIS, Processor processor, int32_t readIndex);

/*
 * Operator_isHWLSkip --	Test if THIS Operator is a Hardware Loop Skip.
 */
static inline bool
Operator_isHWLSkip(Operator THIS)
{
  return false;
}

/*
 * Operator_isHWLBreak --	Test if THIS Operator is a Hardware Loop Break.
 */
static inline bool
Operator_isHWLBreak(Operator THIS)
{
  return false;
}

/*
 * Operator_isHWLIter --	Test if THIS Operator is a Hardware Loop Iter.
 */
static inline bool
Operator_isHWLIter(Operator THIS)
{
  return false;
}

/*
 * Operator_isHWLBranch --	Test if THIS Operator is a Hardware Loop Branch.
 */
static inline bool
Operator_isHWLBranch(Operator THIS)
{
  return false;
}

/*
 * Operator_isHWLPseudo --	Test if THIS Operator is a Hardware Loop Pseudo.
 */
static inline bool
Operator_isHWLPseudo(Operator THIS)
{
  return false;
}

//
bool
Operator_DTD(FILE *file);

//
bool
Operator_XML(FILE *file);

/*
 * !!!! arm-Operator.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 * Stefan Freudenberger (Stefan.Freudenberger@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */






/*
 * !!!!	Bundling.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Bundling_name_ --	Names for the Bundling enumeration.
 */
extern const char *
Bundling_name_(Bundling THIS);

/*
 * BundlingBuffer --	Buffer used to reorder Bundling(s).
 */






typedef struct BundlingBuffer_ BundlingBuffer_, *BundlingBuffer;
typedef const struct BundlingBuffer_ *const_BundlingBuffer;
typedef struct BundlingBuffer_ * restrict_BundlingBuffer;

#define BundlingBuffer_BUNDLINGS(THIS) ((THIS)->BUNDLINGS)
#define BundlingBuffer__BUNDLINGS(THIS) (&(THIS)->BUNDLINGS)
#define BundlingBuffer_PERMUTE(THIS) ((THIS)->PERMUTE)
#define BundlingBuffer__PERMUTE(THIS) (&(THIS)->PERMUTE)


/*
 * BundlingBuffer_sort --	Sort the BUNDLINGS array and fill the PERMUTE array.
 *
 * Return:	hash value suitable for use by =BundleMatch_FindBundle=.
 *
 * The hash value is computed as follows:
 *
 *	hash = -1;
 *	for (i = 0; i < count; i++) {
 *	  hash++; hash *= (Bundling__ - Bundling__BIAS);
 *	  hash += (bundlings[i] - Bundling__BIAS);
 *	}
 *	hash++;
 */
int32_t
BundlingBuffer_sort(BundlingBuffer THIS, int count);

//
bool
Bundling_DTD(FILE *file);

//
bool
Bundling_XML(FILE *file);






/*
 * !!!!	Template.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Template_name_ --	Names for the Template enumeration.
 */
extern const char *
Template_name_(Template THIS);

/*
 * Template_increment --	This Template increment of the PC.
 */
int
Template_increment(Template THIS);

/*
 * Template_count --	This Template count of Syllables.
 */
int
Template_count(Template THIS);

/*
 * Template_distances --	This Template Syllable PC distances from Bundle PC.
 */
const uint8_t *
Template_distances(Template THIS);

/*
 * Template_encode --	This Template encode function.
 */
typedef void
(*TemplateEncode)(const_InstanceOpcodes *restrict opcodes, void *restrict buffer);
TemplateEncode
Template_encode(Template THIS);






/*
 * !!!!	Bundle.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Bundle_name_ --	Names for the Bundle enumeration.
 */
extern const char *
Bundle_name_(Bundle THIS);

/*
 * Bundle_alignBias --	This Bundle align bias.
 */
int
Bundle_alignBias(Bundle THIS);

/*
 * Bundle_alignBase --	This Bundle align bias.
 */
int
Bundle_alignBase(Bundle THIS);

/*
 * Bundle_count --	This Bundle count of Bundling classes.
 */
int
Bundle_count(Bundle THIS);

/*
 * Bundle_contents --	This Bundle contents.
 */
const Bundling *
Bundle_contents(Bundle THIS);

/*
 * Bundle_inverse --	This Bundle inverse permutation.
 */
const uint8_t *
Bundle_inverse(Bundle THIS);

/*
 * Bundle_template --	This Bundle Template.
 */
Template
Bundle_template(Bundle THIS);

/*
 * BundleMatch --	Match between a sorted sequence of Bundling classes and Bundle(s).
 *
 * The HASH value is computed from a sorted sequence of Bundling classes as follows:
 *
 *	HASH = -1;
 *	for (i = 0; i < length; i++) {
 *	  HASH++; HASH *= (Bundling__ - Bundling__BIAS);
 *	  HASH += (bundlings[i] -- Bundling__BIAS);
 *	}
 *	HASH++;
 */







typedef struct BundleMatch_ BundleMatch_, *BundleMatch;
typedef const struct BundleMatch_ *const_BundleMatch;
typedef struct BundleMatch_ * restrict_BundleMatch;

#define BundleMatch_HASH(THIS) ((THIS)->HASH)
#define BundleMatch__HASH(THIS) (&(THIS)->HASH)
#define BundleMatch_COUNT(THIS) ((THIS)->COUNT)
#define BundleMatch__COUNT(THIS) (&(THIS)->COUNT)
#define BundleMatch_BUNDLES(THIS) ((THIS)->BUNDLES)
#define BundleMatch__BUNDLES(THIS) (&(THIS)->BUNDLES)


/*
 * BundleMatch_FindBundle --	Given a HASH and nativePC, find a matching Bundle.
 */
Bundle
BundleMatch_FindBundle(uint32_t hash, PlatformUInt nativePC);






/*
 * !!!!	Reservation.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * ReservationTable --	Reservation table.
 */
struct ReservationTable_ {
  int COLUMNCOUNT;
  ResourceVector_ *COLUMNS;
};
typedef struct ReservationTable_ ReservationTable_, *ReservationTable;
typedef const struct ReservationTable_ *const_ReservationTable;
typedef struct ReservationTable_ * restrict_ReservationTable;

#define ReservationTable_COLUMNCOUNT(THIS) ((THIS)->COLUMNCOUNT)
#define ReservationTable__COLUMNCOUNT(THIS) (&(THIS)->COLUMNCOUNT)
#define ReservationTable_COLUMNS(THIS) ((THIS)->COLUMNS)
#define ReservationTable__COLUMNS(THIS) (&(THIS)->COLUMNS)


/*
 * ReservationTable_columnCount --	Count of columns of THIS ReservationTable.
 */
static inline int
ReservationTable_columnCount(const_ReservationTable THIS)
{
  return ((THIS)->COLUMNCOUNT);
}

/*
 * ReservationTable_columns --	Array of columns of THIS ReservationTable.
 */
static inline const ResourceVector_ *
ReservationTable_columns(const_ReservationTable THIS)
{
  return ((THIS)->COLUMNS);
}

/*
 * Reservation_name_ --	Names for the Reservation enumeration.
 */
extern const char *
Reservation_name_(Reservation THIS);
extern const char *
Reservation_name(Reservation THIS);

/*
 * Reservation_table --	Access to THIS Reservation class ReservationTable
 */
const_ReservationTable
Reservation_table(Reservation THIS);

/*
 * Reservation_requirements --	The Resource requirements of THIS Reservation.
 */
static inline const_ResourceVector
Reservation_requirements(Reservation THIS)
{
  const_ReservationTable table = Reservation_table(THIS);
  return ((table)->COLUMNS);
}

/*
 * Reservation_criticality
 */
unsigned
Reservation_criticality(Reservation THIS);

/*
 * Reservation_odot --	The minimum number of cycles between two Reservation classes.
 */
int
Reservation_odot(Reservation THIS, Reservation that, Processor processor);

//
bool
Reservation_DTD(FILE *file);

//
bool
Reservation_XML(FILE *file);

/*
 * !!!! arm-Reservation.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */






/*
 * !!!!	Scheduling.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Scheduling_name_ --	Names for the Scheduling enumeration.
 */
extern const char *
Scheduling_name_(Scheduling THIS);
extern const char *
Scheduling_name(Scheduling THIS);

/*
 * Scheduling_processor --	This Scheduling class processor.
 */
Processor
Scheduling_processor(Scheduling THIS);

/*
 * Scheduling_bundling --	This Scheduling class Bundling class.
 */
Bundling
Scheduling_bundling(Scheduling THIS);

/*
 * Scheduling_reservation --	This Scheduling class Reservation.
 */
Reservation
Scheduling_reservation(Scheduling THIS);

//
bool
Scheduling_DTD(FILE *file);

//
bool
Scheduling_XML(FILE *file);






/*
 * !!!!	Convention.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * ConventionRole --	Enumerate the Convention Register roles.
 */
typedef enum {
  ConventionRole_Reserved, // Reserved (non allocatable) Register(s).
  ConventionRole_Argument, // Function call argument Register(s).
  ConventionRole_Result, // Function call result Register(s).
  ConventionRole_Struct, // Pointer to result structure Register(s).
  ConventionRole_Caller, // Caller saved (scratch) Register(s).
  ConventionRole_Callee, // Callee saved (preserved) Register(s).
  ConventionRole_Program, // Program counter Register(s).
  ConventionRole_Return, // Return address (link) Register(s).
  ConventionRole_Stack, // Stack pointer Register(s)
  ConventionRole_Frame, // Frame pointer Register(s).
  ConventionRole_Static, // Static link pointer Register(s).
  ConventionRole_Global, // Global data or GOT pointer Register(s).
  ConventionRole_Local, // Local data or TLS pointer Register(s).
  ConventionRole_Wired, // Wired (constant or bucket) Register(s).
  ConventionRole_Zero, // Constant zero value Register(s).
  ConventionRole_One, // Constant one value Register(s).
  ConventionRole__
} enum_ConventionRole;
typedef uint8_t ConventionRole;
extern const char *
ConventionRole_name_(ConventionRole THIS);

/*
 * Convention_name_ --	Names for the Convention enumeration.
 */
extern const char *
Convention_name_(Convention THIS);

/*
 * Convention_roleRegisterSet --	RegisterSet(s) indexed by ConventionRole(s).
 */
const_RegisterSet
Convention_roleRegisterSet(Convention THIS, ConventionRole role);

//
#define Convention_reservedRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Reserved)

#define Convention_argumentRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Argument)

#define Convention_resultRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Result)

#define Convention_structRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Struct)

#define Convention_callerRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Caller)

#define Convention_calleeRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Callee)

#define Convention_programRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Program)

#define Convention_returnRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Return)

#define Convention_stackRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Stack)

#define Convention_frameRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Frame)

#define Convention_staticRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Static)

#define Convention_globalRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Global)

#define Convention_localRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Local)

#define Convention_wiredRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Wired)

#define Convention_zeroRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_Zero)

#define Convention_oneRegisterSet(THIS) Convention_roleRegisterSet(THIS, ConventionRole_One)


//
#define Convention_isReservedRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Reserved), registre)

#define Convention_isArgumentRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Argument), registre)

#define Convention_isResultRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Result), registre)

#define Convention_isStructRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Struct), registre)

#define Convention_isCallerRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Caller), registre)

#define Convention_isCalleeRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Callee), registre)

#define Convention_isProgramRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Program), registre)

#define Convention_isReturnRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Return), registre)

#define Convention_isStackRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Stack), registre)

#define Convention_isFrameRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Frame), registre)

#define Convention_isStaticRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Static), registre)

#define Convention_isGlobalRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Global), registre)

#define Convention_isLocalRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Local), registre)

#define Convention_isWiredRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Wired), registre)

#define Convention_isZeroRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_Zero), registre)

#define Convention_isOneRegister(THIS,registre) RegisterSet_contains(Convention_roleRegisterSet(THIS, ConventionRole_One), registre)


/*
 * Convention_structRegister --	This Convention Struct pointer Register.
 */
Register
Convention_structRegister(Convention THIS);

/*
 * Convention_programRegister --	This Convention Program pointer Register.
 */
Register
Convention_programRegister(Convention THIS);

/*
 * Convention_returnRegister --	This Convention Return pointer Register.
 */
Register
Convention_returnRegister(Convention THIS);

/*
 * Convention_stackRegister --	This Convention Stack pointer Register.
 */
Register
Convention_stackRegister(Convention THIS);

/*
 * Convention_frameRegister --	This Convention Frame pointer Register.
 */
Register
Convention_frameRegister(Convention THIS);

/*
 * Convention_staticRegister --	This Convention Static pointer Register.
 */
Register
Convention_staticRegister(Convention THIS);

/*
 * Convention_globalRegister --	This Convention Global pointer Register.
 */
Register
Convention_globalRegister(Convention THIS);

/*
 * Convention_localRegister --	This Convention Local pointer Register.
 */
Register
Convention_localRegister(Convention THIS);

/*
 * Convention_alignText --	This Convention Text Alignment Base.
 */
unsigned
Convention_alignText(Convention THIS);

/*
 * Convention_alignData --	This Convention Data Alignment Base.
 */
unsigned
Convention_alignData(Convention THIS);

/*
 * Convention_alignHeap --	This Convention Heap Alignment Base.
 */
unsigned
Convention_alignHeap(Convention THIS);

/*
 * Convention_alignStack --	This Convention Stack Alignment Base.
 */
unsigned
Convention_alignStack(Convention THIS);

/*
 * Convention_nativeInt --	This Convention Native Int.
 */
NativeType
Convention_nativeInt(Convention THIS);

/*
 * Convention_nativeUInt --	This Convention Native UInt.
 */
NativeType
Convention_nativeUInt(Convention THIS);

/*
 * Convention_nativeFloat --	This Convention Native Float.
 */
NativeType
Convention_nativeFloat(Convention THIS);

/*
 * Convention_nativePtr --	This Convention Native Ptr.
 */
NativeType
Convention_nativePtr(Convention THIS);

//
extern RegisterSet_
Convention_allocatableSet(Convention THIS, RegFile regFile);

//
bool
Convention_DTD(FILE *file);

//
bool
Convention_XML(FILE *file);






/*
 * !!!!	Decode.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

//
/*
 * MDS_TRACE --	File handle used to trace the MDS.
 */
extern FILE *MDS_TRACE;




/*
 * Variables used to control MDS in non-release mode.
 */
extern int FORCE_MAXISSUE;
extern int FORCE_MINTAKEN;

//
void
MDS_setMaxIssue(Processor processor, int maxIssue);

//
void
MDS_setMinTaken(Processor processor, int minTaken);

//
void
MDS_setReserved(Convention convention, Register registre);

/*
 * MDS_INIT --	MDS init function.
 */
void
MDS_INIT(void);

/*
 * MDS_FINI --	MDS fini function.
 */
void
MDS_FINI(void);





/*
 * !!!!	CGIR.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 * Christophe Guillon (Christophe.Guillon@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

/*
 * Host compiler CGIR types.
 */
typedef uint32_t CGIR_LAB;
typedef uint32_t CGIR_SYM;
typedef struct WN *CGIR_WN;
typedef struct tn *CGIR_TN;
typedef struct op *CGIR_OP;
typedef struct bb *CGIR_BB;
typedef struct LOOP_DESCR *CGIR_LD;
typedef struct region_id *CGIR_RID;

//
typedef enum {
  CGIRType_Virtual,
  CGIRType_Assigned,
  CGIRType_Dedicated,
  CGIRType_Absolute,
  CGIRType_Symbol,
  CGIRType_Label,
  CGIRType__,
} CGIRType;
const char *
CGIRType_(CGIRType type);

/*
 * CGIROperationFlags --	Used to pass OperationFlag to CGIR_OP.
 */
typedef enum {
  CGIROperationFlags_SafeAccess = 0x1,
  CGIROperationFlags_Hoisted = 0x2,
  CGIROperationFlags_Volatile = 0x4,
  CGIROperationFlags_Prefetch = 0x8,
  CGIROperationFlags_Preload = 0x10,
  CGIROperationFlags_Barrier = 0x20,
  CGIROperationFlags_SpillCode = 0x40,
  CGIROperationFlags_SafePerfs = 0x80,
} enum_CGIROperationFlags;
typedef uint8_t CGIROperationFlags;

/*
 * CGIRBasicBlockFlags --	Used to pass BasicBlockFlag to CGIR_OP.
 */
typedef enum {
  CGIRBasicBlockFlags_Allocated = 0x1,
  CGIRBasicBlockFlags_Scheduled = 0x2,
} CGIRBasicBlockFlags;

/*
 * uint32_t CGIR_LAB_identity(CGIR_LAB cgir_lab); --	Identity of a CGIR_LAB.
 */
#define CGIR_LAB_identity(cgir_lab) (uint32_t)(cgir_lab)


/*
 * uint32_t CGIR_SYM_identity(CGIR_SYM cgir_sym); --	Identity of a CGIR_SYM.
 */
#define CGIR_SYM_identity(cgir_sym) (uint32_t)(cgir_sym)


/*
 * uint32_t CGIR_TN_identity(CGIR_TN cgir_tn); --	Identity of a CGIR_TN.
 */
#define CGIR_TN_identity(cgir_tn) (uint32_t)(cgir_tn)


/*
 * uint32_t CGIR_OP_identity(CGIR_OP cgir_op); --	Identity of a CGIR_OP.
 */
#define CGIR_OP_identity(cgir_op) (uint32_t)(cgir_op)


/*
 * uint32_t CGIR_BB_identity(CGIR_BB cgir_bb); --	Identity of a CGIR_BB.
 */
#define CGIR_BB_identity(cgir_bb) (uint32_t)(cgir_bb)


/*
 * uint32_t CGIR_LD_identity(CGIR_LD cgir_ld); --	Identity of a CGIR_LD.
 */
#define CGIR_LD_identity(cgir_ld) (uint32_t)(cgir_ld)


/*
 * CGIR_LAB_make --	Update a CGIR_LAB.
 */
static CGIR_LAB
CGIR_LAB_make(CGIR_LAB cgir_lab, const char *name);

/*
 * CGIR_SYM_make --	Update a CGIR_SYM.
 */
static CGIR_SYM
CGIR_SYM_make(CGIR_SYM cgir_sym, const char *name, bool isSpill, NativeType lai_nativeType);

/*
 * CGIR_TN_make --	Update a CGIR_TN.
 */
static CGIR_TN
CGIR_TN_make(CGIR_TN cgir_tn, CGIRType cgir_type, ...);

/*
 * CGIR_OP_make --	Update a CGIR_OP from a LIR Operation.
 */
static CGIR_OP
CGIR_OP_make(CGIR_OP cgir_op, Operator lai_operator, CGIR_TN arguments[], CGIR_TN results[], CGIR_OP orig_op);

//
static void
CGIR_OP_more(CGIR_OP cgir_op, int iteration, int startDate, unsigned flags);

/*
 * void CGIR_BB_make --	Update a CGIR_BB.
 */
static CGIR_BB
CGIR_BB_make(CGIR_BB cgir_bb, CGIR_LAB labels[], CGIR_OP operations[], CGIR_RID cgir_rid, float frequency);

//
static void
CGIR_BB_more(CGIR_BB cgir_bb, CGIR_BB loop_bb, intptr_t traceId, int unrolled, unsigned flags);

/*
 * CGIR_LD_make --	Update a CGIR_LD.
 */
static CGIR_LD
CGIR_LD_make(CGIR_LD cgir_ld, CGIR_BB head_bb, CGIR_TN trip_count_tn, int unrolled);

/*
 * CGIR_BB_chain --	Chain two CGIR_BBs in the CGIR.
 */
static void
CGIR_BB_chain(CGIR_BB cgir_bb, CGIR_BB succ_cgir_bb);

/*
 * CGIR_BB_unchain --	Unchain a CGIR_BB in the CGIR.
 */
static void
CGIR_BB_unchain(CGIR_BB cgir_bb);

/*
 * CGIR_BB_link --	Link two CGIR_BBs in the CGIR with the given branch probability.
 */
static void
CGIR_BB_link(CGIR_BB tail_cgir_bb, CGIR_BB head_cgir_bb, float probability);

/*
 * void CGIR_BB_unlink(CGIR_BB cgir_bb, bool preds, bool succs);
 * --	Unlink the predecessors and/or the successors of a CGIR_BB in the CGIR.
 */
static void
CGIR_BB_unlink(CGIR_BB cgir_bb, bool preds, bool succs);

/*
 * void CGIR_BB_discard(CGIR_BB cgir_bb);
 * --	Discard a CGIR_BB in the CGIR.
 */
static void
CGIR_BB_discard(CGIR_BB cgir_bb);

/*
 * CGIR_CallBack --	Call back functions.
 */
struct CGIR_CallBack_ {
  CGIR_LAB (*LAB_make)(CGIR_LAB cgir_lab, const char *name);
  CGIR_SYM (*SYM_make)(CGIR_SYM cgir_sym, const char *name, bool isSpill, NativeType lai_nativeType);
  CGIR_TN (*TN_make)(CGIR_TN cgir_tn, CGIRType cgir_type, ...);
  CGIR_OP (*OP_make)(CGIR_OP cgir_op, Operator lai_operator, CGIR_TN arguments[], CGIR_TN results[], CGIR_OP orig_op);
  void (*OP_more)(CGIR_OP cgir_op, int iteration, int startDate, unsigned flags);
  CGIR_BB (*BB_make)(CGIR_BB cgir_bb, CGIR_LAB labels[], CGIR_OP operations[], CGIR_RID cgir_rid, float frequency);
  void (*BB_more)(CGIR_BB cgir_bb, CGIR_BB loop_bb, intptr_t traceId, int unrolled, unsigned flags);
  CGIR_LD (*LD_make)(CGIR_LD cgir_ld, CGIR_BB head_bb, CGIR_TN trip_count_tn, int unrolled);
  void (*BB_chain)(CGIR_BB cgir_bb, CGIR_BB succ_cgir_bb);
  void (*BB_unchain)(CGIR_BB cgir_bb);
  void (*BB_link)(CGIR_BB tail_cgir_bb, CGIR_BB head_cgir_bb, float probability);
  void (*BB_unlink)(CGIR_BB cgir_bb, bool preds, bool succs);
  void (*BB_discard)(CGIR_BB cgir_bb);
};
typedef struct CGIR_CallBack_ CGIR_CallBack_, *CGIR_CallBack;
typedef const struct CGIR_CallBack_ *const_CGIR_CallBack;
typedef struct CGIR_CallBack_ * restrict_CGIR_CallBack;

#define CGIR_CallBack_LAB_make(THIS) ((THIS)->LAB_make)
#define CGIR_CallBack__LAB_make(THIS) (&(THIS)->LAB_make)
#define CGIR_CallBack_SYM_make(THIS) ((THIS)->SYM_make)
#define CGIR_CallBack__SYM_make(THIS) (&(THIS)->SYM_make)
#define CGIR_CallBack_TN_make(THIS) ((THIS)->TN_make)
#define CGIR_CallBack__TN_make(THIS) (&(THIS)->TN_make)
#define CGIR_CallBack_OP_make(THIS) ((THIS)->OP_make)
#define CGIR_CallBack__OP_make(THIS) (&(THIS)->OP_make)
#define CGIR_CallBack_OP_more(THIS) ((THIS)->OP_more)
#define CGIR_CallBack__OP_more(THIS) (&(THIS)->OP_more)
#define CGIR_CallBack_BB_make(THIS) ((THIS)->BB_make)
#define CGIR_CallBack__BB_make(THIS) (&(THIS)->BB_make)
#define CGIR_CallBack_BB_more(THIS) ((THIS)->BB_more)
#define CGIR_CallBack__BB_more(THIS) (&(THIS)->BB_more)
#define CGIR_CallBack_LD_make(THIS) ((THIS)->LD_make)
#define CGIR_CallBack__LD_make(THIS) (&(THIS)->LD_make)
#define CGIR_CallBack_BB_chain(THIS) ((THIS)->BB_chain)
#define CGIR_CallBack__BB_chain(THIS) (&(THIS)->BB_chain)
#define CGIR_CallBack_BB_unchain(THIS) ((THIS)->BB_unchain)
#define CGIR_CallBack__BB_unchain(THIS) (&(THIS)->BB_unchain)
#define CGIR_CallBack_BB_link(THIS) ((THIS)->BB_link)
#define CGIR_CallBack__BB_link(THIS) (&(THIS)->BB_link)
#define CGIR_CallBack_BB_unlink(THIS) ((THIS)->BB_unlink)
#define CGIR_CallBack__BB_unlink(THIS) (&(THIS)->BB_unlink)
#define CGIR_CallBack_BB_discard(THIS) ((THIS)->BB_discard)
#define CGIR_CallBack__BB_discard(THIS) (&(THIS)->BB_discard)


//
int
CGIR_Print_LAB_Vector(CGIR_LAB cgir_labels[], FILE *file);

//
int
CGIR_Print_TN_Vector(CGIR_TN cgir_temporaries[], FILE *file);

//
int
CGIR_Print_OP_Vector(CGIR_OP cgir_operations[], FILE *file);

/*
 * O64_Interface --	O64 Interface object.
 * All functions for the LAO Interface are available
 * from THIS object.
 */
struct O64_Interface_ {
  int size;
  void (*Interface_Initialize)(void);
  void (*Interface_Finalize)(void);
  struct Interface_* (*Interface_getInstance)(void);
  void (*Interface_setMaxIssue)(struct Interface_* THIS, Processor processor,
                                int maxIssue);
  void (*Interface_setMinTaken)(struct Interface_* THIS, Processor processor,
                                int minTaken);
  void (*Interface_setReserved)(struct Interface_* THIS, Convention convention,
                                Register reserved);
  bool (*Interface_setArgStage)(struct Interface_* THIS, Processor processor,
                                Operator operator, int index, int stage);
  bool (*Interface_setResStage)(struct Interface_* THIS, Processor processor,
                                Operator operator, int index, int stage);
  Label (*Interface_makeLabel)(struct Interface_* THIS, CGIR_LAB cgir_lab,
                               const char *name);
  Label (*Interface_findLabel)(struct Interface_* THIS, CGIR_LAB cgir_lab);
  Symbol (*Interface_makeSymbol)(struct Interface_* THIS, CGIR_SYM cgir_sym,
                                 const char *name);
  void (*Interface_Symbol_setClasses)(struct Interface_* THIS, Symbol symbol,
                                      SymbolClass sclass, SymbolStore sstore,
                                      SymbolExport sexport);
  Symbol (*Interface_findSymbol)(struct Interface_* THIS, CGIR_SYM cgir_sym);
  Temporary (*Interface_makeDedicatedTemporary)(struct Interface_* THIS, CGIR_TN cgir_tn,
                                                Register registre);
  Temporary (*Interface_makeAssignedTemporary)(struct Interface_* THIS, CGIR_TN cgir_tn,
                                               Register registre);
  Temporary (*Interface_makeVirtualTemporary)(struct Interface_* THIS, CGIR_TN cgir_tn,
                                              RegFile regFile);
  Temporary (*Interface_makeAbsoluteTemporary)(struct Interface_* THIS, CGIR_TN cgir_tn,
                                               Immediate immediate, int64_t value);
  Temporary (*Interface_makeSymbolTemporary)(struct Interface_* THIS, CGIR_TN cgir_tn,
                                             Immediate immediate, Symbol symbol,
                                             int64_t offset);
  Temporary (*Interface_makeLabelTemporary)(struct Interface_* THIS, CGIR_TN cgir_tn,
                                            Immediate immediate, Label label);
  void (*Interface_Temporary_setWidth)(struct Interface_* THIS, Temporary temporary,
                                       unsigned width);
  void (*Interface_Temporary_setRemater)(struct Interface_* THIS, Temporary temporary,
                                         Temporary value);
  void (*Interface_Temporary_setHomeable)(struct Interface_* THIS, Temporary temporary,
                                          Temporary location);
  void (*Interface_Temporary_setDedicated)(struct Interface_* THIS, Temporary temporary);
  Temporary (*Interface_findTemporary)(struct Interface_* THIS, CGIR_TN cgir_tn);
  uint32_t (*Interface_Temporary_identity)(Temporary temporary);
  int (*Interface_Temporary_isAbsolute)(Temporary temporary);
  int64_t (*Interface_Temporary_value)(Temporary temporary);
  int (*Interface_Temporary_isSymbol)(Temporary temporary);
  Symbol (*Interface_Temporary_symbol)(Temporary temporary);
  int64_t (*Interface_Temporary_offset)(Temporary temporary);
  Immediate (*Interface_Temporary_invariant)(Temporary temporary);
  int (*Interface_Temporary_isVirtual)(Temporary temporary);
  int (*Interface_Temporary_isDedicated)(Temporary temporary);
  int (*Interface_Temporary_isAssigned)(Temporary temporary);
  Register (*Interface_Temporary_register)(Temporary temporary);
  RegFile (*Interface_Temporary_regFile)(Temporary temporary);
  uint32_t (*Interface_Symbol_identity)(Symbol symbol);
  const char * (*Interface_Symbol_name)(Symbol symbol);
  int (*Interface_Symbol_isSpill)(Symbol symbol);
  NativeType (*Interface_Symbol_nativeType)(Symbol symbol);
  uint32_t (*Interface_Operation_identity)(Operation operation);
  Operator (*Interface_Operation_operator)(Operation operation);
  int (*Interface_Operation_iteration)(Operation operation);
  int (*Interface_Operation_startDate)(Operation operation);
  int (*Interface_Operation_isSpillCode)(Operation operation);
  int (*Interface_Operation_isVolatile)(Operation operation);
  int (*Interface_Operation_isHoisted)(Operation operation);
  uint32_t (*Interface_Label_identity)(Label label);
  const char * (*Interface_Label_name)(Label label);
  uint32_t (*Interface_BasicBlock_identity)(BasicBlock basicBlock);
  int (*Interface_BasicBlock_unrolled)(BasicBlock basicBlock);
  intptr_t (*Interface_BasicBlock_traceId)(BasicBlock basicBlock);
  uint32_t (*Interface_LoopScope_identity)(LoopScope loopScope);
  int (*Interface_LoopScope_unrolled)(LoopScope loopScope);
  Operation (*Interface_makeOperation)(struct Interface_* THIS,
      CGIR_OP cgir_op, Operator operator, int iteration,
      int argCount, Temporary arguments[], int resCount,
      Temporary results[], int regCount, int registers[]);
  Operation (*Interface_findOperation)(struct Interface_* THIS, CGIR_OP cgir_op);
  void (*Interface_Operation_setSafeAccess)(struct Interface_* THIS, Operation operation);
  void (*Interface_Operation_setHoisted)(struct Interface_* THIS, Operation operation);
  void (*Interface_Operation_setVolatile)(struct Interface_* THIS, Operation operation);
  void (*Interface_Operation_setPrefetch)(struct Interface_* THIS, Operation operation);
  void (*Interface_Operation_setPreload)(struct Interface_* THIS, Operation operation);
  void (*Interface_Operation_setBarrier)(struct Interface_* THIS, Operation operation);
  void (*Interface_Operation_setSafePerfs)(struct Interface_* THIS, Operation operation);
  void (*Interface_Operation_setSpillCode)(struct Interface_* THIS, Operation operation,
                                           Symbol symbol);
  BasicBlock (*Interface_makeBasicBlock)(struct Interface_* THIS, CGIR_BB cgir_bb,
                                         Processor processor, int unrolled,
                                         int labelCount, Label labels[],
                                         int operationCount, Operation operations[],
                                         intptr_t regionId, float frequency);
  BasicBlock (*Interface_findBasicBlock)(struct Interface_* THIS, CGIR_BB cgir_bb);
  void (*Interface_linkBasicBlocks)(struct Interface_* THIS,
      BasicBlock tail_block, BasicBlock head_block, float probability);
  LoopScope (*Interface_makeLoopScope)(struct Interface_* THIS, CGIR_LD cgir_ld,
                                     BasicBlock basicBlock, Temporary temporary,
                                     ConfigureItem item, ...);
  LoopScope (*Interface_findLoopScope)(struct Interface_* THIS, CGIR_LD cgir_ld);
  void (*Interface_LoopScope_setDependenceNode)(struct Interface_* THIS,
      LoopScope loopScope, Operation operation, DependenceNode node);
  void (*Interface_LoopScope_setDependenceArc)(struct Interface_* THIS,
      LoopScope loopScope, Operation tail_operation, Operation head_operation,
      int latency, int omega, DependenceKind type);
  void (*Interface_setBody)(struct Interface_* THIS, BasicBlock basicBlock);
  void (*Interface_setEntry)(struct Interface_* THIS, BasicBlock basicBlock);
  void (*Interface_setExit)(struct Interface_* THIS, BasicBlock basicBlock);
  void (*Interface_setStart)(struct Interface_* THIS, BasicBlock basicBlock);
  void (*Interface_updateCGIR)(struct Interface_* THIS, CGIR_CallBack callback);
  void (*Interface_open)(struct Interface_* THIS, const char *name,
                         ConfigureItem item, ...);
  unsigned (*Interface_optimize)(struct Interface_* THIS, OptimizeItem item, ...);
  void (*Interface_close)(struct Interface_* THIS);
};
typedef struct O64_Interface_ O64_Interface_, *O64_Interface;
typedef const struct O64_Interface_ *const_O64_Interface;
typedef struct O64_Interface_ * restrict_O64_Interface;

#define O64_Interface_size(THIS) ((THIS)->size)
#define O64_Interface__size(THIS) (&(THIS)->size)
#define O64_Interface_Interface_Initialize(THIS) ((THIS)->Interface_Initialize)
#define O64_Interface__Interface_Initialize(THIS) (&(THIS)->Interface_Initialize)
#define O64_Interface_Interface_Finalize(THIS) ((THIS)->Interface_Finalize)
#define O64_Interface__Interface_Finalize(THIS) (&(THIS)->Interface_Finalize)
#define O64_Interface_Interface_getInstance(THIS) ((THIS)->Interface_getInstance)
#define O64_Interface__Interface_getInstance(THIS) (&(THIS)->Interface_getInstance)
#define O64_Interface_Interface_setMaxIssue(THIS) ((THIS)->Interface_setMaxIssue)
#define O64_Interface__Interface_setMaxIssue(THIS) (&(THIS)->Interface_setMaxIssue)
#define O64_Interface_Interface_setMinTaken(THIS) ((THIS)->Interface_setMinTaken)
#define O64_Interface__Interface_setMinTaken(THIS) (&(THIS)->Interface_setMinTaken)
#define O64_Interface_Interface_setReserved(THIS) ((THIS)->Interface_setReserved)
#define O64_Interface__Interface_setReserved(THIS) (&(THIS)->Interface_setReserved)
#define O64_Interface_Interface_setArgStage(THIS) ((THIS)->Interface_setArgStage)
#define O64_Interface__Interface_setArgStage(THIS) (&(THIS)->Interface_setArgStage)
#define O64_Interface_Interface_setResStage(THIS) ((THIS)->Interface_setResStage)
#define O64_Interface__Interface_setResStage(THIS) (&(THIS)->Interface_setResStage)
#define O64_Interface_Interface_makeLabel(THIS) ((THIS)->Interface_makeLabel)
#define O64_Interface__Interface_makeLabel(THIS) (&(THIS)->Interface_makeLabel)
#define O64_Interface_Interface_findLabel(THIS) ((THIS)->Interface_findLabel)
#define O64_Interface__Interface_findLabel(THIS) (&(THIS)->Interface_findLabel)
#define O64_Interface_Interface_makeSymbol(THIS) ((THIS)->Interface_makeSymbol)
#define O64_Interface__Interface_makeSymbol(THIS) (&(THIS)->Interface_makeSymbol)
#define O64_Interface_Interface_Symbol_setClasses(THIS) ((THIS)->Interface_Symbol_setClasses)
#define O64_Interface__Interface_Symbol_setClasses(THIS) (&(THIS)->Interface_Symbol_setClasses)
#define O64_Interface_Interface_findSymbol(THIS) ((THIS)->Interface_findSymbol)
#define O64_Interface__Interface_findSymbol(THIS) (&(THIS)->Interface_findSymbol)
#define O64_Interface_Interface_makeDedicatedTemporary(THIS) ((THIS)->Interface_makeDedicatedTemporary)
#define O64_Interface__Interface_makeDedicatedTemporary(THIS) (&(THIS)->Interface_makeDedicatedTemporary)
#define O64_Interface_Interface_makeAssignedTemporary(THIS) ((THIS)->Interface_makeAssignedTemporary)
#define O64_Interface__Interface_makeAssignedTemporary(THIS) (&(THIS)->Interface_makeAssignedTemporary)
#define O64_Interface_Interface_makeVirtualTemporary(THIS) ((THIS)->Interface_makeVirtualTemporary)
#define O64_Interface__Interface_makeVirtualTemporary(THIS) (&(THIS)->Interface_makeVirtualTemporary)
#define O64_Interface_Interface_makeAbsoluteTemporary(THIS) ((THIS)->Interface_makeAbsoluteTemporary)
#define O64_Interface__Interface_makeAbsoluteTemporary(THIS) (&(THIS)->Interface_makeAbsoluteTemporary)
#define O64_Interface_Interface_makeSymbolTemporary(THIS) ((THIS)->Interface_makeSymbolTemporary)
#define O64_Interface__Interface_makeSymbolTemporary(THIS) (&(THIS)->Interface_makeSymbolTemporary)
#define O64_Interface_Interface_makeLabelTemporary(THIS) ((THIS)->Interface_makeLabelTemporary)
#define O64_Interface__Interface_makeLabelTemporary(THIS) (&(THIS)->Interface_makeLabelTemporary)
#define O64_Interface_Interface_Temporary_setWidth(THIS) ((THIS)->Interface_Temporary_setWidth)
#define O64_Interface__Interface_Temporary_setWidth(THIS) (&(THIS)->Interface_Temporary_setWidth)
#define O64_Interface_Interface_Temporary_setRemater(THIS) ((THIS)->Interface_Temporary_setRemater)
#define O64_Interface__Interface_Temporary_setRemater(THIS) (&(THIS)->Interface_Temporary_setRemater)
#define O64_Interface_Interface_Temporary_setHomeable(THIS) ((THIS)->Interface_Temporary_setHomeable)
#define O64_Interface__Interface_Temporary_setHomeable(THIS) (&(THIS)->Interface_Temporary_setHomeable)
#define O64_Interface_Interface_Temporary_setDedicated(THIS) ((THIS)->Interface_Temporary_setDedicated)
#define O64_Interface__Interface_Temporary_setDedicated(THIS) (&(THIS)->Interface_Temporary_setDedicated)
#define O64_Interface_Interface_findTemporary(THIS) ((THIS)->Interface_findTemporary)
#define O64_Interface__Interface_findTemporary(THIS) (&(THIS)->Interface_findTemporary)
#define O64_Interface_Interface_Temporary_identity(THIS) ((THIS)->Interface_Temporary_identity)
#define O64_Interface__Interface_Temporary_identity(THIS) (&(THIS)->Interface_Temporary_identity)
#define O64_Interface_Interface_Temporary_isAbsolute(THIS) ((THIS)->Interface_Temporary_isAbsolute)
#define O64_Interface__Interface_Temporary_isAbsolute(THIS) (&(THIS)->Interface_Temporary_isAbsolute)
#define O64_Interface_Interface_Temporary_value(THIS) ((THIS)->Interface_Temporary_value)
#define O64_Interface__Interface_Temporary_value(THIS) (&(THIS)->Interface_Temporary_value)
#define O64_Interface_Interface_Temporary_isSymbol(THIS) ((THIS)->Interface_Temporary_isSymbol)
#define O64_Interface__Interface_Temporary_isSymbol(THIS) (&(THIS)->Interface_Temporary_isSymbol)
#define O64_Interface_Interface_Temporary_symbol(THIS) ((THIS)->Interface_Temporary_symbol)
#define O64_Interface__Interface_Temporary_symbol(THIS) (&(THIS)->Interface_Temporary_symbol)
#define O64_Interface_Interface_Temporary_offset(THIS) ((THIS)->Interface_Temporary_offset)
#define O64_Interface__Interface_Temporary_offset(THIS) (&(THIS)->Interface_Temporary_offset)
#define O64_Interface_Interface_Temporary_invariant(THIS) ((THIS)->Interface_Temporary_invariant)
#define O64_Interface__Interface_Temporary_invariant(THIS) (&(THIS)->Interface_Temporary_invariant)
#define O64_Interface_Interface_Temporary_isVirtual(THIS) ((THIS)->Interface_Temporary_isVirtual)
#define O64_Interface__Interface_Temporary_isVirtual(THIS) (&(THIS)->Interface_Temporary_isVirtual)
#define O64_Interface_Interface_Temporary_isDedicated(THIS) ((THIS)->Interface_Temporary_isDedicated)
#define O64_Interface__Interface_Temporary_isDedicated(THIS) (&(THIS)->Interface_Temporary_isDedicated)
#define O64_Interface_Interface_Temporary_isAssigned(THIS) ((THIS)->Interface_Temporary_isAssigned)
#define O64_Interface__Interface_Temporary_isAssigned(THIS) (&(THIS)->Interface_Temporary_isAssigned)
#define O64_Interface_Interface_Temporary_register(THIS) ((THIS)->Interface_Temporary_register)
#define O64_Interface__Interface_Temporary_register(THIS) (&(THIS)->Interface_Temporary_register)
#define O64_Interface_Interface_Temporary_regFile(THIS) ((THIS)->Interface_Temporary_regFile)
#define O64_Interface__Interface_Temporary_regFile(THIS) (&(THIS)->Interface_Temporary_regFile)
#define O64_Interface_Interface_Symbol_identity(THIS) ((THIS)->Interface_Symbol_identity)
#define O64_Interface__Interface_Symbol_identity(THIS) (&(THIS)->Interface_Symbol_identity)
#define O64_Interface_Interface_Symbol_name(THIS) ((THIS)->Interface_Symbol_name)
#define O64_Interface__Interface_Symbol_name(THIS) (&(THIS)->Interface_Symbol_name)
#define O64_Interface_Interface_Symbol_isSpill(THIS) ((THIS)->Interface_Symbol_isSpill)
#define O64_Interface__Interface_Symbol_isSpill(THIS) (&(THIS)->Interface_Symbol_isSpill)
#define O64_Interface_Interface_Symbol_nativeType(THIS) ((THIS)->Interface_Symbol_nativeType)
#define O64_Interface__Interface_Symbol_nativeType(THIS) (&(THIS)->Interface_Symbol_nativeType)
#define O64_Interface_Interface_Operation_identity(THIS) ((THIS)->Interface_Operation_identity)
#define O64_Interface__Interface_Operation_identity(THIS) (&(THIS)->Interface_Operation_identity)
#define O64_Interface_Interface_Operation_operator(THIS) ((THIS)->Interface_Operation_operator)
#define O64_Interface__Interface_Operation_operator(THIS) (&(THIS)->Interface_Operation_operator)
#define O64_Interface_Interface_Operation_iteration(THIS) ((THIS)->Interface_Operation_iteration)
#define O64_Interface__Interface_Operation_iteration(THIS) (&(THIS)->Interface_Operation_iteration)
#define O64_Interface_Interface_Operation_startDate(THIS) ((THIS)->Interface_Operation_startDate)
#define O64_Interface__Interface_Operation_startDate(THIS) (&(THIS)->Interface_Operation_startDate)
#define O64_Interface_Interface_Operation_isSpillCode(THIS) ((THIS)->Interface_Operation_isSpillCode)
#define O64_Interface__Interface_Operation_isSpillCode(THIS) (&(THIS)->Interface_Operation_isSpillCode)
#define O64_Interface_Interface_Operation_isVolatile(THIS) ((THIS)->Interface_Operation_isVolatile)
#define O64_Interface__Interface_Operation_isVolatile(THIS) (&(THIS)->Interface_Operation_isVolatile)
#define O64_Interface_Interface_Operation_isHoisted(THIS) ((THIS)->Interface_Operation_isHoisted)
#define O64_Interface__Interface_Operation_isHoisted(THIS) (&(THIS)->Interface_Operation_isHoisted)
#define O64_Interface_Interface_Label_identity(THIS) ((THIS)->Interface_Label_identity)
#define O64_Interface__Interface_Label_identity(THIS) (&(THIS)->Interface_Label_identity)
#define O64_Interface_Interface_Label_name(THIS) ((THIS)->Interface_Label_name)
#define O64_Interface__Interface_Label_name(THIS) (&(THIS)->Interface_Label_name)
#define O64_Interface_Interface_BasicBlock_identity(THIS) ((THIS)->Interface_BasicBlock_identity)
#define O64_Interface__Interface_BasicBlock_identity(THIS) (&(THIS)->Interface_BasicBlock_identity)
#define O64_Interface_Interface_BasicBlock_unrolled(THIS) ((THIS)->Interface_BasicBlock_unrolled)
#define O64_Interface__Interface_BasicBlock_unrolled(THIS) (&(THIS)->Interface_BasicBlock_unrolled)
#define O64_Interface_Interface_BasicBlock_traceId(THIS) ((THIS)->Interface_BasicBlock_traceId)
#define O64_Interface__Interface_BasicBlock_traceId(THIS) (&(THIS)->Interface_BasicBlock_traceId)
#define O64_Interface_Interface_LoopScope_identity(THIS) ((THIS)->Interface_LoopScope_identity)
#define O64_Interface__Interface_LoopScope_identity(THIS) (&(THIS)->Interface_LoopScope_identity)
#define O64_Interface_Interface_LoopScope_unrolled(THIS) ((THIS)->Interface_LoopScope_unrolled)
#define O64_Interface__Interface_LoopScope_unrolled(THIS) (&(THIS)->Interface_LoopScope_unrolled)
#define O64_Interface_Interface_makeOperation(THIS) ((THIS)->Interface_makeOperation)
#define O64_Interface__Interface_makeOperation(THIS) (&(THIS)->Interface_makeOperation)
#define O64_Interface_Interface_findOperation(THIS) ((THIS)->Interface_findOperation)
#define O64_Interface__Interface_findOperation(THIS) (&(THIS)->Interface_findOperation)
#define O64_Interface_Interface_Operation_setSafeAccess(THIS) ((THIS)->Interface_Operation_setSafeAccess)
#define O64_Interface__Interface_Operation_setSafeAccess(THIS) (&(THIS)->Interface_Operation_setSafeAccess)
#define O64_Interface_Interface_Operation_setHoisted(THIS) ((THIS)->Interface_Operation_setHoisted)
#define O64_Interface__Interface_Operation_setHoisted(THIS) (&(THIS)->Interface_Operation_setHoisted)
#define O64_Interface_Interface_Operation_setVolatile(THIS) ((THIS)->Interface_Operation_setVolatile)
#define O64_Interface__Interface_Operation_setVolatile(THIS) (&(THIS)->Interface_Operation_setVolatile)
#define O64_Interface_Interface_Operation_setPrefetch(THIS) ((THIS)->Interface_Operation_setPrefetch)
#define O64_Interface__Interface_Operation_setPrefetch(THIS) (&(THIS)->Interface_Operation_setPrefetch)
#define O64_Interface_Interface_Operation_setPreload(THIS) ((THIS)->Interface_Operation_setPreload)
#define O64_Interface__Interface_Operation_setPreload(THIS) (&(THIS)->Interface_Operation_setPreload)
#define O64_Interface_Interface_Operation_setBarrier(THIS) ((THIS)->Interface_Operation_setBarrier)
#define O64_Interface__Interface_Operation_setBarrier(THIS) (&(THIS)->Interface_Operation_setBarrier)
#define O64_Interface_Interface_Operation_setSafePerfs(THIS) ((THIS)->Interface_Operation_setSafePerfs)
#define O64_Interface__Interface_Operation_setSafePerfs(THIS) (&(THIS)->Interface_Operation_setSafePerfs)
#define O64_Interface_Interface_Operation_setSpillCode(THIS) ((THIS)->Interface_Operation_setSpillCode)
#define O64_Interface__Interface_Operation_setSpillCode(THIS) (&(THIS)->Interface_Operation_setSpillCode)
#define O64_Interface_Interface_makeBasicBlock(THIS) ((THIS)->Interface_makeBasicBlock)
#define O64_Interface__Interface_makeBasicBlock(THIS) (&(THIS)->Interface_makeBasicBlock)
#define O64_Interface_Interface_findBasicBlock(THIS) ((THIS)->Interface_findBasicBlock)
#define O64_Interface__Interface_findBasicBlock(THIS) (&(THIS)->Interface_findBasicBlock)
#define O64_Interface_Interface_linkBasicBlocks(THIS) ((THIS)->Interface_linkBasicBlocks)
#define O64_Interface__Interface_linkBasicBlocks(THIS) (&(THIS)->Interface_linkBasicBlocks)
#define O64_Interface_Interface_makeLoopScope(THIS) ((THIS)->Interface_makeLoopScope)
#define O64_Interface__Interface_makeLoopScope(THIS) (&(THIS)->Interface_makeLoopScope)
#define O64_Interface_Interface_findLoopScope(THIS) ((THIS)->Interface_findLoopScope)
#define O64_Interface__Interface_findLoopScope(THIS) (&(THIS)->Interface_findLoopScope)
#define O64_Interface_Interface_LoopScope_setDependenceNode(THIS) ((THIS)->Interface_LoopScope_setDependenceNode)
#define O64_Interface__Interface_LoopScope_setDependenceNode(THIS) (&(THIS)->Interface_LoopScope_setDependenceNode)
#define O64_Interface_Interface_LoopScope_setDependenceArc(THIS) ((THIS)->Interface_LoopScope_setDependenceArc)
#define O64_Interface__Interface_LoopScope_setDependenceArc(THIS) (&(THIS)->Interface_LoopScope_setDependenceArc)
#define O64_Interface_Interface_setBody(THIS) ((THIS)->Interface_setBody)
#define O64_Interface__Interface_setBody(THIS) (&(THIS)->Interface_setBody)
#define O64_Interface_Interface_setEntry(THIS) ((THIS)->Interface_setEntry)
#define O64_Interface__Interface_setEntry(THIS) (&(THIS)->Interface_setEntry)
#define O64_Interface_Interface_setExit(THIS) ((THIS)->Interface_setExit)
#define O64_Interface__Interface_setExit(THIS) (&(THIS)->Interface_setExit)
#define O64_Interface_Interface_setStart(THIS) ((THIS)->Interface_setStart)
#define O64_Interface__Interface_setStart(THIS) (&(THIS)->Interface_setStart)
#define O64_Interface_Interface_updateCGIR(THIS) ((THIS)->Interface_updateCGIR)
#define O64_Interface__Interface_updateCGIR(THIS) (&(THIS)->Interface_updateCGIR)
#define O64_Interface_Interface_open(THIS) ((THIS)->Interface_open)
#define O64_Interface__Interface_open(THIS) (&(THIS)->Interface_open)
#define O64_Interface_Interface_optimize(THIS) ((THIS)->Interface_optimize)
#define O64_Interface__Interface_optimize(THIS) (&(THIS)->Interface_optimize)
#define O64_Interface_Interface_close(THIS) ((THIS)->Interface_close)
#define O64_Interface__Interface_close(THIS) (&(THIS)->Interface_close)


/*
 * O64_getInstance --	The singleton O64_Interface instance.
 */
O64_Interface
O64_getInstance(void);

/*
 * Accessors to the O64_Interface functions.
 * O64_instance must be an O64_Interface object.
 */
#define O64_Interface_Initialize (*O64_instance->Interface_Initialize)
#define O64_Interface_Finalize (*O64_instance->Interface_Finalize)
#define O64_Interface_getInstance (*O64_instance->Interface_getInstance)
#define O64_Interface_setMaxIssue (*O64_instance->Interface_setMaxIssue)
#define O64_Interface_setMinTaken (*O64_instance->Interface_setMinTaken)
#define O64_Interface_setReserved (*O64_instance->Interface_setReserved)
#define O64_Interface_setArgStage (*O64_instance->Interface_setArgStage)
#define O64_Interface_setResStage (*O64_instance->Interface_setResStage)
#define O64_Interface_makeLabel (*O64_instance->Interface_makeLabel)
#define O64_Interface_findLabel (*O64_instance->Interface_findLabel)
#define O64_Interface_makeSymbol (*O64_instance->Interface_makeSymbol)
#define O64_Interface_Symbol_setClasses (*O64_instance->Interface_Symbol_setClasses)
#define O64_Interface_findSymbol (*O64_instance->Interface_findSymbol)
#define O64_Interface_makeDedicatedTemporary (*O64_instance->Interface_makeDedicatedTemporary)
#define O64_Interface_makeAssignedTemporary (*O64_instance->Interface_makeAssignedTemporary)
#define O64_Interface_makeVirtualTemporary (*O64_instance->Interface_makeVirtualTemporary)
#define O64_Interface_makeAbsoluteTemporary (*O64_instance->Interface_makeAbsoluteTemporary)
#define O64_Interface_makeSymbolTemporary (*O64_instance->Interface_makeSymbolTemporary)
#define O64_Interface_makeLabelTemporary (*O64_instance->Interface_makeLabelTemporary)
#define O64_Interface_Temporary_setWidth (*O64_instance->Interface_Temporary_setWidth)
#define O64_Interface_Temporary_setRemater (*O64_instance->Interface_Temporary_setRemater)
#define O64_Interface_Temporary_setHomeable (*O64_instance->Interface_Temporary_setHomeable)
#define O64_Interface_Temporary_setDedicated (*O64_instance->Interface_Temporary_setDedicated)
#define O64_Interface_findTemporary (*O64_instance->Interface_findTemporary)
#define O64_Interface_Temporary_identity (*O64_instance->Interface_Temporary_identity)
#define O64_Interface_Temporary_isAbsolute (*O64_instance->Interface_Temporary_isAbsolute)
#define O64_Interface_Temporary_value (*O64_instance->Interface_Temporary_value)
#define O64_Interface_Temporary_isSymbol (*O64_instance->Interface_Temporary_isSymbol)
#define O64_Interface_Temporary_symbol (*O64_instance->Interface_Temporary_symbol)
#define O64_Interface_Temporary_offset (*O64_instance->Interface_Temporary_offset)
#define O64_Interface_Temporary_invariant (*O64_instance->Interface_Temporary_invariant)
#define O64_Interface_Temporary_isVirtual (*O64_instance->Interface_Temporary_isVirtual)
#define O64_Interface_Temporary_isDedicated (*O64_instance->Interface_Temporary_isDedicated)
#define O64_Interface_Temporary_isAssigned (*O64_instance->Interface_Temporary_isAssigned)
#define O64_Interface_Temporary_register (*O64_instance->Interface_Temporary_register)
#define O64_Interface_Temporary_regFile (*O64_instance->Interface_Temporary_regFile)
#define O64_Interface_Symbol_identity (*O64_instance->Interface_Symbol_identity)
#define O64_Interface_Symbol_name (*O64_instance->Interface_Symbol_name)
#define O64_Interface_Symbol_isSpill (*O64_instance->Interface_Symbol_isSpill)
#define O64_Interface_Symbol_nativeType (*O64_instance->Interface_Symbol_nativeType)
#define O64_Interface_Operation_identity (*O64_instance->Interface_Operation_identity)
#define O64_Interface_Operation_operator (*O64_instance->Interface_Operation_operator)
#define O64_Interface_Operation_iteration (*O64_instance->Interface_Operation_iteration)
#define O64_Interface_Operation_startDate (*O64_instance->Interface_Operation_startDate)
#define O64_Interface_Operation_isSpillCode (*O64_instance->Interface_Operation_isSpillCode)
#define O64_Interface_Operation_isVolatile (*O64_instance->Interface_Operation_isVolatile)
#define O64_Interface_Operation_isHoisted (*O64_instance->Interface_Operation_isHoisted)
#define O64_Interface_Label_identity (*O64_instance->Interface_Label_identity)
#define O64_Interface_Label_name (*O64_instance->Interface_Label_name)
#define O64_Interface_BasicBlock_identity (*O64_instance->Interface_BasicBlock_identity)
#define O64_Interface_BasicBlock_unrolled (*O64_instance->Interface_BasicBlock_unrolled)
#define O64_Interface_BasicBlock_traceId (*O64_instance->Interface_BasicBlock_traceId)
#define O64_Interface_LoopScope_identity (*O64_instance->Interface_LoopScope_identity)
#define O64_Interface_LoopScope_unrolled (*O64_instance->Interface_LoopScope_unrolled)
#define O64_Interface_makeOperation (*O64_instance->Interface_makeOperation)
#define O64_Interface_findOperation (*O64_instance->Interface_findOperation)
#define O64_Interface_Operation_setSafeAccess (*O64_instance->Interface_Operation_setSafeAccess)
#define O64_Interface_Operation_setHoisted (*O64_instance->Interface_Operation_setHoisted)
#define O64_Interface_Operation_setVolatile (*O64_instance->Interface_Operation_setVolatile)
#define O64_Interface_Operation_setPrefetch (*O64_instance->Interface_Operation_setPrefetch)
#define O64_Interface_Operation_setPreload (*O64_instance->Interface_Operation_setPreload)
#define O64_Interface_Operation_setBarrier (*O64_instance->Interface_Operation_setBarrier)
#define O64_Interface_Operation_setSafePerfs (*O64_instance->Interface_Operation_setSafePerfs)
#define O64_Interface_Operation_setSpillCode (*O64_instance->Interface_Operation_setSpillCode)
#define O64_Interface_makeBasicBlock (*O64_instance->Interface_makeBasicBlock)
#define O64_Interface_findBasicBlock (*O64_instance->Interface_findBasicBlock)
#define O64_Interface_linkBasicBlocks (*O64_instance->Interface_linkBasicBlocks)
#define O64_Interface_makeLoopScope (*O64_instance->Interface_makeLoopScope)
#define O64_Interface_findLoopScope (*O64_instance->Interface_findLoopScope)
#define O64_Interface_LoopScope_setDependenceNode (*O64_instance->Interface_LoopScope_setDependenceNode)
#define O64_Interface_LoopScope_setDependenceArc (*O64_instance->Interface_LoopScope_setDependenceArc)
#define O64_Interface_setBody (*O64_instance->Interface_setBody)
#define O64_Interface_setEntry (*O64_instance->Interface_setEntry)
#define O64_Interface_setExit (*O64_instance->Interface_setExit)
#define O64_Interface_setStart (*O64_instance->Interface_setStart)
#define O64_Interface_updateCGIR (*O64_instance->Interface_updateCGIR)
#define O64_Interface_open (*O64_instance->Interface_open)
#define O64_Interface_optimize (*O64_instance->Interface_optimize)
#define O64_Interface_close (*O64_instance->Interface_close)





/*
 * !!!!	Interface.xcc
 *
 * Benoit Dupont de Dinechin (Benoit.Dupont-de-Dinechin@st.com).
 * Francois de Ferriere (Francois.de-Ferriere@st.com).
 * Christophe Guillon (Christophe.Guillon@st.com).
 *
 * Copyright 2002 - 2007 STMicroelectronics.
 * Copyright 1995 - 1998 Commissariat a l'Energie Atomique.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of either (at your option): the GNU
 * General Public License (GPL) version 2; the GNU Lesser General
 * Public License (LGPL) version 2.1; any later version of these
 * licences as published by the Free Software Foundation.
 */

//
typedef void *InterfaceCGIR;
typedef void *LIR2CGIR;

/*
  InterfaceType -- Enumerate the Interface types in reverse mapping.
 */
typedef enum {
  InterfaceType_CGIR,
  InterfaceType_Label,
  InterfaceType_Symbol,
  InterfaceType_Temporary,
  InterfaceType_Operation,
  InterfaceType_BasicBlock,
  InterfaceType_LoopScope,
  InterfaceType_CGIRImport,
  InterfaceType_CGIRValid,
  InterfaceType__
} InterfaceType;
typedef uint8_t short_InterfaceType;

/*
 * InterfaceMapped --	Mapped value in the LIR2CGIR HTables.
 */
struct InterfaceMapped_ {
  //@args	void *cgir, InterfaceType type
  InterfaceCGIR CGIR; // The CGIR object mapped to.
  short_InterfaceType TYPE; // The LIR key object type.
};
typedef struct InterfaceMapped_ InterfaceMapped_, *InterfaceMapped;
typedef const struct InterfaceMapped_ *const_InterfaceMapped;
typedef struct InterfaceMapped_ * restrict_InterfaceMapped;

extern InterfaceMapped
InterfaceMapped_Ctor(InterfaceMapped THIS, void *cgir, InterfaceType type);

extern InterfaceMapped
InterfaceMapped_Copy(InterfaceMapped THIS, const_InterfaceMapped that);

extern void
InterfaceMapped_Dtor(InterfaceMapped THIS);

extern size_t
InterfaceMapped_Size(void *cgir, InterfaceType type);

#define InterfaceMapped_CGIR(THIS) ((THIS)->CGIR)
#define InterfaceMapped__CGIR(THIS) (&(THIS)->CGIR)
#define InterfaceMapped_TYPE(THIS) ((THIS)->TYPE)
#define InterfaceMapped__TYPE(THIS) (&(THIS)->TYPE)


/*
 * Interface --	Interface between the LAO LIR and a host compiler CGIR.
 *
 * The purpose of the interface is to maintain mappings between LIR Labels,
 * Symbols, Temporaries, Operations, BasicBlocks, LoopScopes, and the corresponding
 * host compiler CGIR (Code Generator Intermediate Representation) objects.
 *
 * There must not be more than one CGIR object mapped to the same LIR object
 * to ensure that all CGIR objects are correctly updated. This constraint
 * apply to all CGIR->LIR object tables.
 * However there may be more than one LIR object mapped to the same CGIR
 * object. So factorization of the objects in the CGIR side is allowed.
 * These duplicated LIR objects however should not be mutable as in THIS
 * case information from the LIR side may not be passed back to the CGIR
 * side. So the LIR->CGIR reversed tables may have several keys pointing
 * to the same CGIR object. In THIS case only one update is performed on
 * the CGIR object.
 */
struct Interface_;
typedef struct Interface_ Interface_, *Interface;
typedef const struct Interface_ *const_Interface;
typedef struct Interface_ * restrict_Interface;

/*
 * Interface_getInstance --	Returns the singleton Interface, for use by the LAO clients.
 */
Interface
Interface_getInstance(void);

//
int *Interface_Registers(int count, ...);

//
Label *
Interface_Labels(int count, ...);

//
Temporary *
Interface_Temporaries(int count, ...);

//
Operation *
Interface_Operations(int count, ...);

//
/*--------------------- LAO Interface Input Functions ------------------------*/

/*
 * Interface_setMaxIssue --	Set the processor max issue (override MDS information).
 */
void
Interface_setMaxIssue(Interface THIS, Processor processor, int maxIssue);

/*
 * Interface_setMinTaken --	Set the processor min taken (override MDS information).
 */
void
Interface_setMinTaken(Interface THIS, Processor processor, int minTaken);

/*
 * Interface_setReserved --	Set a register as reserved (override MDS information).
 */
void
Interface_setReserved(Interface THIS, Convention convention, Register reserved);

/*
 * Interface_setArgStage --	Set the argument read stage (override MDS information).
 */
bool
Interface_setArgStage(Interface THIS, Processor processor,
                      Operator operator, int index, int stage);

/*
 * Interface_setResStage --	Set the result write stage (override MDS information).
 */
bool
Interface_setResStage(Interface THIS, Processor processor,
                      Operator operator, int index, int stage);

/*
 * Interface_makeLabel --	Make a Label.
 */
Label
Interface_makeLabel(Interface THIS, CGIR_LAB cgir_lab, const char *name);

/*
 * Interface_findLabel --	Find a Label.
 */
Label
Interface_findLabel(Interface THIS, CGIR_LAB cgir_lab);

/*
 * Interface_makeSymbol --	Make a Symbol.
 */
Symbol
Interface_makeSymbol(Interface THIS, CGIR_SYM cgir_sym, const char *name);

/*
 * Interface_Symbol_setClasses --	Set the (class,store,export) for a Symbol.
 */
void
Interface_Symbol_setClasses(Interface THIS, Symbol symbol, SymbolClass sclass, SymbolStore sstore, SymbolExport sexport);

/*
 * Interface_findSymbol --	Find a Symbol.
 */
Symbol
Interface_findSymbol(Interface THIS, CGIR_SYM cgir_sym);

/*
 * Interface_makeDedicatedTemporary --	Make a Dedicated Temporary.
 */
Temporary
Interface_makeDedicatedTemporary(Interface THIS, CGIR_TN cgir_tn, Register cgir_register);

/*
 * Interface_makeAssignedTemporary --	Make a Assigned Temporary.
 */
Temporary
Interface_makeAssignedTemporary(Interface THIS, CGIR_TN cgir_tn, Register cgir_register);

/*
 * Interface_makeVirtualTemporary --	Make a Virtual Temporary.
 */
Temporary
Interface_makeVirtualTemporary(Interface THIS, CGIR_TN cgir_tn, RegFile regFile);

/*
 * Interface_makeAbsoluteTemporary --	Make an Absolute Temporary.
 */
Temporary
Interface_makeAbsoluteTemporary(Interface THIS, CGIR_TN cgir_tn, Immediate immediate, int64_t value);

/*
 * Interface_makeSymbolTemporary --	Make a Symbol Temporary.
 */
Temporary
Interface_makeSymbolTemporary(Interface THIS, CGIR_TN cgir_tn, Immediate immediate, Symbol symbol, int64_t offset);

/*
 * Interface_makeLabelTemporary --	Make a Label Temporary.
 */
Temporary
Interface_makeLabelTemporary(Interface THIS, CGIR_TN cgir_tn, Immediate immediate, Label label);

/*
 * Interface_Temporary_setWidth --	Set a Temporary bit-width.
 */
void
Interface_Temporary_setWidth(Interface THIS, Temporary temporary, unsigned width);

/*
 * Interface_Temporary_setRemater --	Set an Temporary as remat.
 */
void
Interface_Temporary_setRemater(Interface THIS, Temporary temporary, Temporary value);

/*
 * Interface_Temporary_setHomeable --	Set an Temporary as homeable to location.
 */
void
Interface_Temporary_setHomeable(Interface THIS, Temporary temporary, Temporary location);

/*
 * Interface_Temporary_setDedicated --	Set an Temporary as dedicated.
 */
void
Interface_Temporary_setDedicated(Interface THIS, Temporary temporary);

/*
 * Interface_findTemporary --	Find a Temporary.
 */
Temporary
Interface_findTemporary(Interface THIS, CGIR_TN cgir_tn);

//
/*--------------------- LAO Interface Accessors Functions ------------------------*/

/*
 * O64 Interface for queries on LAO Temporaries.
 */
uint32_t
Interface_Temporary_identity(Temporary temporary);
int
Interface_Temporary_isAbsolute(Temporary temporary);
int64_t
Interface_Temporary_value(Temporary temporary);
int
Interface_Temporary_isSymbol(Temporary temporary);
Symbol
Interface_Temporary_symbol(Temporary temporary);
int64_t
Interface_Temporary_offset(Temporary temporary);
Immediate
Interface_Temporary_invariant(Temporary temporary);
int
Interface_Temporary_isVirtual(Temporary temporary);
int
Interface_Temporary_isDedicated(Temporary temporary);
int
Interface_Temporary_isAssigned(Temporary temporary);
Register
Interface_Temporary_register(Temporary temporary);
RegFile
Interface_Temporary_regFile(Temporary temporary);

/*
 * O64Interface for queries on LAO Symbols.
 */
uint32_t
Interface_Symbol_identity(Symbol symbol);
const char *
Interface_Symbol_name(Symbol symbol);
int
Interface_Symbol_isSpill(Symbol symbol);
NativeType
Interface_Symbol_nativeType(Symbol symbol);

/*
 * O64 Interface for queries on LAO Operations.
 */
uint32_t
Interface_Operation_identity(Operation operation);
Operator
Interface_Operation_operator(Operation operation);
int
Interface_Operation_iteration(Operation operation);
int
Interface_Operation_startDate(Operation operation);
int
Interface_Operation_isSpillCode(Operation operation);
int
Interface_Operation_isVolatile(Operation operation);
int
Interface_Operation_isHoisted(Operation operation);

/*
 * O64 Interface for queries on LAO Labels.
 */
uint32_t
Interface_Label_identity(Label label);
const char *
Interface_Label_name(Label label);

/*
 * O64 Interface for queries on LAO BasicBlocks.
 */
uint32_t
Interface_BasicBlock_identity(BasicBlock basicBlock);
int
Interface_BasicBlock_unrolled(BasicBlock basicBlock);
intptr_t
Interface_BasicBlock_traceId(BasicBlock basicBlock);

/*
 * O64 Interface for queries on LAO LoopScopes.
 */
uint32_t
Interface_LoopScope_identity(LoopScope loopScope);
int
Interface_LoopScope_unrolled(LoopScope loopScope);

/*
 * Interface_makeOperation --	Make an Operation.
 */
Operation
Interface_makeOperation(Interface THIS, CGIR_OP cgir_op,
    Operator operator, int iteration, int argCount, Temporary arguments[],
    int resCount, Temporary results[], int regCount, int registers[]);

/*
 * Interface_findOperation --	Find a Operation.
 */
Operation
Interface_findOperation(Interface THIS, CGIR_OP cgir_op);

/*
 * Interface_Operation_setSafeAccess --	Set an Operation as safe memory access.
 */
void
Interface_Operation_setSafeAccess(Interface THIS, Operation operation);

/*
 * Interface_Operation_setSafePerfs --	Set an Operation as safe performance effects.
 */
void
Interface_Operation_setSafePerfs(Interface THIS, Operation operation);

/*
 * Interface_Operation_setHoisted --	Set an Operation as volatile.
 */
void
Interface_Operation_setHoisted(Interface THIS, Operation operation);

/*
 * Interface_Operation_setVolatile --	Set an Operation as volatile.
 */
void
Interface_Operation_setVolatile(Interface THIS, Operation operation);

/*
 * Interface_Operation_setPrefetch --	Set an Operation as memory prefetch.
 */
void
Interface_Operation_setPrefetch(Interface THIS, Operation operation);

/*
 * Interface_Operation_setPreload --	Set an Operation as memory preload.
 */
void
Interface_Operation_setPreload(Interface THIS, Operation operation);

/*
 * Interface_Operation_setBarrier --	Set an Operation as a memory barrier.
 */
void
Interface_Operation_setBarrier(Interface THIS, Operation operation);

/*
 * Interface_Operation_setSpillCode --	Set an Operation as spill code.
 */
void
Interface_Operation_setSpillCode(Interface THIS, Operation operation, Symbol symbol);

/*
 * Interface_makeBasicBlock --	Make a BasicBlock.
 */
BasicBlock
Interface_makeBasicBlock(Interface THIS, CGIR_BB cgir_bb, Processor processor,
                         int unrolled, int labelCount, Label labels[], int operationCount,
                         Operation operations[], intptr_t regionId, float frequency);

/*
 * Interface_findBasicBlock --	Find a BasicBlock.
 */
BasicBlock
Interface_findBasicBlock(Interface THIS, CGIR_BB cgir_bb);

/*
 * Interface_linkBasicBlocks --	Link two BasicBlocks.
 */
void
Interface_linkBasicBlocks(Interface THIS, BasicBlock tail_block,
                          BasicBlock head_block, float probability);

/*
 * Interface_makeLoopScope --	Make a LoopScope.
 */
LoopScope
Interface_makeLoopScope(Interface THIS, CGIR_LD cgir_ld, BasicBlock basicBlock,
                        Temporary temporary, ConfigureItem item, ...);

/*
 * Interface_findLoopScope --	Find a LoopScope.
 */
LoopScope
Interface_findLoopScope(Interface THIS, CGIR_LD cgir_ld);

/*
 * Interface_LoopScope_setDependenceNode --	Set Operation with a memory dependence node.
 */
void
Interface_LoopScope_setDependenceNode(Interface THIS, LoopScope loopScope, Operation operation, DependenceNode node);

/*
 * Interface_LoopScope_setDependenceArc --	Set a memory dependence arc between two operations.
 */
void
Interface_LoopScope_setDependenceArc(Interface THIS, LoopScope loopScope,
    Operation tail_operation, Operation head_operation, int latency, int omega, DependenceKind kind);

//
/*
 * Interface_setBody --	Set a BasicBlock as a body block.
 */
void
Interface_setBody(Interface THIS, BasicBlock basicBlock);

//
/*
 * Interface_setEntry --	Set a BasicBlock as an entry block.
 */
void
Interface_setEntry(Interface THIS, BasicBlock basicBlock);

//
/*
 * Interface_setExit --	Set a BasicBlock as an exit block.
 */
void
Interface_setExit(Interface THIS, BasicBlock basicBlock);

//
/*
 * Interface_setStart --	Set a BasicBlock as trace start block.
 */
void
Interface_setStart(Interface THIS, BasicBlock basicBlock);

//
/*--------------------- LAO Interface Output Functions -----------------------*/

/*
 * Interface_updateCGIR --	Update the CGIR from the LAO Interface.
 */
void
Interface_updateCGIR(Interface THIS, CGIR_CallBack callback);

//
/*--------------------- LAO Interface Control Functions ----------------------*/

/*
 * Interface_Initialize --	Initialize the interface, must be called once per process.
 */
void
Interface_Initialize(void);

/*
 * Interface_open --	Open THIS Interface.
 */
void
Interface_open(Interface THIS, const char *name, ConfigureItem item, ...);

/*
 * Interface_optimize --	Apply the LAO optimizations through THIS Interface.
 */
unsigned
Interface_optimize(Interface THIS, OptimizeItem item, ...);

/*
 * Interface_close --	Close THIS Interface.
 */
void
Interface_close(Interface THIS);

/*
 * Interface_Finalize --	Finalize the interface, must be called once per process.
 */
void
Interface_Finalize(void);
